# Foreign function interface for interfacing with C code.
#
# This module provides various types and methods for calling C code from Inko
# code.
#
# # Limitations
#
# * C code calling back into Inko code isn't supported
# * Only builtin types (e.g. Int and String) can be converted from/to C types
# * Memory management of C types has to be done manually (e.g. using `free()`)
# * Variadic arguments aren't supported
import std::clone::Clone
import std::cmp::Equal
import std::drop::Drop
import std::fmt::(Format, Formatter)
import std::hash::Hash
import std::index::(Index, SetIndex)
import std::int::ToInt
import std::process::(panic)
import std::set::Set

# The address used for NULL pointers.
let NULL_ADDRESS = 0x0

# The size (in bytes) of an Inko object header.
let HEADER_SIZE = 16

# A pointer to a C value.
class pub Pointer {
  # The raw pointer.
  let @raw: Any

  # Returns a `Pointer` wrapping the given raw pointer.
  fn pub static new(raw: Any) -> Self {
    Self { @raw = raw }
  }

  # Creates a pointer using the given memory address.
  fn pub static from_address(address: Int) -> Self {
    Self { @raw = _INKO.ffi_pointer_from_address(address) }
  }

  # Returns a NULL `Pointer`.
  fn pub static null -> Self {
    from_address(NULL_ADDRESS)
  }

  # Returns `true` if this `Pointer` is a NULL pointer.
  fn pub null? -> Bool {
    address == NULL_ADDRESS
  }

  # Returns the address of this `Pointer`.
  fn pub address -> Int {
    _INKO.ffi_pointer_address(@raw)
  }

  # Reads the value of a pointer into a certain type.
  #
  # The `type` argument specifies the `Type` of data that is being read.
  #
  # The `offset` argument is used to specify an offset in bytes (relative to the
  # pointer) to read from.
  fn pub read(type: Type, offset: Int) -> Any {
    _INKO.ffi_pointer_read(@raw, type.to_int, offset)
  }

  # Writes a value to the pointer.
  #
  # The `type` argument specifies the `Type` of data that is being written. The
  # `offset` argument can be used to specify an offset in bytes (relative to
  # the pointer) to write to.
  fn pub mut write(type: Type, offset: Int, value: Any) {
    _INKO.ffi_pointer_write(@raw, type.to_int, offset, value)
  }

  # Returns the underlying raw pointer.
  fn pub raw -> Any {
    @raw
  }

  # Returns a pointer to the raw pointer wrapped by `self` (aka a pointer
  # pointer).
  fn pub pointer -> Pointer {
    let addr = _INKO.ffi_pointer_address(self) + HEADER_SIZE

    Pointer.from_address(addr)
  }
}

impl Clone for Pointer {
  fn pub clone -> Pointer {
    Pointer.from_address(address)
  }
}

impl Equal for Pointer {
  # Returns `true` if `self` and the given `Pointer` point to the same memory
  # address.
  fn pub ==(other: ref Self) -> Bool {
    address == other.address
  }
}

impl Format for Pointer {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("Pointer(0x{address.to_base16})")
  }
}

# A dynamically loaded C library.
class pub Library {
  let @lib: Any

  # Dynamically loads a C library.
  #
  # The `names` argument is an `Array` of library names to use for loading the
  # library. These names are used in order to find the corresponding library.
  #
  # The names in this `Array` can either be the library name with extension,
  # such as `'libc.so.6'`, or absolute paths such as `'/usr/lib/libc.so.6'`.
  fn pub static new(names: ref Array[String]) -> Option[Self] {
    let lib = _INKO.ffi_library_open(names)

    if _INKO.is_undefined(lib) {
      Option.None
    } else {
      Option.Some(Self { @lib = lib })
    }
  }

  # Returns a `Pointer` pointing to the address of the given variable.
  fn pub variable(name: String) -> Option[Pointer] {
    let ptr = _INKO.ffi_pointer_attach(@lib, name)

    if _INKO.is_undefined(ptr) {
      Option.None
    } else {
      Option.Some(Pointer { @raw = ptr })
    }
  }

  # Loads a C function from the given library.
  #
  # # Panics
  #
  # This method panics if the argument types or return type are invalid.
  fn pub function(
    name: String,
    arguments: Array[Type],
    returns: Type
  ) -> Option[Function] {
    let args = arguments.into_iter.map fn (type) { type.to_int }.to_array
    let func = _INKO.ffi_function_attach(@lib, name, args, returns.to_int)

    if _INKO.is_undefined(func) {
      Option.None
    } else {
      Option.Some(Function { @func = func })
    }
  }
}

impl Drop for Library {
  fn mut drop {
    _INKO.ffi_library_drop(@lib)
  }
}

# A C function that can be called from Inko.
class pub Function {
  let @func: Any

  # Calls the function without providing any arguments.
  fn pub call0 -> Any {
    _INKO.ffi_function_call(@func)
  }

  # Calls the function with a single argument.
  fn pub call1(arg0: ref Any) -> Any {
    _INKO.ffi_function_call(@func, arg0)
  }

  # Calls the function with two arguments.
  fn pub call2(arg1: ref Any, arg2: ref Any) -> Any {
    _INKO.ffi_function_call(@func, arg1, arg2)
  }

  # Calls the function with three arguments.
  fn pub call3(arg1: ref Any, arg2: ref Any, arg3: ref Any) -> Any {
    _INKO.ffi_function_call(@func, arg1, arg2, arg3)
  }

  # Calls the function with four arguments.
  fn pub call4(
    arg1: ref Any, arg2: ref Any, arg3: ref Any, arg4: ref Any
  ) -> Any {
    _INKO.ffi_function_call(@func, arg1, arg2, arg3, arg4)
  }

  # Calls the function with five arguments.
  fn pub call5(
    arg1: ref Any, arg2: ref Any, arg3: ref Any, arg4: ref Any, arg5: ref Any
  ) -> Any {
    _INKO.ffi_function_call(@func, arg1, arg2, arg3, arg4, arg5)
  }

  # Calls the function with six arguments.
  fn pub call6(
    arg1: ref Any,
    arg2: ref Any,
    arg3: ref Any,
    arg4: ref Any,
    arg5: ref Any,
    arg6: ref Any,
  ) -> Any {
    _INKO.ffi_function_call(@func, arg1, arg2, arg3, arg4, arg5, arg6)
  }
}

impl Drop for Function {
  fn mut drop {
    _INKO.ffi_function_drop(@func)
  }
}

# A member in a structure.
class Member {
  let @name: String
  let @type: Type
  let @offset: Int
}

# The members, alignment, and other information used for building a C
# structure.
class pub Layout {
  # The members of this layout, mapped to their names.
  let @members: Map[String, Member]

  # The size (in bytes) of this layout.
  let pub @size: Int

  # The alignment to use for all fields. This equals the alignment of the
  # largest field.
  let pub @alignment: Int
}

# A C structure.
class pub Struct {
  let @layout: Layout

  # The pointer to the C address that contains the structure.
  let pub @pointer: Pointer

  fn pub static new(pointer: Pointer, layout: Layout) -> Self {
    Self { @pointer = pointer, @layout = layout }
  }

  # Returns the size in bytes of this `Struct`.
  fn pub size -> Int {
    @layout.size.clone
  }

  # Returns the alignment of the members in this `Struct`.
  fn pub alignment -> Int {
    @layout.alignment.clone
  }
}

impl Index[String, Any] for Struct {
  # Reads the value of the given struct member.
  #
  # This method will panic if the given member does not exist.
  fn pub index(index: String) -> Any {
    let member = @layout.members[index]

    @pointer.read(type: member.type.clone, offset: member.offset.clone)
  }
}

impl SetIndex[String, Any] for Struct {
  # Writes a value to a struct member.
  fn pub mut set_index(index: String, value: Any) {
    let member = @layout.members[index]
    let type = member.type.clone
    let offset = member.offset.clone

    @pointer.write(type, offset, value)
  }
}

# An object used for constructing an immutable `Layout`.
class pub LayoutBuilder {
  # The names of all members, in the order they are defined in.
  let @members: Array[String]

  # The types of all members, in the order they are defined in.
  let @types: Array[Type]

  # A Map that tracks which members have already been defined.
  let @existing: Set[String]

  # The alignment of the largest field.
  let @alignment: Int

  # A boolean indicating if members should be padded or not.
  let @padding: Bool

  fn pub static new -> Self {
    Self {
      @members = [],
      @types = [],
      @existing = Set.new,
      @alignment = 0,
      @padding = true
    }
  }

  # Disables the padding of members.
  fn pub mut no_padding {
    @padding = false
    @alignment = 1
  }

  # Defines a new member.
  #
  # Trying to redefine a member will result in a panic.
  fn pub mut field(name: String, value: Type) {
    if @existing.contains?(name) {
      panic("The field '{name}' is already defined")
    }

    # If padding is enabled we determine the structure's alignment based on the
    # alignment of the largest field.
    if @padding and { value.alignment > @alignment } {
      @alignment = value.alignment
    }

    @existing.insert(name.clone)
    @members.push(name)
    @types.push(value)
  }

  # Creates a new `Layout` based on the current state of this builder.
  fn pub move into_layout -> Layout {
    if @padding {
      into_layout_with_padding
    } else {
      into_layout_without_padding
    }
  }

  fn move into_layout_with_padding -> Layout {
    let members = Map.new
    let mut size = 0
    let mut offset = 0
    let mut remaining_in_hole = @alignment.clone
    let mut index = 0

    while index < @members.length {
      let name = @members[index]
      let type = @types[index]
      let type_align = type.alignment

      # If the value is too great to fit into the current hole, we need to add
      # padding to the current hole, then start over at the next hole.
      if type_align > remaining_in_hole {
        let padding = @alignment - remaining_in_hole

        size += padding
        offset += padding

        remaining_in_hole = @alignment.clone
      }

      members[name.clone] = Member {
        @name = name.clone,
        @type = type.clone,
        @offset = offset.clone
      }

      remaining_in_hole -= type_align

      size += type_align
      offset += type_align

      if remaining_in_hole == 0 { remaining_in_hole = @alignment.clone }

      index += 1
    }

    Layout {
      @members = members,
      @alignment = @alignment.clone,
      @size = size
    }
  }

  fn move into_layout_without_padding -> Layout {
    let members = Map.new
    let mut offset = 0
    let mut index = 0

    while index < @members.length {
      let name = @members[index]
      let type = @types[index]

      members[name.clone] = Member {
        @name = name.clone,
        @type = type.clone,
        @offset = offset.clone
      }

      offset += type.alignment
      index += 1
    }

    Layout {
      @members = members,
      @alignment = @alignment.clone,
      @size = offset
    }
  }
}

# An identifier for a C type.
class pub enum Type {
  # The C type `void`.
  case Void

  # The C type `void *`.
  case Pointer

  # The C type `double`.
  case F64

  # The C type `float`.
  case F32

  # The C type `char`.
  case I8

  # The C type `short`.
  case I16

  # The C type `int`.
  case I32

  # The C type `long`.
  case I64

  # The C type `unsigned char`.
  case U8

  # The C type `unsigned short`.
  case U16

  # The C type `unsigned int`.
  case U32

  # The C type `unsigned long`.
  case U64

  # The C type `size_t`
  case SizeT

  # The C type `char *`.
  case String

  # The C type `char *`, but for when you need a `ByteArray` instead of a
  # `String`.
  case ByteArray

  # Returns the size of this type in bytes.
  fn pub size -> Int {
    _INKO.ffi_type_size(to_int)
  }

  # Returns the alignment of this type in bytes.
  fn pub alignment -> Int {
    _INKO.ffi_type_alignment(to_int)
  }
}

impl ToInt for Type {
  fn pub to_int -> Int {
    match self {
      case Void -> 0
      case Pointer -> 1
      case F64 -> 2
      case F32 -> 3
      case I8 -> 4
      case I16 -> 5
      case I32 -> 6
      case I64 -> 7
      case U8 -> 8
      case U16 -> 9
      case U32 -> 10
      case U64 -> 11
      case String -> 12
      case ByteArray -> 13
      case SizeT -> 14
    }
  }
}

impl Clone for Type {
  fn pub clone -> Self {
    match self {
      case Void -> Type.Void
      case Pointer -> Type.Pointer
      case F64 -> Type.F64
      case F32 -> Type.F32
      case I8 -> Type.I8
      case I16 -> Type.I16
      case I32 -> Type.I32
      case I64 -> Type.I64
      case U8 -> Type.U8
      case U16 -> Type.U16
      case U32 -> Type.U32
      case U64 -> Type.U64
      case SizeT -> Type.SizeT
      case String -> Type.String
      case ByteArray -> Type.ByteArray
    }
  }
}

impl Equal for Type {
  fn pub ==(other: ref Self) -> Bool {
    to_int == other.to_int
  }
}

impl Format for Type {
  fn pub fmt(formatter: mut Formatter) {
    let write = match self {
      case Void -> 'void'
      case Pointer -> 'void*'
      case F64 -> 'double'
      case F32 -> 'float'
      case I8 -> 'char'
      case I16 -> 'short'
      case I32 -> 'int'
      case I64 -> 'long'
      case U8 -> 'unsignhed char'
      case U16 -> 'unsigned short'
      case U32 -> 'unsigned int'
      case U64 -> 'unsigned long'
      case SizeT -> 'size_t'
      case String -> 'String'
      case ByteArray -> 'ByteArray'
    }

    formatter.write(write)
  }
}
