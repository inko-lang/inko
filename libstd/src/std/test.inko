# A simple unit testing library.
#
# This module provides a simple and opinionated unit testing library. Tests are
# simply closures with a description, and define assertions using a `Test`
# instance passed as an argument to these closures.
#
# Unlike many other testing libraries, assertion failures don't immediately
# terminate the test, instead the test runs until the end. This ensures all
# failing assertions are immediately visible, instead of only the first
# assertion per failing test being visible.
#
# This module doesn't provide the means for setting up hooks (e.g. a function
# that runs before every or all tests), nor does it provide the means to tag
# tests, temporarily disable them, and more.
#
# Tests are run concurrently and in random order. The number of concurrently
# running tests is limited, with the default limit being the number of CPU cores
# available. This makes it easier to interact with external services, such as
# databases, as these may only be able to handle a limit number of concurrent
# requests.
#
# # Writing tests
#
# To write a test you need to import 'the' `Tests` type into your module of
# choice. You can then write your tests like so:
#
#     import 'std/test' (Tests)
#
#     class async Main {
#       fn async main {
#         let tests = Tests.new
#
#         tests.test('This is the test description') fn (t) {
#           t.equal('foo'.length, 3)
#         }
#
#         tests.run
#       }
#     }
#
# The closure passed to the `test` method must be a `uni` closure, otherwise it
# can't be sent to the process that runs the test. If you pass the closure
# directly (as shown above) no extra work is needed. If you decide to first
# store the closure in a variable, you must explicitly recover it:
#
#     import 'std/test' (Tests)
#
#     class async Main {
#       fn async main {
#         let tests = Tests.new
#         let block = recover fn (t: mut Tets) { t.equal('foo'.length, 3) }
#
#         tests.test('This is the test description', block)
#         tests.run
#       }
#     }
#
# For more information about the available assertions, refer to the
# documentation of the `Test` type.
import 'std/cmp' (Compare, Equal)
import 'std/debug'
import 'std/fmt'
import 'std/fs/path' (Path)
import 'std/io' (Write)
import 'std/process' (sleep, poll)
import 'std/rand' (Random, Shuffle)
import 'std/stdio' (STDOUT)
import 'std/sys'
import 'std/time' (Duration, Instant)

fn format(value: ref fmt::Format) -> String {
  let formatter: fmt::Formatter = fmt::DefaultFormatter.new

  value.fmt(formatter)
  formatter.into_string
}

# A single unit test.
class pub Test {
  # The unique ID of this test.
  #
  # This ID can be used when you want to create some sort of resource unique to
  # a test, such as a file. This removes the need for manually generating unique
  # names/paths/etc.
  let pub @id: Int

  # The name of the test as defined by the user.
  let pub @name: String

  # The path to the source file the test is defined in.
  let pub @path: Path

  # The line on which the test is defined.
  let pub @line: Int

  # All test failures produced when running the tests.
  let pub @failures: Array[Failure]

  # A closure containing the assertions to perform.
  let @code: uni fn (mut Test)

  # Returns a new `Test`.
  fn pub static new(
    id: Int,
    name: String,
    path: Path,
    line: Int,
    code: uni fn (mut Test)
  ) -> Self {
    Self {
      @id = id,
      @name = name,
      @path = path,
      @line = line,
      @failures = [],
      @code = code
    }
  }

  # Asserts that the given arguments are equal to each other.
  fn pub mut equal[T: Equal + fmt::Format](got: ref T, expected: ref T) {
    if got == expected { return }

    @failures.push(Failure.new(format(got), format(expected)))
  }

  # Asserts that the given arguments are not equal to each other.
  fn pub mut not_equal[T: Equal + fmt::Format](got: ref T, expected: ref T) {
    if got != expected { return }

    @failures.push(Failure.new(format(got), format(expected)))
  }

  # Asserts that `got` is greater than `minimum`.
  fn pub mut greater[T: Compare + fmt::Format](got: ref T, minimum: ref T) {
    if got > minimum { return }

    @failures.push(Failure.new(format(got), "> {format(minimum)}"))
  }

  # Asserts that the given value is `true`.
  fn pub mut true(value: Bool) {
    if value { return }

    @failures.push(Failure.new('false', 'true'))
  }

  # Asserts that the given value is `false`.
  fn pub mut false(value: Bool) {
    if value.false? { return }

    @failures.push(Failure.new('true', 'false'))
  }

  # Asserts that the given closure throws a value.
  fn pub mut throw[E](block: fn !! E) {
    try block.call else return

    @failures.push(Failure.new('no value is thrown', 'a value to be thrown'))
  }

  # Asserts that the given closure doesn't throw a value.
  fn pub mut no_throw[E: fmt::Format](block: fn !! E) {
    try block.call else (err) {
      @failures.push(Failure.new(format(err), 'no value is thrown'))
    }
  }
}

# A type used for reporting test progress.
trait pub Reporter {
  # Reports a test that passed.
  fn pub mut passed(test: Test)

  # Reports a test that failed.
  fn pub mut failed(test: Test)

  # Presents a summary of the test suite upon completion.
  #
  # The `duration` argument is set to the total execution time.
  #
  # The `seed` argument is the seed used to sort the tests in a random order.
  #
  # If any tests failed, this method must return `false`.
  fn pub move finished(duration: Duration, seed: Int) -> Bool
}

# A test reporter that writes to STDOUT.
class pub Plain {
  let @out: Write
  let @tests: Int
  let @failed: Array[Test]
  let @colors: Bool

  # Returns a new reporter that writes to the given output stream.
  fn pub static new(out: Write, colors: Bool) -> Self {
    Self { @out = out, @tests = 0, @failed = [], @colors = colors }
  }

  fn red(value: String) -> String {
    if @colors { "\e[31m{value}\e[0m" } else { value }
  }

  fn green(value: String) -> String {
    if @colors { "\e[32m{value}\e[0m" } else { value }
  }
}

impl Reporter for Plain {
  fn pub mut passed(test: Test) {
    @tests += 1

    try! @out.write_string(green('.'))
    try! @out.flush
  }

  fn pub mut failed(test: Test) {
    @tests += 1

    @failed.push(test)

    try! @out.write_string(red('F'))
    try! @out.flush
  }

  fn pub move finished(duration: Duration, seed: Int) -> Bool {
    let failed = @failed.length > 0

    if failed {
      try! @out.print("\n\nFailures:")

      @failed.iter.each_with_index fn (test_index, test) {
        test.failures.iter.each_with_index fn (failure_index, fail) {
          let num = "{test_index + failure_index + 1}."
          let indent = ' '.repeat(num.characters.count)

          try! @out.print(
            "
{num} Test: {test.name}
{indent} Line: {fail.path}:{fail.line}

{indent}   {green("expected:")} {fail.expected}
{indent}        {red("got:")} {fail.got}"
          )
        }
      }
    }

    let decimals = 4
    let dur = if duration.to_seconds >= 1.0 {
      "{duration.to_seconds.round(decimals)} seconds"
    } else {
      "{duration.to_milliseconds.round(decimals)} milliseconds"
    }

    let failures = if failed {
      red("{@failed.length} failures")
    } else {
      green('0 failures')
    }

    try! @out.print(
      "\nFinished running {@tests} tests in {dur}, {failures}, seed: {seed}"
    )

    @failed.empty?
  }
}

class async Runner {
  fn async run(test: uni Test) -> uni Test {
    recover {
      let test = recover test

      test.code.call(test)
      test
    }
  }
}

# A test failure produced by an assertion.
class pub Failure {
  # A description of what happened.
  let pub @got: String

  # A description of what was expected to happen.
  let pub @expected: String

  # The path to the source file in which the failure occurred.
  let pub @path: Path

  # The line on which the failure occurred.
  let pub @line: Int

  # Returns a new failure for the given reason.
  #
  # The source location is determined automatically based on the call stack.
  fn pub static new(got: String, expected: String) -> Self {
    # This skips the call to stacktrace(), the call to this new(), and its
    # caller (which would be e.g. `assert_equal`).
    match debug.stacktrace(skip: 3).pop.unwrap {
      case { @path = path, @line = line } -> Self {
        @got = got,
        @expected = expected,
        @path = path,
        @line = line
      }
    }
  }
}

# A collection of tests to run.
class pub Tests {
  # The number of tests to run concurrently.
  #
  # This defaults to the number of CPU cores.
  let pub @concurrency: Int

  # The reporter to use for producing test output.
  #
  # This defaults to the `Plain` reporter that writes to STDOUT.
  let pub @reporter: Reporter

  # The pattern to use for filtering out tests.
  #
  # By default no tests are filtered out.
  let pub @pattern: Option[String]

  # The seed to use for ordering the tests.
  #
  # Tests are sorted in random order before running them, in an attempt to
  # prevent them from depending on a specific execution order. When debugging
  # test failures it may be useful to set the seed to a fixed value, ensuring
  # tests are sorted in the same order.
  #
  # While this value affects the order in which tests are sorted and scheduled,
  # tests may finish in a different order. For example, given a seed S and tests
  # [A, B, C], the tests might be ordered as [C, B, A] but finish in the order
  # [B, C, A], due to tests being run concurrently. For a truly deterministic
  # execution order you'll also need to set the `concurrency` field to `1`.
  let pub @seed: Option[Int]

  let @tests: Array[uni Test]

  # Returns a new test tests with its default settings.
  fn pub static new -> Self {
    Self {
      @tests = [],
      @concurrency = sys.cpu_cores,
      @reporter = Plain.new(out: STDOUT.new, colors: sys.unix?),
      @pattern = Option.None,
      @seed = Option.None,
    }
  }

  # Registers a new test with the test tests.
  fn pub mut test(name: String, code: uni fn (mut Test)) {
    let id = @tests.length
    let test = recover {
      match debug.stacktrace(skip: 2).pop.unwrap {
        case { @path = path, @line = line } ->
          Test.new(id, name, path, line, code)
      }
    }

    @tests.push(test)
  }

  # Runs all the tests.
  fn pub move run {
    let tests = match @pattern {
      case Some(pat) -> {
        @tests
          .into_iter
          .select_map fn (test) {
            if test.name.contains?(pat) {
              Option.Some(test)
            } else {
              Option.None
            }
          }
          .to_array
      }
      case _ -> @tests
    }

    let seed = match @seed {
      case Some(seed) -> seed
      case _ -> Random.new.int
    }

    # We shuffle tests in a random order to ensure they don't end up
    # (implicitly) depending on a specific execution order.
    Shuffle.from_int(seed).sort(tests)

    let rep = @reporter
    let futures = []
    let start = Instant.new

    while tests.length > 0 or futures.length > 0 {
      # This schedules up to N concurrent tests, but only if we have any tests
      # left to schedule.
      while futures.length < @concurrency {
        match tests.pop {
          case Some(test) -> futures.push(async Runner {}.run(test))
          case _ -> break
        }
      }

      poll(futures).into_iter.each fn (fut) {
        let test: Test = fut.await

        if test.failures.empty? { rep.passed(test) } else { rep.failed(test) }
      }
    }

    if rep.finished(start.elapsed, seed) {
      sys.exit(status: 0)
    } else {
      sys.exit(status: 1)
    }
  }
}
