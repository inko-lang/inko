# The Int type.
import std::clone::Clone
import std::cmp::(Compare, Equal, Ordering)
import std::float::ToFloat
import std::fmt::(Format, Formatter)
import std::hash::(Hash, Hasher)
import std::ops::(
  Add, BitAnd, BitOr, BitXor, Divide, Modulo, Multiply, Power,
  ShiftLeft, ShiftRight, Subtract
)
import std::range::Range
import std::string::(ToString, StringBuffer)

# A type that can be converted to a Int.
trait pub ToInt {
  # Converts `self` to a `Int`
  fn pub to_int -> Int
}

# The minimum value an `Int` can represent.
let pub MIN = -9_223_372_036_854_775_808

# The maximum value an `Int` can represent.
let pub MAX = 9_223_372_036_854_775_807

# A 64-bits signed integer type.
#
# `Int` values can represent values in the range
# `-9223372036854775808 <= value <= 9223372036854775807`.
#
# # Panics
#
# Integer operations that would result in an overflow produce a panic.
class builtin Int {
  # Parses an `Int` from a `String`, using base 2.
  #
  # The `String` may start with `+` or `-`. Leading and/or trailing whitespace
  # is considered invalid.
  #
  # # Examples
  #
  #     Int.from_base2('11') # => Option.Some(3)
  #     Int.from_base2('ff') # => Option.None
  fn pub static from_base2(string: ref String) -> Option[Self] {
    let res = _INKO.string_to_int(string, 2, -1, -1)

    if _INKO.is_undefined(res) { Option.None } else { Option.Some(res) }
  }

  # Parses an `Int` from a `String`, using base 10.
  #
  # The `String` may start with `+` or `-`. Leading and/or trailing whitespace
  # is considered invalid.
  #
  # # Examples
  #
  #     Int.from_base10('12') # => Option.Some(12)
  #     Int.from_base10('ff') # => Option.None
  fn pub static from_base10(string: ref String) -> Option[Self] {
    let res = _INKO.string_to_int(string, 10, -1, -1)

    if _INKO.is_undefined(res) { Option.None } else { Option.Some(res) }
  }

  # Parses an `Int` from a `String`, using base 16.
  #
  # The `String` may start with `+` or `-`. Leading and/or trailing whitespace
  # is considered invalid.
  #
  # This method doesn't remove the usual `0x` prefix used for hexadecimal
  # numbers. If your string starts with such a prefix (e.g. `0xFF`), you must
  # remove it yourself.
  #
  # # Examples
  #
  #     Int.from_base16('ef') # => Option.Some(239)
  #     Int.from_base16('zz') # => Option.None
  fn pub static from_base16(string: ref String) -> Option[Self] {
    let res = _INKO.string_to_int(string, 16, -1, -1)

    if _INKO.is_undefined(res) { Option.None } else { Option.Some(res) }
  }

  # Formats `self` as a `String` using base 2.
  #
  # # Examples
  #
  #     3.to_base2  # => '11'
  #     -3.to_base2 # => '-11'
  fn pub to_base2 -> String {
    to_base(2)
  }

  # Formats `self` as a `String` using base 16.
  #
  # # Examples
  #
  #     123.to_base16  # => '7b'
  #     -123.to_base16 # => '-7b'
  fn pub to_base16 -> String {
    to_base(16)
  }

  # Calls the supplied closure `self` times.
  #
  # # Examples
  #
  #     4.times fn (i) {
  #       i # => 0, 1, 2, 3
  #     }
  fn pub times(block: fn (Int)) {
    let mut index = 0

    while index < self {
      block.call(index)

      index += 1
    }
  }

  # Returns the absolute value of `self`.
  #
  # # Examples
  #
  #     -4.absolute # => 4
  #     4.absolute  # => 4
  fn pub absolute -> Self {
    if self < 0 { 0 - self } else { clone }
  }

  # Returns a value with the opposite sign of `self`.
  #
  # # Examples
  #
  #     -42.opposite # => 42
  #     42.opposite  # => -42
  fn pub opposite -> Self {
    0 - self
  }

  # Returns a `Range` from `self` up to but excluding `other`.
  fn pub until(other: Int) -> Range {
    Range.exclusive(clone, other)
  }

  # Returns a `Range` from `self` up to and including `other`.
  fn pub to(other: Int) -> Range {
    Range.inclusive(clone, other)
  }

  # Returns the number of digits of `self`.
  #
  # # Examples
  #
  #     0.digits    # => 1
  #     10.digits   # => 2
  #     100.digits  # => 3
  #     -100.digits # => 3
  fn pub digits -> Int {
    if self == 0 { return 1 }

    let mut digits = 0
    let mut number = absolute

    while number > 0 {
      number /= 10
      digits += 1
    }

    digits
  }

  # Rounds `self` to the nearest power of two.
  #
  # If `self <= 0`, this method returns zero.
  #
  # # Examples
  #
  #     0.nearest_power_of_two # => 0
  #     1.nearest_power_of_two # => 1
  #     2.nearest_power_of_two # => 2
  #     3.nearest_power_of_two # => 4
  fn pub nearest_power_of_two -> Int {
    if self <= 0 { return 0 }

    let mut rounded = clone

    rounded -= 1
    rounded |= rounded >> 1
    rounded |= rounded >> 2
    rounded |= rounded >> 4
    rounded |= rounded >> 8
    rounded |= rounded >> 16
    rounded |= rounded >> 32
    rounded += 1

    rounded
  }

  # Formats `self` as a `String` in the given base.
  #
  # This method only supports a limited number of bases, and is marked as
  # private so we have more control over what bases we publicly support.
  fn to_base(base: Int) -> String {
    if self == 0 { return '0' }

    let alphabet = '0123456789abcdef'
    let bytes = []
    let mut int = absolute

    while int > 0 {
      bytes.push(alphabet.byte(int % base))

      int /= base
    }

    if self < 0 { bytes.push(45) }

    bytes.reverse
    ByteArray.from_array(bytes).into_string
  }
}

impl ToInt for Int {
  fn pub to_int -> Int {
    clone
  }
}

impl ToFloat for Int {
  fn pub to_float -> Float {
    _INKO.int_to_float(self)
  }
}

impl Compare for Int {
  fn pub cmp(other: ref Self) -> Ordering {
    if self > other {
      Ordering.Greater
    } else if self < other {
      Ordering.Less
    } else {
      Ordering.Equal
    }
  }

  fn pub <(other: ref Self) -> Bool {
    _INKO.int_lt(self, other)
  }

  fn pub <=(other: ref Self) -> Bool {
    _INKO.int_le(self, other)
  }

  fn pub >(other: ref Self) -> Bool {
    _INKO.int_gt(self, other)
  }

  fn pub >=(other: ref Self) -> Bool {
    _INKO.int_ge(self, other)
  }
}

impl Equal for Int {
  fn pub ==(other: ref Int) -> Bool {
    _INKO.int_eq(self, other)
  }
}

impl Clone for Int {
  fn pub clone -> Self {
    _INKO.int_clone(self)
  }
}

impl ToString for Int {
  fn pub to_string -> String {
    _INKO.int_to_string(self)
  }
}

impl Add[Int] for Int {
  fn pub +(other: ref Self) -> Self {
    _INKO.int_add(self, other)
  }
}

impl Subtract[Int] for Int {
  fn pub -(other: ref Self) -> Self {
    _INKO.int_sub(self, other)
  }
}

impl Divide for Int {
  fn pub /(other: ref Self) -> Self {
    _INKO.int_div(self, other)
  }
}

impl Multiply for Int {
  fn pub *(other: ref Self) -> Self {
    _INKO.int_mul(self, other)
  }
}

impl Modulo for Int {
  fn pub %(other: ref Self) -> Self {
    _INKO.int_mod(self, other)
  }
}

impl BitAnd for Int {
  fn pub &(other: ref Self) -> Self {
    _INKO.int_bit_and(self, other)
  }
}

impl BitOr for Int {
  fn pub |(other: ref Self) -> Self {
    _INKO.int_bit_or(self, other)
  }
}

impl BitXor for Int {
  fn pub ^(other: ref Self) -> Self {
    _INKO.int_bit_xor(self, other)
  }
}

impl ShiftLeft for Int {
  fn pub <<(other: ref Self) -> Self {
    _INKO.int_shl(self, other)
  }
}

impl ShiftRight for Int {
  fn pub >>(other: ref Self) -> Self {
    _INKO.int_shr(self, other)
  }
}

impl Power for Int {
  fn pub **(other: ref Self) -> Self {
    _INKO.int_pow(self, other)
  }
}

impl Hash for Int {
  fn pub hash(hasher: mut Hasher) {
    hasher.write(clone)
  }
}

impl Format for Int {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write(to_string)
  }
}
