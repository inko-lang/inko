# Cryptographically secure random number generation.
import 'std/drop' (Drop)

# A cryptographically secure pseudo random number generator (CSPRNG).
#
# The algorithm used is unspecified but guaranteed to be cryptographically
# secure.
class pub Random {
  # The internal/low-level random number generator.
  let @rng: Any

  # Returns a new `Random` using the given `Int` as its seed.
  #
  # `Random` instances created using this method **are not** suitable for
  # cryptography, as a single `Int` doesn't produce enough entropy. For
  # cryptography you _must_ use `Random.new` instead.
  #
  # # Examples
  #
  #     import 'std/rand' (Random)
  #
  #     Random.from_int(42)
  fn pub static from_int(seed: Int) -> Self {
    Self { @rng = _INKO.random_from_int(seed) }
  }

  # Returns a new `Random` seeded using a cryptographically secure seed.
  #
  # Seeding is performed by the runtime using a thread-local random number
  # generator suitable for cryptography.
  #
  # # Examples
  #
  #     import 'std/rand' (Random)
  #
  #     Random.new
  fn pub static new -> Self {
    Self { @rng = _INKO.random_new }
  }

  # Returns a randomly generated `Int`.
  #
  # # Examples
  #
  #     import 'std/rand' (Random)
  #
  #     Random.new.int
  fn pub mut int -> Int {
    _INKO.random_int(@rng)
  }

  # Returns a randomly generated `Float`.
  #
  # # Examples
  #
  #     import 'std/rand' (Random)
  #
  #     Random.new.float
  fn pub mut float -> Float {
    _INKO.random_float(@rng)
  }

  # Returns a randomly generated `Int` in the given range.
  #
  # The returned value is in the range `start <= value < stop`. If
  # `start >= stop` is true, this method returns `0`.
  fn pub int_between(min: Int, max: Int) -> Int {
    _INKO.random_int_range(@rng, min, max)
  }

  # Returns a randomly generated `Float` in the given range.
  #
  # The returned value is in the range `start <= value < stop`. If
  # `start >= stop` is true, this method returns `0.0`.
  fn pub float_between(min: Float, max: Float) -> Float {
    _INKO.random_float_range(@rng, min, max)
  }

  # Returns a `ByteArray` containing randomly generated bytes.
  #
  # The returned `ByteArray` will contain exactly `size` bytes.
  #
  # # Panics
  #
  # This method might panic if no random bytes could be generated.
  fn pub bytes(size: Int) -> ByteArray {
    _INKO.random_bytes(@rng, size)
  }
}

impl Drop for Random {
  fn mut drop {
    _INKO.random_drop(@rng)
  }
}

# A type for sorting arrays in a random order.
class pub Shuffle {
  let @rng: Random

  # Returns a new `Shuffle` that sorts values in a random order.
  fn pub static new -> Self {
    Self { @rng = Random.new }
  }

  # Returns a new `Shuffle` that uses the given seed for sorting values.
  fn pub static from_int(seed: Int) -> Self {
    Self { @rng = Random.from_int(seed) }
  }

  # Sorts the values of the given `Array` in place such that they are in a
  # random order.
  #
  # The algorithm used by this method is Sattolo's algorithm. Some more details
  # on this are found here:
  #
  # - https://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle#Sattolo's_algorithm
  # - https://danluu.com/sattolo/
  # - https://rosettacode.org/wiki/Sattolo_cycle
  #
  # # Examples
  #
  #     import 'std/rand' (Shuffle)
  #
  #     let a = [10, 20]
  #
  #     Shuffle.new.sort(a)
  #     a # => [20, 10]
  fn pub mut sort[T](array: mut Array[T]) {
    # Note that the types produced by `array_get()` and `array_set()` are `Any`.
    # These values aren't dropped automatically, so there's no need to mark them
    # as moved to prevent them from being dropped after the swap.
    let mut swap = array.length - 1

    while swap > 0 {
      let swap_with = @rng.int_between(min: 0, max: swap)
      let swap_val = _INKO.array_get(array, swap)

      _INKO.array_set(array, swap, _INKO.array_set(array, swap_with, swap_val))

      swap -= 1
    }
  }
}
