# IP and Unix domain sockets.
import std::cmp::Equal
import std::drop::Drop
import std::fmt::(Format, Formatter)
import std::fs::path::Path
import std::io::(Error, Read, Write)
import std::net::ip::IpAddress
import std::string::ToString
import std::time::Duration

# The maximum value valid for a listen() call.
#
# Linux and FreeBSD do not allow for values greater than this as they internally
# use an u16, so we'll limit the backlog to this value. We don't use SOMAXCONN
# because it might be hardcoded. This means that setting `net.core.somaxconn` on
# Linux (for example) would have no effect.
let MAXIMUM_LISTEN_BACKLOG = 65_535

# The type of a socket.
class pub enum Type {
  # The type corresponding to `SOCK_STREAM`.
  case STREAM

  # The type corresponding to `SOCK_DGRAM`.
  case DGRAM

  # The type corresponding to `SOCK_SEQPACKET`.
  case SEQPACKET

  # The type corresponding to `SOCK_RAW`.
  case RAW

  # Converts a `Type` into the underlying `SOCK_*` integer.
  fn pub move into_int -> Int {
    match self {
      case STREAM -> 0
      case DGRAM -> 1
      case SEQPACKET -> 2
      case RAW -> 3
    }
  }
}

# An IPv4 or IPv6 socket address.
class pub SocketAddress {
  # The IPv4/IPv6 address of this socket address.
  #
  # This is stored as a `String` so we don't need to parse the address every
  # time a `SocketAddress` is created.
  let pub @address: String

  # The port number of this socket address.
  let pub @port: Int

  fn pub static new(address: String, port: Int) -> Self {
    Self { @address = address, @port = port }
  }

  # Returns the IPv4/IPv6 address associated with `self`.
  fn pub ip -> Option[IpAddress] {
    IpAddress.parse(@address)
  }
}

impl Equal for SocketAddress {
  # Returns `true` if `self` and `other` are the same.
  fn pub ==(other: ref Self) -> Bool {
    @address == other.address and @port == other.port
  }
}

impl Format for SocketAddress {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write("{@address}:{@port}")
  }
}

# A low-level, non-blocking IPv4 or IPv6 socket.
class pub Socket {
  let @fd: Any

  # Creates a new IPv4 socket.
  #
  # # Examples
  #
  #     import std::net::socket::(Type, Socket)
  #
  #     try! Socket.ipv4(Type.DGRAM)
  fn pub static ipv4(type: Type) !! Error -> Self {
    let id = type.into_int
    let fd = try _INKO.socket_allocate_ipv4(id) else (e) throw Error.from_int(e)

    Self { @fd = fd }
  }

  # Creates a new IPv6 socket.
  #
  # # Examples
  #
  #     import std::net::socket::(Type, Socket)
  #
  #     try! Socket.ipv6(Type.DGRAM)
  fn pub static ipv6(type: Type) !! Error -> Self {
    let id = type.into_int
    let fd = try _INKO.socket_allocate_ipv6(id) else (e) throw Error.from_int(e)

    Self { @fd = fd }
  }

  # Binds this socket to the specified address.
  #
  # # Examples
  #
  # Binding a socket:
  #
  #     import std::net::socket::(Socket, Type)
  #
  #     let socket = try! Socket.ipv4(Type.DGRAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  fn pub mut bind(ip: ref ToString, port: Int) !! Error {
    let addr = ip.to_string

    try _INKO.socket_bind(@fd, addr, port) else (e) throw Error.from_int(e)
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a socket:
  #
  #     import std::net::socket::(Socket, Type)
  #
  #     let listener = try! Socket.ipv4(Type.STREAM)
  #     let client = try! Socket.ipv4(Type.STREAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.listen
  #     try! client.connect(ip: '0.0.0.0', port: 9999)
  fn pub mut connect(ip: ref ToString, port: Int) !! Error {
    let addr = ip.to_string

    try _INKO.socket_connect(@fd, addr, port) else (e) throw Error.from_int(e)
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  #     import std::net::socket::(Socket, Type)
  #
  #     let socket = try! Socket.ipv4(Type.STREAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.listen
  fn pub mut listen !! Error {
    try {
      _INKO.socket_listen(@fd, MAXIMUM_LISTEN_BACKLOG)
    } else (e) {
      throw Error.from_int(e)
    }
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  #     import std::net::socket::(Socket, Type)
  #
  #     let listener = try! Socket.ipv4(Type.STREAM)
  #     let stream = try! Socket.ipv4(Type.STREAM)
  #
  #     try! listener.bind(ip: '0.0.0.0', port: 9999)
  #     try! listener.listen
  #
  #     try! stream.connect(ip: '0.0.0.0', port: 9999)
  #     try! stream.write_string('ping')
  #
  #     let client = try! listener.accept
  #     let buffer = ByteArray.new
  #
  #     try! client.read(into: buffer, size: 4)
  #
  #     buffer.to_string # => 'ping'
  fn pub accept !! Error -> Socket {
    let fd = try _INKO.socket_accept_ip(@fd) else (e) throw Error.from_int(e)

    Socket { @fd = fd }
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std::net::socket::(Socket, Type)
  #
  #     let socket = try! Socket.ipv4(Type.DGRAM)
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.send_string_to(string: 'hello', ip: '0.0.0.0', port: 9999)
  fn pub mut send_string_to(
    string: ref String,
    ip: ref ToString,
    port: Int
  ) !! Error -> Int {
    try {
      _INKO.socket_send_string_to(@fd, string, ip.to_string, port)
    } else (e) {
      throw Error.from_int(e)
    }
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std::net::socket::(Socket, Type)
  #
  #     let socket = try! Socket.ipv4(Type.DGRAM)
  #     let bytes = 'hello'.to_byte_array
  #
  #     try! socket.bind(ip: '0.0.0.0', port: 9999)
  #     try! socket.send_bytes_to(bytes: bytes, ip: '0.0.0.0', port: 9999)
  fn pub mut send_bytes_to(
    bytes: ByteArray,
    ip: ref ToString,
    port: Int
  ) !! Error -> Int {
    try {
      _INKO.socket_send_bytes_to(@fd, bytes, ip.to_string, port)
    } else (e) {
      throw Error.from_int(e)
    }
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  #     import std::net::socket::(Socket, Type)
  #
  #     let socket = try! Socket.ipv4(Type.DGRAM)
  #     let bytes = ByteArray.new
  #
  #     try! socket.send_string_to('hello', ip: '0.0.0.0', port: 9999)
  #
  #     let received_from = try! socket.receive_from(bytes: bytes, size: 5)
  #
  #     bytes.to_string       # => 'hello'
  #     received_from.address # => '0.0.0.0'
  #     received_from.port    # => 9999
  fn pub mut receive_from(
    bytes: ref ByteArray,
    size: Int
  ) !! Error -> SocketAddress {
    let raw_addr = try {
      _INKO.socket_receive_from(@fd, bytes, size)
    } else (e) {
      throw Error.from_int(e)
    }

    let addr = _INKO.socket_address_pair_address(raw_addr)
    let port = _INKO.socket_address_pair_port(raw_addr)

    _INKO.socket_address_pair_drop(raw_addr)
    SocketAddress.new(addr, port)
  }

  # Returns the local address of this socket.
  fn pub local_address !! Error -> SocketAddress {
    let raw_addr =
      try _INKO.socket_local_address(@fd) else (e) throw Error.from_int(e)
    let addr = _INKO.socket_address_pair_address(raw_addr)
    let port = _INKO.socket_address_pair_port(raw_addr)

    _INKO.socket_address_pair_drop(raw_addr)
    SocketAddress.new(addr, port)
  }

  # Returns the peer address of this socket.
  fn pub peer_address !! Error -> SocketAddress {
    let raw_addr =
      try _INKO.socket_peer_address(@fd) else (e) throw Error.from_int(e)
    let addr = _INKO.socket_address_pair_address(raw_addr)
    let port = _INKO.socket_address_pair_port(raw_addr)

    _INKO.socket_address_pair_drop(raw_addr)
    SocketAddress.new(addr, port)
  }

  # Returns the value of the `IP_TTL` option.
  fn pub ttl !! Error -> Int {
    try _INKO.socket_get_ttl(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `IP_TTL` option.
  fn pub mut ttl=(value: Int) !! Error {
    try _INKO.socket_set_ttl(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `IPV6_V6ONLY` option.
  fn pub only_ipv6? !! Error -> Bool {
    try _INKO.socket_get_only_v6(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `IPV6_V6ONLY` option.
  fn pub mut only_ipv6=(value: Bool) !! Error {
    try _INKO.socket_set_only_v6(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `TCP_NODELAY` option.
  fn pub no_delay? !! Error -> Bool {
    try _INKO.socket_get_nodelay(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `TCP_NODELAY` option.
  fn pub mut no_delay=(value: Bool) !! Error {
    try _INKO.socket_set_nodelay(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_BROADCAST` option.
  fn pub broadcast? !! Error -> Bool {
    try _INKO.socket_get_broadcast(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_BROADCAST` option.
  fn pub mut broadcast=(value: Bool) !! Error {
    try _INKO.socket_set_broadcast(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_LINGER` option.
  fn pub linger !! Error -> Duration {
    let seconds =
      try _INKO.socket_get_linger(@fd) else (e) throw Error.from_int(e)

    Duration.from_seconds(seconds)
  }

  # Sets the value of the `SO_LINGER` option.
  fn pub mut linger=(value: ref Duration) !! Error {
    let secs = value.to_seconds

    try _INKO.socket_set_linger(@fd, secs) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_RCVBUF` option.
  fn pub receive_buffer_size !! Error -> Int {
    try _INKO.socket_get_recv_size(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) !! Error {
    try _INKO.socket_set_recv_size(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_SNDBUF` option.
  fn pub send_buffer_size !! Error -> Int {
    try _INKO.socket_get_send_size(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) !! Error {
    try _INKO.socket_set_send_size(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_KEEPALIVE` option.
  fn pub keepalive !! Error -> Bool {
    try _INKO.socket_get_keepalive(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_KEEPALIVE` option.
  fn pub mut keepalive=(value: Bool) !! Error {
    try _INKO.socket_set_keepalive(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_REUSEADDR` option.
  fn pub reuse_address !! Error -> Bool {
    try _INKO.socket_get_reuse_address(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_REUSEADDR` option.
  fn pub mut reuse_address=(value: Bool) !! Error {
    try _INKO.socket_set_reuse_address(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the returned value
  # will be `false`.
  fn pub reuse_port !! Error -> Bool {
    try _INKO.socket_get_reuse_port(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the supplied
  # argument will be ignored.
  fn pub mut reuse_port=(value: Bool) !! Error {
    try _INKO.socket_set_reuse_port(@fd, value) else (e) throw Error.from_int(e)
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read !! Error {
    try _INKO.socket_shutdown_read(@fd) else (e) throw Error.from_int(e)
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write !! Error {
    try _INKO.socket_shutdown_write(@fd) else (e) throw Error.from_int(e)
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown !! Error {
    try _INKO.socket_shutdown_read_write(@fd) else (e) throw Error.from_int(e)
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    let fd = try _INKO.socket_try_clone(@fd) else (e) throw Error.from_int(e)

    Self { @fd = fd }
  }
}

impl Drop for Socket {
  fn mut drop {
    _INKO.socket_drop(@fd)
  }
}

impl Read for Socket {
  fn pub mut read(into: mut ByteArray, size: Int) !! Error -> Int {
    try _INKO.socket_read(@fd, into, size) else (e) throw Error.from_int(e)
  }
}

impl Write for Socket {
  fn pub mut write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try _INKO.socket_write_bytes(@fd, bytes) else (e) throw Error.from_int(e)
  }

  fn pub mut write_string(string: ref String) !! Error -> Int {
    try _INKO.socket_write_string(@fd, string) else (e) throw Error.from_int(e)
  }

  fn pub mut flush {
    # Sockets can't be flushed, so this method is just a noop.
  }
}

# A UDP socket.
#
# A `UdpSocket` can be used to easily create a bound UDP socket from an IP
# address and a port. Optionally a `UdpSocket` can be connected to another
# socket using `UdpSocket::connect`.
class pub UdpSocket {
  # The raw `Socket` wrapped by this `UdpSocket`.
  let pub @socket: Socket

  # Creates a new `UdpSocket`, bound to the given address.
  #
  # # Examples
  #
  # Creating a new bound UDP socket:
  #
  #     import std::net::socket::UdpSocket
  #     import std::net::ip::IpAddress
  #
  #     let ip = try! IpAddress.parse('0.0.0.0')
  #
  #     try! UdpSocket.new(ip, port: 0)
  fn pub static new(ip: IpAddress, port: Int) !! Error -> Self {
    let socket = if ip.v6? {
      try Socket.ipv6(Type.DGRAM)
    } else {
      try Socket.ipv4(Type.DGRAM)
    }

    try socket.bind(ip, port)

    Self { @socket = socket }
  }

  # Connects `self` to the remote address.
  #
  # Connecting a `UdpSocket` allows sending and receiving data using the
  # methods from `std::io::Read` and `std::io::Write`, instead of having to use
  # `UdpSocket.receive_from` and `UdpSocket.send_to`.
  #
  # # Examples
  #
  # Connecting a UDP socket:
  #
  #     import std::net::socket::UdpSocket
  #
  #     let socket1 = try! UdpSocket.new(ip: '0.0.0.0', port: 40_000)
  #     let socket2 = try! UdpSocket.new(ip: '0.0.0.0', port: 41_000)
  #
  #     try! socket1.connect(ip: '0.0.0.0', port: 41_000)
  fn pub mut connect(ip: ref ToString, port: Int) !! Error {
    try @socket.connect(ip, port)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `Socket.send_string_to` for more information.
  #
  # # Examples
  #
  #     import std::net::socket::UdpSocket
  #
  #     let socket = try! UdpSocket.new(ip: '0.0.0.0', port: 9999)
  #
  #     try! socket.send_string_to(string: 'hello', ip: '0.0.0.0', port: 9999)
  fn pub mut send_string_to(
    string: ref String,
    ip: ref ToString,
    port: Int
  ) !! Error -> Int {
    try @socket.send_string_to(string, ip, port)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `Socket.send_bytes_to` for more information.
  #
  # # Examples
  #
  #     import std::net::socket::UdpSocket
  #
  #     let socket = try! UdpSocket.new(ip: '0.0.0.0', port: 9999)
  #     let bytes = 'hello'.to_byte_array
  #
  #     try! socket.send_bytes_to(bytes: bytes, ip: '0.0.0.0', port: 9999)
  fn pub mut send_bytes_to(
    bytes: ByteArray,
    ip: ref ToString,
    port: Int
  ) !! Error -> Int {
    try @socket.send_bytes_to(bytes, ip, port)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # See the documentation of `Socket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: ref ByteArray,
    size: Int
  ) !! Error -> SocketAddress {
    try @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address !! Error -> SocketAddress {
    try @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    Self { @socket = try @socket.try_clone }
  }
}

impl Read for UdpSocket {
  fn pub mut read(into: mut ByteArray, size: Int) !! Error -> Int {
    try @socket.read(into, size)
  }
}

impl Write for UdpSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: ref String) !! Error -> Int {
    try @socket.write_string(string)
  }

  fn pub mut flush {}
}

# A TCP socket connected to another TCP socket.
class pub TcpClient {
  # The raw `Socket` wrapped by this `TcpClient`.
  let pub @socket: Socket

  # Creates a new `TcpClient` that is connected to the TCP socket at the given
  # IP address and port.
  #
  # # Examples
  #
  # Connecting a `TcpClient`:
  #
  #     import std::net::socket::TcpClient
  #     import std::net::ip::IpAddress
  #
  #     let ip = try! IpAddress.parse('127.0.0.1')
  #
  #     try! TcpClient.new(ip, port: 40_000)
  fn pub static new(ip: IpAddress, port: Int) !! Error -> Self {
    let socket = if ip.v6? {
      try Socket.ipv6(Type.STREAM)
    } else {
      try Socket.ipv4(Type.STREAM)
    }

    try socket.connect(ip, port)

    Self { @socket = socket }
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address !! Error -> SocketAddress {
    try @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `Socket.peer_address` for more information.
  fn pub peer_address !! Error -> SocketAddress {
    try @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read !! Error {
    try @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write !! Error {
    try @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown !! Error {
    try @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    Self { @socket = try @socket.try_clone }
  }
}

impl Read for TcpClient {
  fn pub mut read(into: mut ByteArray, size: Int) !! Error -> Int {
    try @socket.read(into, size)
  }
}

impl Write for TcpClient {
  fn pub mut write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: ref String) !! Error -> Int {
    try @socket.write_string(string)
  }

  fn pub mut flush {}
}

# A TCP socket server that can accept incoming connections.
class pub TcpServer {
  # The raw `Socket` wrapped by this `TcpServer`.
  let pub @socket: Socket

  # Creates a new `TcpServer` bound to and listening on the given IP address
  # and port.
  #
  # A `TcpServer` uses `SO_REUSEADDR` and `SO_REUSEPORT` to allow for fast
  # rebinding of sockets. `SO_REUSEPORT` is only used on platforms that support
  # it.
  #
  # The `only_ipv6` argument is ignored when binding to an IPv4 address.
  #
  # # Examples
  #
  # Creating a `TcpServer`:
  #
  #     import std::net::socket::TcpServer
  #     import std::net::ip::IpAddress
  #
  #     let ip = try! IpAddress.parse('0.0.0.0')
  #
  #     try! TcpServer.new(ip, port: 40_000)
  fn pub static new(ip: IpAddress, port: Int) !! Error -> Self {
    let socket = if ip.v6? {
      try Socket.ipv6(Type.STREAM)
    } else {
      try Socket.ipv4(Type.STREAM)
    }

    try socket.reuse_address = true
    try socket.reuse_port = true

    try socket.bind(ip, port)
    try socket.listen

    Self { @socket = socket }
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  #     import std::net::socket::(TcpServer, TcpClient)
  #
  #     let listener = try! TcpServer.new(ip: '127.0.0.1', port: 40_000)
  #     let client = try! TcpClient.new(ip: '127.0.0.1', port: 40_000)
  #
  #     client.write_string('ping')
  #
  #     let connection = try! listener.accept
  #     let buffer = ByteArray.new
  #
  #     try! connection.read(into: buffer, size: 4)
  #
  #     buffer.to_string # => 'ping'
  fn pub accept !! Error -> TcpClient {
    TcpClient { @socket = try @socket.accept }
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address !! Error -> SocketAddress {
    try @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    Self { @socket = try @socket.try_clone }
  }
}

# A Unix domain socket address.
class pub UnixAddress {
  # The path or name of the address.
  #
  # This is a `String` since using a `Path` does not make sense for abstract
  # and unnamed addresses.
  let pub @address: String

  # Creates a new `UnixAddress` from the given path or name.
  #
  # # Examples
  #
  # Creating a `UnixAddress` that uses a path:
  #
  #     import std::net::socket::UnixAddress
  #
  #     UnixAddress.new('/tmp/test.sock')
  #
  # Creating a `UnixAddress` that uses an unnamed address:
  #
  #     import std::net::socket::UnixAddress
  #
  #     UnixAddress.new('')
  #
  # Creating a `UnixAddress` that uses an abstract address:
  #
  #     import std::net::socket::UnixAddress
  #
  #     UnixAddress.new("\0example")
  fn pub static new(address: ref ToString) -> Self {
    Self { @address = address.to_string }
  }

  # Returns the path of this address.
  #
  # If the address is unnamed or an abstract address, None is returned.
  fn pub to_path -> Option[Path] {
    if unnamed? or abstract? {
      Option.None
    } else {
      Option.Some(@address.to_path)
    }
  }

  # Returns `true` if `self` is an abstract address.
  #
  # # Examples
  #
  # Checking if an address is abstract:
  #
  #     import std::net::socket::UnixAddress
  #
  #     UnixAddress.new('/tmp/test.sock').abstract?    # => false
  #     UnixAddress.new("\0example-address").abstract? # => true
  fn pub abstract? -> Bool {
    @address.starts_with?("\0")
  }

  # Returns `true` if `self` is an unnamed address.
  #
  # # Examples
  #
  # Checking if an address is unnamed:
  #
  #     import std::net::socket::UnixAddress
  #
  #     UnixAddress.new('/tmp/test.sock').unnamed? # => false
  #     UnixAddress.new('').unnamed?               # => true
  fn pub unnamed? -> Bool {
    @address.empty?
  }
}

impl Format for UnixAddress {
  fn pub fmt(formatter: mut Formatter) {
    let write = if abstract? {
      "@{@address.slice_bytes(start: 1, length: @address.size - 1)}"
    } else if unnamed? {
      'unnamed'
    } else {
      @address.clone
    }

    formatter.write(write)
  }
}

impl Equal for UnixAddress {
  # Returns `true` if `self` and `other` are the same socket addresses.
  #
  # # Examples
  #
  # Comparing two `UnixAddress` objects:
  #
  #     import std::net::socket::UnixAddress
  #
  #     UnixAddress.new('a.sock') == UnixAddress.new('a.sock') # => true
  #     UnixAddress.new('a.sock') == UnixAddress.new('b.sock') # => false
  fn pub ==(other: ref Self) -> Bool {
    @address == other.address
  }
}

impl ToString for UnixAddress {
  # Returns the address name or path as a `String`.
  #
  # # Examples
  #
  # Converting a `UnixAddress` to a `String`:
  #
  #     import std::net::socket::UnixAddress
  #
  #     UnixAddress.new('/tmp/test.sock').to_string # => '/tmp/test.sock'
  #     UnixAddress.new("\0example").to_string      # => "\0example"
  fn pub to_string -> String {
    @address.clone
  }
}

# A low-level, non-blocking Unix domain socket.
class pub UnixSocket {
  let @fd: Any

  # Creates a new Unix domain socket.
  #
  # # Examples
  #
  # Creating a new socket:
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     try! UnixSocket.new(Type.DGRAM)
  fn pub static new(type: Type) !! Error -> UnixSocket {
    let id = type.into_int
    let fd = try _INKO.socket_allocate_unix(id) else (e) throw Error.from_int(e)

    UnixSocket { @fd = fd }
  }

  # Binds this socket to the specified path or abstract address.
  #
  # # Examples
  #
  # Binding a Unix socket to a path:
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     let socket = try! UnixSocket.new(Type.DGRAM)
  #
  #     try! socket.bind('/tmp/test.sock')
  fn pub mut bind(path: ref ToString) !! Error {
    try _INKO.socket_bind(@fd, path.to_string, 0) else (e) {
      throw Error.from_int(e)
    }
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a Unix socket:
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     let listener = try! UnixSocket.new(Type.STREAM)
  #     let stream = try! UnixSocket.new(Type.STREAM)
  #
  #     try! listener.bind('/tmp/test.sock')
  #     try! listener.listen
  #
  #     try! stream.connect('/tmp/test.sock')
  fn pub mut connect(path: ref ToString) !! Error {
    try _INKO.socket_connect(@fd, path.to_string, 0) else (e) {
      throw Error.from_int(e)
    }
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     let socket = try! UnixSocket.new(Type.STREAM)
  #
  #     try! socket.bind('/tmp/test.sock')
  #     try! socket.listen
  fn pub mut listen !! Error {
    try {
      _INKO.socket_listen(@fd, MAXIMUM_LISTEN_BACKLOG)
    } else (e) {
      throw Error.from_int(e)
    }
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     let listener = try! UnixSocket.new(Type.STREAM)
  #     let stream = try! UnixSocket.new(Type.STREAM)
  #
  #     try! listener.bind('/tmp/test.sock')
  #     try! listener.listen
  #
  #     try! stream.connect('/tmp/test.sock')
  #     try! stream.write_string('ping')
  #
  #     let client = try! listener.accept
  #     let buffer = ByteArray.new
  #
  #     try! client.read(into: buffer, size: 4)
  #
  #     buffer.to_string # => 'ping'
  fn pub accept !! Error -> UnixSocket {
    let fd = try _INKO.socket_accept_unix(@fd) else (e) throw Error.from_int(e)

    UnixSocket { @fd = fd }
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     let socket = try! UnixSocket.new(Type.DGRAM)
  #
  #     try! socket.bind('/tmp/test.sock')
  #     try! socket.send_string_to(string: 'hello', address: '/tmp/test.sock')
  fn pub mut send_string_to(
    string: ref String,
    address: ref ToString
  ) !! Error -> Int {
    try {
      _INKO.socket_send_string_to(@fd, string, address.to_string, 0)
    } else (e) {
      throw Error.from_int(e)
    }
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     let socket = try! UnixSocket.new(Type.DGRAM)
  #     let bytes = 'hello'.to_byte_array
  #
  #     try! socket.bind('/tmp/test.sock')
  #     try! socket.send_bytes_to(bytes: bytes, address: '/tmp/test.sock')
  fn pub mut send_bytes_to(
    bytes: ByteArray,
    address: ref ToString
  ) !! Error -> Int {
    try {
      _INKO.socket_send_bytes_to(@fd, bytes, address.to_string, 0)
    } else (e) {
      throw Error.from_int(e)
    }
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  #     import std::net::socket::(Type, UnixSocket)
  #
  #     let socket = try! UnixSocket.new(Type.DGRAM)
  #     let bytes = ByteArray.new
  #
  #     try! socket.send_string_to('hello', address: '/tmp/test.sock')
  #
  #     let received_from = try! socket.receive_from(bytes: bytes, size: 5)
  #
  #     bytes.to_string         # => 'hello'
  #     received_from.to_string # => '/tmp/test.sock'
  fn pub mut receive_from(bytes: ref ByteArray, size: Int) !! Error -> UnixAddress {
    let raw_addr = try {
      _INKO.socket_receive_from(@fd, bytes, size)
    } else (e) {
      throw Error.from_int(e)
    }

    let addr = _INKO.socket_address_pair_address(raw_addr)

    _INKO.socket_address_pair_drop(raw_addr)
    UnixAddress.new(addr)
  }

  # Returns the local address of this socket.
  fn pub local_address !! Error -> UnixAddress {
    let raw_addr =
      try _INKO.socket_local_address(@fd) else (e) throw Error.from_int(e)
    let addr = _INKO.socket_address_pair_address(raw_addr)

    _INKO.socket_address_pair_drop(raw_addr)
    UnixAddress.new(addr)
  }

  # Returns the peer address of this socket.
  fn pub peer_address !! Error -> UnixAddress {
    let raw_addr =
      try _INKO.socket_peer_address(@fd) else (e) throw Error.from_int(e)
    let addr = _INKO.socket_address_pair_address(raw_addr)

    _INKO.socket_address_pair_drop(raw_addr)
    UnixAddress.new(addr)
  }

  # Returns the value of the `SO_RCVBUF` option.
  fn pub receive_buffer_size !! Error -> Int {
    try _INKO.socket_get_recv_size(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) !! Error {
    try _INKO.socket_set_recv_size(@fd, value) else (e) throw Error.from_int(e)
  }

  # Returns the value of the `SO_SNDBUF` option.
  fn pub send_buffer_size !! Error -> Int {
    try _INKO.socket_get_send_size(@fd) else (e) throw Error.from_int(e)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) !! Error {
    try _INKO.socket_set_send_size(@fd, value) else (e) throw Error.from_int(e)
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read !! Error {
    try _INKO.socket_shutdown_read(@fd) else (e) throw Error.from_int(e)
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write !! Error {
    try _INKO.socket_shutdown_write(@fd) else (e) throw Error.from_int(e)
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown !! Error {
    try _INKO.socket_shutdown_read_write(@fd) else (e) throw Error.from_int(e)
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    let fd = try _INKO.socket_try_clone(@fd) else (e) throw Error.from_int(e)

    Self { @fd = fd }
  }
}

impl Drop for UnixSocket {
  fn mut drop {
    _INKO.socket_drop(@fd)
  }
}

impl Read for UnixSocket {
  fn pub mut read(into: mut ByteArray, size: Int) !! Error -> Int {
    try _INKO.socket_read(@fd, into, size) else (e) throw Error.from_int(e)
  }
}

impl Write for UnixSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try _INKO.socket_write_bytes(@fd, bytes) else (e) throw Error.from_int(e)
  }

  fn pub mut write_string(string: ref String) !! Error -> Int {
    try _INKO.socket_write_string(@fd, string) else (e) throw Error.from_int(e)
  }

  fn pub mut flush {}
}

# A Unix datagram socket.
class pub UnixDatagram {
  # The raw `UnixSocket` wrapped by this `UnixDatagram`.
  let pub @socket: UnixSocket

  # Creates a new Unix datagram socket bound to the given address.
  #
  # # Examples
  #
  # Creating a new Unix datagram socket:
  #
  #     import std::net::socket::UnixDatagram
  #
  #     try! UnixDatagram.new('/tmp/test.sock')
  fn pub static new(address: ref ToString) !! Error -> Self {
    let socket = try UnixSocket.new(Type.DGRAM)

    try socket.bind(address)

    Self { @socket = socket }
  }

  # Connects `self` to the remote addres.s
  #
  # Connecting a `UnixDatagram` allows sending and receiving data using the
  # methods from `std::io::Read` and `std::io::Write`, instead of having to use
  # `UnixDatagram.receive_from` and `UnixDatagram.send_to`.
  #
  # # Examples
  #
  # Connecting a Unix datagram socket:
  #
  #     import std::net::socket::UnixDatagram
  #
  #     let socket1 = try! UnixDatagram.new('/tmp/test1.sock')
  #     let socket2 = try! UnixDatagram.new('/tmp/test2.sock')
  #
  #     try! socket1.connect('/tmp/test2.sock')
  fn pub mut connect(address: ref ToString) !! Error {
    try @socket.connect(address)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `UnixSocket.send_string_to` for more information.
  #
  # # Examples
  #
  #     import std::net::socket::UnixDatagram
  #
  #     let socket = try! UnixDatagram.new('/tmp/test.sock')
  #
  #     try! socket.send_string_to(string: 'hello', address: '/tmp/test.sock')
  fn pub mut send_string_to(
    string: String,
    address: ref ToString
  ) !! Error -> Int {
    try @socket.send_string_to(string, address)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `UnixSocket.send_bytes_to` for more information.
  #
  # # Examples
  #
  #     import std::net::socket::UnixDatagram
  #
  #     let socket = try! UnixDatagram.new('/tmp/test.sock')
  #     let bytes = 'hello'.to_byte_array
  #
  #     try! socket.send_bytes_to(bytes: bytes, address: '/tmp/test.sock')
  fn pub mut send_bytes_to(
    bytes: ByteArray,
    address: ref ToString
  ) !! Error -> Int {
    try @socket.send_bytes_to(bytes, address)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # See the documentation of `UnixSocket.receive_from` for more information.
  fn pub mut receive_from(bytes: ref ByteArray, size: Int) !! Error -> UnixAddress {
    try @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address !! Error -> UnixAddress {
    try @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    Self { @socket = try @socket.try_clone }
  }
}

impl Read for UnixDatagram {
  fn pub mut read(into: mut ByteArray, size: Int) !! Error -> Int {
    try @socket.read(into, size)
  }
}

impl Write for UnixDatagram {
  fn pub mut write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: ref String) !! Error -> Int {
    try @socket.write_string(string)
  }

  fn pub mut flush {}
}

# A Unix stream socket connected to another Unix socket.
class pub UnixClient {
  # The raw `UnixSocket` wrapped by this `UnixClient`.
  let pub @socket: UnixSocket

  # Creates a new `UnixClient` that is connected to the given address.
  #
  # # Examples
  #
  # Connecting a `UnixClient`:
  #
  #     import std::net::socket::(UnixServer, UnixClient)
  #
  #     let listener = try! UnixServer.new('/tmp/test.sock')
  #
  #     try! UnixClient.new('/tmp/test.sock')
  fn pub static new(address: ref ToString) !! Error -> Self {
    let socket = try UnixSocket.new(Type.STREAM)

    try socket.connect(address)

    Self { @socket = socket }
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address !! Error -> UnixAddress {
    try @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `UnixSocket.peer_address` for more information.
  fn pub peer_address !! Error -> UnixAddress {
    try @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read !! Error {
    try @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write !! Error {
    try @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown !! Error {
    try @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    Self { @socket = try @socket.try_clone }
  }
}

impl Read for UnixClient {
  fn pub mut read(into: mut ByteArray, size: Int) !! Error -> Int {
    try @socket.read(into, size)
  }
}

impl Write for UnixClient {
  fn pub mut write_bytes(bytes: ref ByteArray) !! Error -> Int {
    try @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: ref String) !! Error -> Int {
    try @socket.write_string(string)
  }

  fn pub mut flush {}
}

# A Unix socket server that can accept incoming connections.
class pub UnixServer {
  # The raw `UnixSocket` wrapped by this `UnixServer`.
  let pub @socket: UnixSocket

  # Creates a new `UnixServer` bound to and listening on the given address.
  #
  # The `backlog` argument can be used to set the listen backlog.
  #
  # # Examples
  #
  # Creating a `UnixServer`:
  #
  #     import std::net::socket::UnixServer
  #
  #     try! UnixServer.new('/tmp/test.sock')
  fn pub static new(address: ref ToString) !! Error -> Self {
    let socket = try UnixSocket.new(Type.STREAM)

    try socket.bind(address)
    try socket.listen

    Self { @socket = socket }
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  #     import std::net::socket::(UnixServer, UnixClient)
  #
  #     let listener = try! UnixServer.new('/tmp/test.sock')
  #     let client = try! UnixClient.new('/tmp/test.sock')
  #
  #     client.write_string('ping')
  #
  #     let connection = try! listener.accept
  #     let buffer = ByteArray.new
  #
  #     try! connection.read(into: buffer, size: 4)
  #
  #     buffer.to_string # => 'ping'
  fn pub accept !! Error -> UnixClient {
    UnixClient { @socket = try @socket.accept }
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address !! Error -> UnixAddress {
    try @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone !! Error -> Self {
    Self { @socket = try @socket.try_clone }
  }
}
