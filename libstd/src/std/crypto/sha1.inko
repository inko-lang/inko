# An implementation of the SHA1 hash function.
#
# SHA1 is _not_ cryptographically secure and you should avoid using it whenever
# possible.
#
# # Examples
#
#     import std::crypto::sha1::Sha1
#
#     let hasher = Sha1.new
#
#     hasher.write('hello'.to_byte_array)
#     hasher.finalize.to_string # => 'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d'
#
# You can also use `Sha1.hash`:
#
#     import std::crypto::sha1::Sha1
#
#     Sha1.hash('hello'.to_byte_array).to_string # => 'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d'
#
# # Limitations
#
# The implementation of SHA1 uses a 64-bits signed integer for tracking the
# total message size in bytes. This limits the total message size to 1024 PiB.
import std::crypto::hash::(Block, Hash, Hasher)
import std::crypto::math::(rotate_left_u32, to_u32)
import std::endian::big

let BLOCK_SIZE = 64

# A SHA1 hasher.
class pub Sha1 {
  let @block: Block
  let @words: Array[Int]
  let @size: Int
  let @a: Int
  let @b: Int
  let @c: Int
  let @d: Int
  let @e: Int

  # Generates a hash for the given bytes.
  #
  # # Examples
  #
  #     import std::crypto::sha1::Sha1
  #
  #     Sha1.hash('hello')
  fn pub static hash(bytes: ref ByteArray) -> Hash {
    let hasher = new

    hasher.write(bytes)
    hasher.finalize
  }

  # Returns a new instance of the hasher.
  fn pub static new -> Sha1 {
    Sha1 {
      @block = Block.new(BLOCK_SIZE),
      @words = Array.filled(with: 0, times: 80),
      @size = 0,
      @a = 0x67452301,
      @b = 0xEFCDAB89,
      @c = 0x98BADCFE,
      @d = 0x10325476,
      @e = 0xC3D2E1F0,
    }
  }

  fn mut compress {
    let words = @words

    0.until(16).iter.each fn (i) { words[i] = @block.read_u32_be(i * 4) }

    16.until(80).iter.each fn (i) {
      words[i] = rotate_left_u32(
        words[i - 3] ^ words[i - 8] ^ words[i - 14] ^ words[i - 16],
        1
      )
    }

    let mut a = @a
    let mut b = @b
    let mut c = @c
    let mut d = @d
    let mut e = @e
    let mut i = 0

    while i < 20 {
      let temp = to_u32(
        rotate_left_u32(a, 5)
          .wrapping_add((b & c) | (b.not & d))
          .wrapping_add(e)
          .wrapping_add(words[i])
          .wrapping_add(0x5A827999)
      )

      e = d
      d = c
      c = rotate_left_u32(b, 30)
      b = a
      a = temp
      i += 1
    }

    while i < 40 {
      let temp = to_u32(
        rotate_left_u32(a, 5)
          .wrapping_add(b ^ c ^ d)
          .wrapping_add(e)
          .wrapping_add(words[i])
          .wrapping_add(0x6ED9EBA1)
      )

      e = d
      d = c
      c = rotate_left_u32(b, 30)
      b = a
      a = temp
      i += 1
    }

    while i < 60 {
      let temp = to_u32(
        rotate_left_u32(a, 5)
          .wrapping_add((b & c) | (b & d) | (c & d))
          .wrapping_add(e)
          .wrapping_add(words[i])
          .wrapping_add(0x8F1BBCDC)
      )

      e = d
      d = c
      c = rotate_left_u32(b, 30)
      b = a
      a = temp
      i += 1
    }

    while i < 80 {
      let temp = to_u32(
        rotate_left_u32(a, 5)
          .wrapping_add(b ^ c ^ d)
          .wrapping_add(e)
          .wrapping_add(words[i])
          .wrapping_add(0xCA62C1D6)
      )

      e = d
      d = c
      c = rotate_left_u32(b, 30)
      b = a
      a = temp
      i += 1
    }

    @a = to_u32(a.wrapping_add(@a))
    @b = to_u32(b.wrapping_add(@b))
    @c = to_u32(c.wrapping_add(@c))
    @d = to_u32(d.wrapping_add(@d))
    @e = to_u32(e.wrapping_add(@e))
  }
}

impl Hasher for Sha1 {
  fn pub mut write(bytes: ref ByteArray) {
    @size += bytes.length
    @block.write_bytes(bytes) fn { compress }
  }

  fn pub move finalize -> Hash {
    @block.add_padding(8) fn { compress }
    @block.write_length_be(@size * 8, at: 56)
    compress

    let out = ByteArray.filled(with: 0, times: 20)

    big.write_u32(@a, into: out, at: 0)
    big.write_u32(@b, into: out, at: 4)
    big.write_u32(@c, into: out, at: 8)
    big.write_u32(@d, into: out, at: 12)
    big.write_u32(@e, into: out, at: 16)
    Hash.new(out)
  }
}
