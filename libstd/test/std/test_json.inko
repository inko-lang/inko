# import helpers::(fmt)
import helpers::(fmt)
import std::json::(self, Error, Json, Parser)
import std::test::Tests

fn parse(input: String) !! Error -> Json {
  try Parser.new(input).parse
}

fn parse_invalid(input: String) -> Option[String] {
  try Parser.new(input).parse else (err) { return Option.Some(err.to_string) }
  Option.None
}

fn pub tests(t: mut Tests) {
  t.test('Error.fmt') fn (t) {
    let err = Error { @message = 'foo', @line = 1, @offset = 5 }

    t.equal(fmt(err), 'foo, on line 1 at byte offset 5')
  }

  t.test('Error.to_string') fn (t) {
    let err = Error { @message = 'foo', @line = 1, @offset = 5 }

    t.equal(err.to_string, 'foo, on line 1 at byte offset 5')
  }

  t.test('Json.fmt') fn (t) {
    let map = Map.new

    map['a'] = Json.Int(10)

    t.equal(fmt(Json.Int(42)), 'Int(42)')
    t.equal(fmt(Json.Float(42.0)), 'Float(42.0)')
    t.equal(fmt(Json.String('test')), 'String("test")')
    t.equal(fmt(Json.Array([Json.Int(10)])), 'Array([Int(10)])')
    t.equal(fmt(Json.Object(map)), 'Object({"a": Int(10)})')
    t.equal(fmt(Json.Bool(true)), 'Bool(true)')
    t.equal(fmt(Json.Bool(false)), 'Bool(false)')
    t.equal(fmt(Json.Null), 'Null')
  }

  t.test('Json.==') fn (t) {
    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new

    map1['a'] = Json.Int(10)
    map2['a'] = Json.Int(10)
    map3['a'] = Json.Int(10)

    t.equal(Json.Int(10), Json.Int(10))
    t.not_equal(Json.Int(10), Json.Int(20))
    t.not_equal(Json.Int(10), Json.Float(20.0))

    t.equal(Json.Float(10.0), Json.Float(10.0))
    t.not_equal(Json.Float(10.0), Json.Float(20.0))
    t.not_equal(Json.Float(10.0), Json.Int(10))

    t.equal(Json.String('foo'), Json.String('foo'))
    t.not_equal(Json.String('foo'), Json.String('bar'))
    t.not_equal(Json.String('foo'), Json.Int(10))

    t.equal(Json.Array([Json.Int(10)]), Json.Array([Json.Int(10)]))
    t.not_equal(Json.Array([Json.Int(10)]), Json.Array([Json.Int(20)]))
    t.not_equal(Json.Array([Json.Int(10)]), Json.Int(10))

    t.equal(Json.Object(map1), Json.Object(map2))
    t.not_equal(Json.Object(map3), Json.Object(Map.new))
    t.not_equal(Json.Object(Map.new), Json.Int(10))

    t.equal(Json.Bool(true), Json.Bool(true))
    t.not_equal(Json.Bool(true), Json.Bool(false))
    t.not_equal(Json.Bool(true), Json.Int(10))

    t.equal(Json.Null, Json.Null)
    t.not_equal(Json.Null, Json.Int(10))
  }

  t.test('Json.to_string') fn (t) {
    let map = Map.new

    map['a'] = Json.Int(1)
    map['b'] = Json.Int(2)

    t.equal(Json.Int(42).to_string, '42')
    t.equal(Json.Float(1.2).to_string, '1.2')
    t.equal(Json.String('foo').to_string, '"foo"')
    t.equal(Json.String("a\nb").to_string, '"a\nb"')
    t.equal(Json.String("a\rb").to_string, '"a\rb"')
    t.equal(Json.String("a\tb").to_string, '"a\tb"')
    t.equal(Json.String("a\u{C}b").to_string, '"a\fb"')
    t.equal(Json.String("a\u{8}b").to_string, '"a\bb"')
    t.equal(Json.String('a\\b').to_string, '"a\\\\b"')
    t.equal(Json.Array([]).to_string, '[]')
    t.equal(Json.Array([Json.Int(1), Json.Int(2)]).to_string, '[1, 2]')
    t.equal(Json.Object(map).to_string, '{"a": 1, "b": 2}')
    t.equal(Json.Object(Map.new).to_string, '{}')
    t.equal(Json.Bool(true).to_string, 'true')
    t.equal(Json.Bool(false).to_string, 'false')
    t.equal(Json.Null.to_string, 'null')
  }

  t.test('Json.to_pretty_string') fn (t) {
    t.equal(Json.Int(42).to_pretty_string, '42')
    t.equal(Json.Float(1.2).to_pretty_string, '1.2')
    t.equal(Json.String('foo').to_pretty_string, '"foo"')
    t.equal(Json.String("a\nb").to_pretty_string, '"a\nb"')
    t.equal(Json.String("a\rb").to_pretty_string, '"a\rb"')
    t.equal(Json.String("a\tb").to_pretty_string, '"a\tb"')
    t.equal(Json.String("a\u{C}b").to_pretty_string, '"a\fb"')
    t.equal(Json.String("a\u{8}b").to_pretty_string, '"a\bb"')
    t.equal(Json.String('a\\b').to_pretty_string, '"a\\\\b"')
    t.equal(Json.Bool(true).to_pretty_string, 'true')
    t.equal(Json.Bool(false).to_pretty_string, 'false')
    t.equal(Json.Null.to_pretty_string, 'null')

    t.equal(Json.Array([]).to_pretty_string, '[]')
    t.equal(
      Json.Array([Json.Int(1), Json.Int(2)]).to_pretty_string,
      '[
  1,
  2
]'
    )

    t.equal(
      Json.Array([Json.Array([Json.Int(1), Json.Int(2)])]).to_pretty_string,
      '[
  [
    1,
    2
  ]
]'
    )

    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new

    map1['a'] = Json.Int(1)
    map1['b'] = Json.Int(2)
    map2['a'] = Json.Array([Json.Int(1), Json.Int(2)])
    map3['a'] = Json.Int(1)
    map3['b'] = Json.Object(map2)

    t.equal(Json.Object(Map.new).to_pretty_string, '{}')
    t.equal(
      Json.Object(map1).to_pretty_string,
      '{
  "a": 1,
  "b": 2
}'
    )

    t.equal(
      Json.Object(map3).to_pretty_string,
      '{
  "a": 1,
  "b": {
    "a": [
      1,
      2
    ]
  }
}'
    )
  }

  t.test('Parsing integers') fn (t) {
    t.try_equal(fn { try parse('0') }, Json.Int(0))
    t.try_equal(fn { try parse('42') }, Json.Int(42))
    t.try_equal(fn { try parse('  42') }, Json.Int(42))
    t.try_equal(fn { try parse('42   ') }, Json.Int(42))
    t.try_equal(fn { try parse("\t42") }, Json.Int(42))
    t.try_equal(fn { try parse("\r42") }, Json.Int(42))
    t.try_equal(fn { try parse('-42') }, Json.Int(-42))

    t.throw fn { try parse('00') }
    t.throw fn { try parse('10,') }
    t.throw fn { try parse('-') }
    t.throw fn { try parse('-01') }
    t.throw fn { try parse('01') }
    t.throw fn { try parse('1a') }
    t.throw fn { try parse('-a') }
  }

  t.test('Parsing floats') fn (t) {
    t.try_equal(fn { try parse('  1.2') }, Json.Float(1.2))
    t.try_equal(fn { try parse('1.2   ') }, Json.Float(1.2))
    t.try_equal(fn { try parse('1.2') }, Json.Float(1.2))
    t.try_equal(fn { try parse('-1.2') }, Json.Float(-1.2))
    t.try_equal(fn { try parse('1.2e+123') }, Json.Float(1.2e+123))
    t.try_equal(fn { try parse('1.2e-123') }, Json.Float(1.2e-123))
    t.try_equal(fn { try parse('1.2E+123') }, Json.Float(1.2e+123))
    t.try_equal(fn { try parse('1.2E-123') }, Json.Float(1.2e-123))
    t.try_equal(fn { try parse('-1.2E-123') }, Json.Float(-1.2e-123))
    t.try_equal(fn { try parse('0.0') }, Json.Float(0.0))
    t.try_equal(fn { try parse('0E0') }, Json.Float(0.0))
    t.try_equal(fn { try parse('0e+1') }, Json.Float(0.0))
    t.try_equal(fn { try parse('1.2E1') }, Json.Float(1.2e1))
    t.try_equal(fn { try parse('1.2e1') }, Json.Float(1.2e1))
    t.try_equal(
      fn { try parse('1.7976931348623157e+310') },
      Json.Float(Float.infinity)
    )
    t.try_equal(
      fn { try parse('4.940656458412465441765687928682213723651e-330') },
      Json.Float(0.0)
    )
    t.try_equal(
      fn { try parse('-0.000000000000000000000000000000000000000000000000000000000000000000000000000001') },
      Json.Float(-1.0E-78)
    )

    # These numbers are too big for regular integers, so we promote them to
    # floats.
    t.try_equal(
      fn { try parse('11111111111111111111111111111111111111111') },
      Json.Float(11111111111111111111111111111111111111111.0)
    )
    t.try_equal(
      fn { try parse('10000000000000000999') },
      Json.Float(10000000000000000999.0)
    )

    t.throw fn { try parse('00.0') }
    t.throw fn { try parse('1.2e') }
    t.throw fn { try parse('1.2e+') }
    t.throw fn { try parse('1.2e-') }
    t.throw fn { try parse('1.2E') }
    t.throw fn { try parse('1.2E+') }
    t.throw fn { try parse('1.2E-') }
    t.throw fn { try parse('1.2E+a') }
    t.throw fn { try parse('1.2E-a') }
    t.throw fn { try parse('0E') }
    t.throw fn { try parse('10.2,') }

    t.equal(
      parse_invalid("\n1.2e"),
      Option.Some(
        'One or more tokens are required, but we ran out of input, \
          on line 2 at byte offset 5'
      )
    )
  }

  t.test('Parsing arrays') fn (t) {
    t.try_equal(fn { try parse('[]') }, Json.Array([]))
    t.try_equal(fn { try parse('[10]') }, Json.Array([Json.Int(10)]))
    t.try_equal(
      fn { try parse('[10, 20]') },
      Json.Array([Json.Int(10), Json.Int(20)])
    )

    t.throw fn { try parse('[') }
    t.throw fn { try parse(']') }
    t.throw fn { try parse('[,10]') }
    t.throw fn { try parse('[10,]') }
    t.throw fn { try parse('[10') }
    t.throw fn { try parse('[10,') }
    t.throw fn { try parse('[10true]') }
    t.throw fn { try parse('[],') }

    t.throw fn {
      let parser = Parser.new('[[[[10]]]]')

      parser.max_depth = 2
      try parser.parse
    }
  }

  t.test('Parsing booleans') fn (t) {
    t.try_equal(fn { try parse('true') }, Json.Bool(true))
    t.try_equal(fn { try parse('false') }, Json.Bool(false))

    t.throw fn { try parse('t') }
    t.throw fn { try parse('tr') }
    t.throw fn { try parse('tru') }
    t.throw fn { try parse('f') }
    t.throw fn { try parse('fa') }
    t.throw fn { try parse('fal') }
    t.throw fn { try parse('fals') }
  }

  t.test('Parsing null') fn (t) {
    t.try_equal(fn { try parse('null') }, Json.Null)

    t.throw fn { try parse('n') }
    t.throw fn { try parse('nu') }
    t.throw fn { try parse('nul') }
  }

  t.test('Parsing strings') fn (t) {
    t.try_equal(fn { try parse('"foo"') }, Json.String('foo'))
    t.try_equal(fn { try parse('"foo bar"') }, Json.String('foo bar'))
    t.try_equal(fn { try parse('"foo\nbar"') }, Json.String("foo\nbar"))
    t.try_equal(fn { try parse('"foo\tbar"') }, Json.String("foo\tbar"))
    t.try_equal(fn { try parse('"foo\rbar"') }, Json.String("foo\rbar"))
    t.try_equal(fn { try parse('"foo\bbar"') }, Json.String("foo\u{0008}bar"))
    t.try_equal(fn { try parse('"foo\fbar"') }, Json.String("foo\u{000C}bar"))
    t.try_equal(fn { try parse('"foo\\"bar"') }, Json.String('foo"bar'))
    t.try_equal(fn { try parse('"foo\\/bar"') }, Json.String('foo/bar'))
    t.try_equal(fn { try parse('"foo\\\\bar"') }, Json.String("foo\\bar"))
    t.try_equal(fn { try parse('"foo\u005Cbar"') }, Json.String('foo\\bar'))
    t.try_equal(
      fn { try parse('"foo\\u001Fbar"') },
      Json.String("foo\u{001F}bar")
    )
    t.try_equal(fn { try parse('"\uD834\uDD1E"') }, Json.String("\u{1D11E}"))
    t.try_equal(
      fn { try parse('"\uE000\uE000"') },
      Json.String("\u{E000}\u{E000}")
    )

    t.throw fn { try parse("\"\0\"") }
    t.throw fn { try parse("\"\n\"") }
    t.throw fn { try parse("\"\t\"") }
    t.throw fn { try parse("\"\r\"") }
    t.throw fn { try parse("\"\u{8}\"") } # \b
    t.throw fn { try parse("\"\u{c}\"") } # \f

    t.throw fn { try parse('"\x42"') }
    t.throw fn { try parse('"\u1"') }
    t.throw fn { try parse('"\u12"') }
    t.throw fn { try parse('"\u123"') }
    t.throw fn { try parse('"\u{XXXX}"') }
    t.throw fn { try parse('"\uD834\uE000"') }
    t.throw fn { try parse('"\uD834\uZZZZ"') }
    t.throw fn { try parse('"\uDFFF\uDFFF"') }

    t.throw fn {
      let parser = Parser.new('"foo"')

      parser.max_string_size = 2
      try parser.parse
    }

    t.equal(
      parse_invalid('"a'),
      Option.Some(
        'One or more tokens are required, but we ran out of input, \
          on line 1 at byte offset 2'
      )
    )
  }

  t.test('Parsing objects') fn (t) {
    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new
    let map4 = Map.new
    let map5 = Map.new

    map2['a'] = Json.Int(10)
    map3['a'] = Json.Int(20)
    map4['a'] = Json.Int(10)
    map4['b'] = Json.Int(20)
    map5['a'] = Json.Int(10)
    map5['b'] = Json.Int(20)

    t.try_equal(fn { try parse('{}') }, Json.Object(map1))
    t.try_equal(fn { try parse('{ "a": 10 }') }, Json.Object(map2))
    t.try_equal(fn { try parse('{"a": 10, "a": 20}') }, Json.Object(map3))
    t.try_equal(fn { try parse('{"a": 10, "b": 20}') }, Json.Object(map4))
    t.try_equal(
      fn {
        try parse('{
          "a": 10,
          "b": 20
        }')
      },
      Json.Object(map5)
    )

    t.throw fn { try parse('{') }
    t.throw fn { try parse('}') }
    t.throw fn { try parse('{{}}') }
    t.throw fn { try parse('{"a"}') }
    t.throw fn { try parse('{"a":}') }
    t.throw fn { try parse('{"a":10,}') }
    t.throw fn { try parse('{},') }
    t.throw fn { try parse('{"a": true} "x"') }

    t.throw fn {
      let parser = Parser.new('{"a": {"b": {"c": 10}}}')

      parser.max_depth = 2
      try parser.parse
    }

    t.equal(
      parse_invalid('{"a"}'),
      Option.Some("The character '}' is unexpected, on line 1 at byte offset 4")
    )
  }

  t.test('Parsing Unicode BOMs') fn (t) {
    t.throw fn { try parse("\u{FEFF}10") }
    t.throw fn { try parse("\u{FFFE}10") }
    t.throw fn { try parse("\u{EF}\u{BB}\u{BF}10") }
  }

  t.test('json.parse') fn (t) {
    t.try_equal(fn { try json.parse('[10]') }, Json.Array([Json.Int(10)]))
  }
}
