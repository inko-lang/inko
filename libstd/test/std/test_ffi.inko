import std::drop::Drop
import std::ffi::(Function, LayoutBuilder, Library, Pointer, Struct, Type)
import std::test::Tests

fn libc_paths -> Array[String] {
  [
    # Linux, sometimes a GNU ld script
    'libc.so',

    # Linux, glibc 2.x
    'libc.so.6',

    # CI uses Ubuntu, which puts libc here
    '/lib/x86_64-linux-gnu/libc.so.6',

    # Mac OS
    'libSystem.dylib',

    # Windows
    'msvcrt.dll'
  ]
}

class Mem {
  let @ptr: Pointer
  let @free: Function

  fn static alloc(libc: ref Library, size: Int) -> Self {
    let calloc = libc
      .function(
        'calloc',
        arguments: [Type.SizeT, Type.SizeT],
        returns: Type.Pointer
      )
      .unwrap

    let free = libc
      .function('free', arguments: [Type.Pointer], returns: Type.Void)
      .unwrap

    let ptr = Pointer.new(calloc.call2(1, size))

    if ptr.null? { panic("calloc(1, {size}) failed") }

    Self { @ptr = ptr, @free = free }
  }
}

impl Drop for Mem {
  fn mut drop {
    @free.call1(@ptr.raw)
  }
}

fn pub tests(t: mut Tests) {
  t.test('Pointer.from_address') fn (t) {
    t.equal(Pointer.from_address(0x4).address, 0x4)
  }

  t.test('Pointer.null') fn (t) {
    t.equal(Pointer.null.address, 0x0)
  }

  t.test('Pointer.null?') fn (t) {
    t.true(Pointer.null.null?)
  }

  t.test('Pointer.read') fn (t) {
    let libc = Library.new(libc_paths).unwrap

    let mem = Mem.alloc(libc, size: Type.U8.size)

    t.equal(mem.ptr.read(type: Type.U8, offset: 0) as Int, 0)
  }

  t.test('Pointer.write') fn (t) {
    let libc = Library.new(libc_paths).unwrap
    let mem = Mem.alloc(libc, size: Type.U8.size)

    mem.ptr.write(type: Type.U8, offset: 0, value: 10)
    t.equal(mem.ptr.read(type: Type.U8, offset: 0) as Int, 10)
  }

  t.test('Pointer.clone') fn (t) {
    let ptr = Pointer.from_address(0x4)

    t.equal(ptr.clone, ptr)
  }

  t.test('Pointer.==') fn (t) {
    t.equal(Pointer.from_address(0x4), Pointer.from_address(0x4))
    t.not_equal(Pointer.from_address(0x4), Pointer.from_address(0x5))
  }

  t.test('Library.new') fn (t) {
    t.true(Library.new(['inko-test-this-wont-exist']).none?)
    t.true(Library.new(libc_paths).some?)
  }

  t.test('Library.variable') fn (t) {
    let libc = Library.new(libc_paths).unwrap

    t.true(libc.variable('malloc').some?)
    t.true(libc.variable('inko_test_this_wont_exist').none?)
  }

  t.test('Library.function') fn (t) {
    let libc = Library.new(libc_paths).unwrap

    t.true(
      libc
        .function('malloc', arguments: [Type.SizeT], returns: Type.Pointer)
        .some?
    )

    t.true(
      libc.function('inko_test_invalid', arguments: [], returns: Type.U8).none?
    )
  }

  t.test('Function.call0') fn (t) {
    let libc = Library.new(libc_paths).unwrap
    let func =
      libc.function('clock', arguments: [], returns: Type.I64).unwrap

    t.true((func.call0 as Int) >= 0)
  }

  t.test('Function.call1') fn (t) {
    let libc = Library.new(libc_paths).unwrap
    let func =
      libc.function('abs', arguments: [Type.I32], returns: Type.I32).unwrap

    t.equal(func.call1(-4) as Int, 4)
  }

  t.test('Function.call2') fn (t) {
    let libc = Library.new(libc_paths).unwrap
    let func = libc
      .function(
        'strcmp',
        arguments: [Type.String, Type.String],
        returns: Type.I32
      )
      .unwrap

    t.equal(func.call2('foo', 'foo') as Int, 0)
  }

  t.test('Function.call3') fn (t) {
    let libc = Library.new(libc_paths).unwrap
    let func = libc
      .function(
        'strtol',
        arguments: [Type.String, Type.Pointer, Type.I32],
        returns: Type.I32
      )
      .unwrap

    let value = func.call3('123', Pointer.null.raw, 10) as Int

    t.equal(value, 123)
  }

  t.test('Function.call4') fn (t) {
    let libc = Library.new(libc_paths).unwrap
  }

  t.test('Struct.pointer') fn (t) {
    let builder = LayoutBuilder.new

    builder.field('foo', Type.I32)

    let layout = builder.into_layout
    let pointer = Pointer.null
    let struct = Struct.new(pointer: pointer.clone, layout: layout)

    t.equal(struct.pointer, pointer)
  }

  t.test('Struct.index') fn (t) {
    let libc = Library.new(libc_paths).unwrap
    let builder = LayoutBuilder.new

    builder.field('foo', Type.I32)
    builder.field('bar', Type.I64)

    let layout = builder.into_layout
    let mem = Mem.alloc(libc, size: layout.size.clone)
    let struct = Struct.new(pointer: mem.ptr.clone, layout: layout)

    t.equal(struct['foo'] as Int, 0)
    t.equal(struct['bar'] as Int, 0)

    struct['foo'] = 4
    struct['bar'] = 8

    t.equal(struct['foo'] as Int, 4)
    t.equal(struct['bar'] as Int, 8)
  }

  t.test('LayoutBuilder.into_layout with padding') fn (t) {
    let builder = LayoutBuilder.new

    builder.field('foo', Type.I32)
    builder.field('bar', Type.I64)

    let layout = builder.into_layout
    let struct = Struct.new(pointer: Pointer.null, layout: layout)

    t.equal(struct.size, Type.I64.size * 2)
    t.equal(struct.alignment, Type.I64.alignment)
  }

  t.test('LayoutBuilder.into_layout without padding') fn (t) {
    let builder = LayoutBuilder.new

    builder.no_padding
    builder.field('foo', Type.I32)
    builder.field('bar', Type.I64)

    let layout = builder.into_layout
    let struct = Struct.new(pointer: Pointer.null, layout: layout)

    t.equal(struct.size, Type.I64.size + Type.I32.size)
    t.equal(struct.alignment, 1)
  }

  t.test('Type.size') fn (t) {
    t.equal(Type.I16.size, 2)
    t.equal(Type.String.size, 8)
    t.equal(Type.ByteArray.size, 8)
  }

  t.test('Type.alignment') fn (t) {
    t.equal(Type.I16.alignment, 2)
    t.equal(Type.String.alignment, 8)
    t.equal(Type.ByteArray.alignment, 8)
  }

  t.test('Type.to_int') fn (t) {
    t.equal(Type.Void.to_int, 0)
    t.equal(Type.Pointer.to_int, 1)
    t.equal(Type.F64.to_int, 2)
    t.equal(Type.F32.to_int, 3)
    t.equal(Type.I8.to_int, 4)
    t.equal(Type.I16.to_int, 5)
    t.equal(Type.I32.to_int, 6)
    t.equal(Type.I64.to_int, 7)
    t.equal(Type.U8.to_int, 8)
    t.equal(Type.U16.to_int, 9)
    t.equal(Type.U32.to_int, 10)
    t.equal(Type.U64.to_int, 11)
    t.equal(Type.String.to_int, 12)
    t.equal(Type.ByteArray.to_int, 13)
    t.equal(Type.SizeT.to_int, 14)
  }

  t.test('Type.clone') fn (t) {
    t.equal(Type.Void.clone, Type.Void)
    t.equal(Type.Pointer.clone, Type.Pointer)
    t.equal(Type.F64.clone, Type.F64)
    t.equal(Type.F32.clone, Type.F32)
    t.equal(Type.I8.clone, Type.I8)
    t.equal(Type.I16.clone, Type.I16)
    t.equal(Type.I32.clone, Type.I32)
    t.equal(Type.I64.clone, Type.I64)
    t.equal(Type.U8.clone, Type.U8)
    t.equal(Type.U16.clone, Type.U16)
    t.equal(Type.U32.clone, Type.U32)
    t.equal(Type.U64.clone, Type.U64)
    t.equal(Type.String.clone, Type.String)
    t.equal(Type.ByteArray.clone, Type.ByteArray)
    t.equal(Type.SizeT.clone, Type.SizeT)
  }
}
