use crate::result::error_to_int;
use libc::{sysconf, _SC_PAGESIZE};
use std::alloc::{alloc, handle_alloc_error, Layout};
use std::ffi::c_char;
use std::ffi::CStr;
use std::io;
use std::mem::{align_of, forget};
use std::ops::Deref;
use std::ptr::null;
use std::slice;
use std::str;
use std::string::String as RustString;

/// The alignment to use for Inko objects.
const ALIGNMENT: usize = align_of::<usize>();

pub(crate) fn page_size() -> usize {
    unsafe { sysconf(_SC_PAGESIZE) as usize }
}

pub(crate) fn allocate(layout: Layout) -> *mut u8 {
    unsafe {
        let ptr = alloc(layout);

        if ptr.is_null() {
            handle_alloc_error(layout);
        } else {
            ptr
        }
    }
}

pub(crate) unsafe fn header_of<'a, T>(ptr: *const T) -> &'a mut Header {
    &mut *(ptr as *mut Header)
}

/// The header used by heap allocated objects.
///
/// The layout is fixed to ensure we can safely assume certain fields are at
/// certain offsets in an object, even when not knowing what type of object
/// we're dealing with.
#[repr(C)]
pub struct Header {
    /// The type of the object.
    pub instance_of: TypePointer,

    /// The number of references to the object of this header.
    ///
    /// If this count overflows the program terminates. In practise this should
    /// never happen, as one needs _a lot_ of references to achieve this.
    ///
    /// We're using a u32 here instead of a u16, as the likelihood of
    /// overflowing a u32 is very tiny, but overflowing a u16 is something that
    /// _could_ happen (i.e. a process reference shared with many other
    /// processes).
    ///
    /// For regular objects, this field is initially set to 0, while for atomic
    /// values it defaults to 1. The latter is done as atomics always use a
    /// checked decrement, so starting with 1 ensures we don't underflow this
    /// value.
    pub references: u32,
}

impl Header {
    pub(crate) fn init_atomic(&mut self, instance_of: TypePointer) {
        self.instance_of = instance_of;
        self.references = 1;
    }
}

/// A function bound to an object.
///
/// Methods don't have headers as there's no need for any, as methods aren't
/// values one can pass around in Inko.
#[repr(C)]
pub struct Method {
    /// The hash of this method, used when performing dynamic dispatch.
    pub hash: u64,

    /// A pointer to the native function that backs this method.
    pub code: extern "system" fn(),
}

/// An Inko type.
///
/// If the layout/size of this type changes, be sure to also update
/// `Context::empty_type` in the compiler accordingly.
#[repr(C)]
pub struct Type {
    /// The name of the type.
    ///
    /// The memory for this name is allocated statically by the compiler as a
    /// NULL terminated string.
    ///
    /// The name is expected (and guaranteed by the compiler) to be valid UTF-8.
    pub(crate) name: *const c_char,

    /// The size (in bytes) of instances of this type.
    ///
    /// This is only used for allocating and deallocating processes, as the
    /// deallocation happens asynchronously _after_ a process finishes running.
    /// For regular types the allocation and free logic is generated by the
    /// compiler.
    pub(crate) instance_size: u32,

    /// The number of method slots this type has.
    ///
    /// The actual number of methods may be less than this value.
    pub(crate) method_slots: u16,

    /// The methods of this type, as pointers to native functions.
    ///
    /// Methods are accessed frequently, and we want to do so with as little
    /// indirection and as cache-friendly as possible. For this reason we use a
    /// flexible array member, instead of a Vec.
    ///
    /// The length of this array _must_ be a power of two.
    pub methods: [Method; 0],
}

impl Type {
    pub(crate) unsafe fn instance_layout(&self) -> Layout {
        Layout::from_size_align_unchecked(
            self.instance_size as usize,
            ALIGNMENT,
        )
    }

    pub(crate) unsafe fn name(&self) -> &str {
        CStr::from_ptr(self.name)
            .to_str()
            .expect("type names must be valid UTF-8")
    }
}

/// A pointer to a type.
#[repr(transparent)]
#[derive(Eq, PartialEq, Copy, Clone, Debug)]
pub struct TypePointer(pub(crate) *const Type);

impl Deref for TypePointer {
    type Target = Type;

    fn deref(&self) -> &Type {
        unsafe { &*self.0 }
    }
}

/// An FFI-safe primitive string.
///
/// These values are created either by the runtime or the standard library, and
/// ownership depends on the context.
///
/// If this struct's layout changes, the type `std.string.PrimitiveString` must
/// be updated accordingly.
#[repr(C)]
pub struct PrimitiveString {
    pub bytes: *const u8,
    pub size: i64,
}

impl PrimitiveString {
    pub(crate) fn empty() -> PrimitiveString {
        Self { bytes: null(), size: 0 }
    }

    pub(crate) fn invalid() -> PrimitiveString {
        Self { bytes: null(), size: -1 }
    }

    pub(crate) fn error(error: io::Error) -> PrimitiveString {
        Self { bytes: error_to_int(error) as *const u8, size: -1 }
    }

    pub(crate) fn owned(value: RustString) -> PrimitiveString {
        let vec = value.into_bytes();
        let ptr = vec.as_ptr();
        let len = vec.len() as i64;

        forget(vec);
        PrimitiveString { bytes: ptr, size: len }
    }

    pub(crate) fn borrowed(value: &str) -> PrimitiveString {
        Self { bytes: value.as_ptr(), size: value.len() as i64 }
    }

    pub(crate) fn as_str<'a>(&self) -> &'a str {
        // Safety: the data being valid UTF8 is enforced when self is created.
        unsafe {
            let slice = slice::from_raw_parts(self.bytes, self.size as usize);

            str::from_utf8_unchecked(slice)
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::mem::{align_of, offset_of, size_of};
    use std::ptr::addr_of;

    extern "system" fn dummy() {}

    #[test]
    fn test_header_field_offsets() {
        let header =
            Header { instance_of: TypePointer(0x7 as _), references: 42 };
        let base = addr_of!(header) as usize;

        assert_eq!(addr_of!(header.instance_of) as usize - base, 0);
        assert_eq!(addr_of!(header.references) as usize - base, 8);
    }

    #[test]
    fn test_type_field_offsets() {
        assert_eq!(offset_of!(Type, name), 0);
        assert_eq!(offset_of!(Type, instance_size), 8);
        assert_eq!(offset_of!(Type, method_slots), 12);
        assert_eq!(offset_of!(Type, methods), 16);
    }

    #[test]
    fn test_method_field_offsets() {
        let method = Method { hash: 42, code: dummy };
        let base = addr_of!(method) as usize;

        assert_eq!(addr_of!(method.hash) as usize - base, 0);
        assert_eq!(addr_of!(method.code) as usize - base, 8);
    }

    #[test]
    fn test_type_sizes() {
        assert_eq!(size_of::<Header>(), 16);
        assert_eq!(size_of::<Method>(), 16);
        assert_eq!(size_of::<Method>(), 16);
        assert_eq!(size_of::<Type>(), 16);
    }

    #[test]
    fn test_type_alignments() {
        assert_eq!(align_of::<Header>(), ALIGNMENT);
        assert_eq!(align_of::<Method>(), ALIGNMENT);
        assert_eq!(align_of::<Type>(), ALIGNMENT);
    }
}
