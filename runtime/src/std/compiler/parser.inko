# Parsing of Inko source code into an Abstract Syntax Tree.
#
# The types and methods of this module are not part of the public API at this
# time, meaning they can change at any time.
import std::byte_array::ToByteArray
import std::compiler::ast::blocks::*
import std::compiler::ast::body::Body
import std::compiler::ast::comments::*
import std::compiler::ast::control_flow::*
import std::compiler::ast::imports::*
import std::compiler::ast::literals::*
import std::compiler::ast::node::*
import std::compiler::ast::objects::*
import std::compiler::ast::operators::*
import std::compiler::ast::pattern_matching::*
import std::compiler::ast::send::*
import std::compiler::ast::types::*
import std::compiler::ast::variables::*
import std::compiler::lexer::Lexer
import std::compiler::source_location::SourceLocation
import std::compiler::token::Token
import std::conversion::ToString
import std::error::Error
import std::fs::path::ToPath
import std::loop::(loop, while)
import std::option::Option

# The name of the type to desugar ?T types into.
let OPTION_TYPE = 'Option'

# An error produced by the parser.
object ParseError {
  # The error message to display.
  @message: String

  # The source location of the error.
  @location: SourceLocation

  static def unexpected_token(token: Token) -> Self {
    let message = token.null?.if(
      true: { 'More input was expected, but we ran out of input' },
      false: {
        'The following unexpected input was encountered: ' + token.value
      }
    )

    new(message: message, location: token.location)
  }

  static def missing_argument_type(location: SourceLocation) -> Self {
    let message = 'An explicit type or default value is required for this argument'

    new(message: message, location: location)
  }

  static def new(message: String, location: SourceLocation) -> Self {
    Self { @message = message, @location = location }
  }

  def location -> SourceLocation {
    @location
  }
}

impl ToString for ParseError {
  def to_string -> String {
    @message
  }
}

impl Error for ParseError {
  def message -> String {
    @message
  }
}

# An LL(1) recursive descent parser for parsing Inko source code into an AST.
object Parser {
  # The lexer to use for lexing the input stream.
  @lexer: Lexer

  # A Token that has been peeked but not yet consumed.
  @peeked_token: ?Token

  # All comments that have been parsed so far.
  @comments: Array!(Comment)

  # A boolean that indicates if comments should be stored (True), or if they
  # should be ignored (False).
  @parse_comments: Boolean

  # Initialises the parser.
  #
  # The `input` argument can be a `ByteArray` or a `String`.
  #
  # The `file` argument should contain the path that produced the input data.
  # This can be a `String`, `Path`, or some other type that implements
  # `std::fs::path::ToPath`.
  #
  # # Parsing comments
  #
  # When `parse_comments` is set to `True`, comments will be stored in the
  # `Parser` instance. These can then be retrieved using `Parser.comments`:
  #
  #     let parser =
  #       Parser.new(input: '# hello', file: 'test.inko', parse_comments: True)
  #
  #     try! parser.parse
  #
  #     parser.comments.length # => 1
  static def new(
    input: ToByteArray,
    file: ToPath,
    parse_comments = False
  ) -> Self {
    Self {
      @lexer = Lexer.new(input: input, file: file),
      @peeked_token = Option.none,
      @comments = Array.new,
      @parse_comments = parse_comments
    }
  }

  # Returns all comments that have been parsed so far.
  def comments -> Array!(Comment) {
    @comments
  }

  # Parses the input source code and returns an AST.
  #
  # # Examples
  #
  # Parsing a simple expression:
  #
  #     import std::compiler::ast::literals::IntegerLiteral
  #     import std::compiler::parser::Parser
  #
  #     let parser = Parser.new(input: '10', file: 'test.inko')
  #     let ast = try! parser.parse
  #     let int = ast.children[0]! as IntegerLiteral
  #
  #     int.value # => '10'
  def parse !! ParseError -> Body {
    let location = @lexer.current_location
    let children = Array.new

    while({ peek_token.valid? }) {
      children.push(try top_level_expression(next_token))
    }

    Body.new(children: children, location: location)
  }

  def top_level_expression(token: Token) !! ParseError -> Node {
    match(token.type) {
      'import' -> { try import_module(token) }
      'object' -> { try object_definition(token) }
      'trait' -> { try trait_definition(token) }
      'impl' -> { try implement_or_reopen(token) }
      'def' -> { try method_definition(token) }
      'let' -> { try define_local_variable_or_constant(token) }
      else -> { try expression(token) }
    } as Node
  }

  def import_module(token: Token) !! ParseError -> Import {
    let path = try import_path
    let loc = token.location

    (peek_token.type == 'mul').if_true {
      next_token

      return Import.new(
        path: path,
        symbols: Array.new,
        import_all: True,
        location: loc
      )
    }

    Import.new(
      path: path,
      symbols: try import_symbols,
      import_all: False,
      location: loc
    )
  }

  def import_path !! ParseError -> Array!(Identifier) {
    let steps = Array.new

    loop {
      let token = next_token

      token.keyword?.or { token.type == 'identifier' }.if_false {
        throw ParseError.unexpected_token(token)
      }

      steps.push(identifier_from_token(token))

      (peek_token.type == 'colon_colon').if_false {
        return steps
      }

      next_token

      match(peek_token.type) {
        'constant', 'paren_open', 'mul' -> { return steps }
        else -> {}
      }
    }
  }

  def import_symbols !! ParseError -> Array!(ImportSymbol) {
    let peeked = peek_token

    (peeked.type == 'constant').if_true {
      let tok = next_token
      let sym = ImportSymbol.new(name: tok.value, location: tok.location)

      return Array.new(sym)
    }

    try collect_optional_greedy_list(
      start: 'paren_open',
      stop: 'paren_close'
    ) do (token) {
      let alias = match(token.type) {
        'identifier', 'constant' -> { try import_alias(token.type) }
        'self' -> { try import_alias('identifier') }
        else -> { throw ParseError.unexpected_token(token) }
      }

      ImportSymbol
        .new(name: token.value, location: token.location, alias: alias)
    }
  }

  def import_alias(expected: String) !! ParseError -> ?ImportAlias {
    (peek_token.type == 'as').if_false { return Option.none }

    # Skip the "as"
    next_token

    let token = next_token

    (token.type == expected).if_false {
      throw ParseError.unexpected_token(token)
    }

    Option.some(ImportAlias.new(name: token.value, location: token.location))
  }

  def object_definition(token: Token) !! ParseError -> DefineObject {
    let name = try token_of_type('constant')
    let params = try type_parameter_definitions
    let body = try object_body

    DefineObject.new(
      name: name.value,
      type_parameters: params,
      body: body,
      location: token.location
    )
  }

  def attribute_definition(token: Token) !! ParseError -> DefineAttribute {
    try token_of_type('colon')

    let type = try type(next_token)

    DefineAttribute
      .new(name: token.value, value_type: type, location: token.location)
  }

  def trait_definition(token: Token) !! ParseError -> DefineTrait {
    let name = try token_of_type('constant')
    let params = try type_parameter_definitions
    let required_traits = try required_traits
    let body = try trait_body

    DefineTrait.new(
      name: name.value,
      type_parameters: params,
      required_traits: required_traits,
      body: body,
      location: token.location
    )
  }

  def implement_or_reopen(token: Token) !! ParseError -> Node {
    let first_name = try token_of_type('constant')
    let peeked = peek_token.type

    (peeked == 'type_args_open').if_true {
      let trait_name = try constant(first_name)

      try token_of_type('for')

      return try implement_trait(token: token, trait_name: trait_name)
    }

    (peeked == 'for').if_true {
      # Skip the "for"
      next_token

      let trait_name = constant_from_token(first_name)

      return try implement_trait(token: token, trait_name: trait_name)
    }

    let object_name = constant_from_token(first_name)

    try reopen_object(token: token, object_name: object_name)
  }

  def implement_trait(
    token: Token,
    trait_name: Constant
  ) !! ParseError -> ImplementTrait {
    let object_name = constant_from_token(try token_of_type('constant'))
    let bounds = try type_parameter_bounds
    let body = try trait_implementation_body

    ImplementTrait.new(
      trait_name: trait_name,
      object_name: object_name,
      type_parameter_bounds: bounds,
      body: body,
      location: token.location
    )
  }

  def reopen_object(
    token: Token,
    object_name: Constant
  ) !! ParseError -> ReopenObject {
    let body = try reopen_object_body

    ReopenObject.new(name: object_name, body: body, location: token.location)
  }

  def method_definition(token: Token) !! ParseError -> Node {
    let static_method = try static_method?(token)
    let name =
      try message_name_from_token(token: next_token, consume_assign: True)

    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let yield_type = try optional_yield_type
    let bounds = try type_parameter_bounds

    DefineMethod.new(
      name: name,
      type_parameters: type_params,
      type_parameter_bounds: bounds,
      arguments: arguments,
      throw_type: throw_type,
      return_type: return_type,
      yield_type: yield_type,
      static_method: static_method,
      body: try body,
      location: token.location
    )
  }

  def trait_method_definition(token: Token) !! ParseError -> Node {
    let name =
      try message_name_from_token(token: next_token, consume_assign: True)

    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let yield_type = try optional_yield_type
    let bounds = try type_parameter_bounds

    (peek_token.type == 'curly_open').if_false {
      return DefineRequiredMethod.new(
        name: name,
        type_parameters: type_params,
        type_parameter_bounds: bounds,
        arguments: arguments,
        throw_type: throw_type,
        return_type: return_type,
        yield_type: yield_type,
        location: token.location
      )
    }

    DefineMethod.new(
      name: name,
      type_parameters: type_params,
      type_parameter_bounds: bounds,
      arguments: arguments,
      throw_type: throw_type,
      return_type: return_type,
      yield_type: yield_type,
      static_method: False,
      body: try body,
      location: token.location
    )
  }

  def static_method?(token: Token) !! ParseError -> Boolean {
    (token.type == 'static').if_false {
      return False
    }

    try token_of_type('def')

    True
  }

  def grouped_expression !! ParseError -> Node {
    let node = try expression(next_token)

    try token_of_type('paren_close')

    node
  }

  def basic_closure(token: Token) !! ParseError -> BasicClosure {
    BasicClosure.new(body: try block_body(token), location: token.location)
  }

  def closure(token: Token) !! ParseError -> Closure {
    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions(require_types: False)
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let body = try body

    Closure.new(
      type_parameters: type_params,
      arguments: arguments,
      body: body,
      throw_type: throw_type,
      return_type: return_type,
      location: token.location
    )
  }

  def lambda(token: Token) !! ParseError -> Lambda {
    let type_params = try type_parameter_definitions
    let arguments = try argument_definitions(require_types: False)
    let throw_type = try optional_throw_type
    let return_type = try optional_return_type
    let body = try body

    Lambda.new(
      type_parameters: type_params,
      arguments: arguments,
      body: body,
      throw_type: throw_type,
      return_type: return_type,
      location: token.location
    )

  }

  def block_body(start: Token) !! ParseError -> Body {
    try collect_block_body_nodes(start.location) do (token) {
      try expression(token)
    }
  }

  def restricted_object_body_node(token: Token) !! ParseError -> Node {
    match(token.type) {
      'def', 'static' -> { try method_definition(token) }
      'attribute' -> { try attribute_definition(token) }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def restricted_trait_body_node(token: Token) !! ParseError -> Node {
    match(token.type) {
      'def' -> { try trait_method_definition(token) }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def restricted_trait_implementation_body_node(token: Token) !! ParseError -> Node {
    match(token.type) {
      'def' -> { try method_definition(token) }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def restricted_reopen_object_body_node(token: Token) !! ParseError -> Node {
    match(token.type) {
      'def', 'static' -> { try method_definition(token) }
      else -> { throw ParseError.unexpected_token(token) }
    }
  }

  def optional_identifier_type !! ParseError -> ?TypeNode {
    (peek_token.type == 'colon').if_false { return Option.none }

    # Skip the ":"
    next_token
    Option.some(try type(next_token))
  }

  def default_value(rest: Boolean) !! ParseError -> ?Node {
    (peek_token.type == 'assign').if_false { return Option.none }

    # Skip the "="
    let assign = next_token

    rest.if_true {
      # Default values for rest arguments make no sense, as the default value
      # will already be set to an empty Array.
      throw ParseError.unexpected_token(assign)
    }

    Option.some(try expression(next_token))
  }

  def type_parameter_definitions !! ParseError -> Array!(DefineTypeParameter) {
    try collect_optional_greedy_list(
      start: 'type_args_open',
      stop: 'paren_close'
    ) do (token) {
      try type_parameter_definition(token)
    }
  }

  def type_parameter_definition(
    name: Token
  ) !! ParseError -> DefineTypeParameter {
    (name.type == 'constant').if_false {
      throw ParseError.unexpected_token(name)
    }

    let traits = try required_traits

    DefineTypeParameter
      .new(name: name.value, required_traits: traits, location: name.location)
  }

  def argument_definitions(
    require_types = True
  ) !! ParseError -> Array!(DefineArgument) {
    try collect_optional_greedy_list(
      start: 'paren_open',
      stop: 'paren_close'
    ) do (current) {
      let mut token = current
      let mut rest = False

      (token.type == 'mul').if_true {
        token = next_token
        rest = True
      }

      try require_token_type(token: token, expected: 'identifier')

      let type = try optional_identifier_type
      let default = try default_value(rest: rest)

      match {
        rest -> {
          type.if_false {
            throw ParseError.missing_argument_type(token.location)
          }

          DefineRestArgument.new(
            name: token.value,
            value_type: type.get,
            location: token.location
          )
        }
        default.some? -> {
          DefineOptionalArgument.new(
            name: token.value,
            value_type: type,
            default_value: default.get,
            location: token.location
          )
        }
        type.some? -> {
          DefineRequiredArgument.new(
            name: token.value,
            value_type: type.get,
            location: token.location
          )
        }
        require_types -> {
          throw ParseError.missing_argument_type(token.location)
        }
        else -> {
          DefineUntypedArgument.new(
            name: token.value,
            location: token.location
          )
        }
      } as DefineArgument
    }
  }

  def required_traits !! ParseError -> Array!(Constant) {
    let traits = Array.new

    (peek_token.type == 'colon').if_false {
      return traits
    }

    # Skip the ":"
    next_token

    loop {
      let constant = try next_as_constant

      traits.push(constant)

      (peek_token.type == 'add').if_false {
        return traits
      }

      next_token
    }
  }

  def type_parameter_bounds !! ParseError -> Array!(DefineTypeParameter) {
    (peek_token.type == 'when').if_false {
      return Array.new
    }

    # Skip the "when"
    next_token

    try collect_list(stop: 'curly_open') do (token) {
      try type_parameter_definition(token)
    }
  }

  def expression(token: Token) !! ParseError -> Node {
    try binary(token)
  }

  def binary(token: Token) !! ParseError -> Node {
    let mut node = try type_cast(token)

    while({ peek_token.binary? }) {
      let operator = next_token
      let operand = try type_cast(next_token)

      node = Send.new(
        message: operator.value,
        receiver: node,
        arguments: Array.new(operand),
        type_arguments: Array.new,
        location: operator.location
      )
    }

    node
  }

  def type_cast(token: Token) !! ParseError -> Node {
    let mut node = try postfix(token: token)

    while({ peek_token.type == 'as' }) {
      let as_token = next_token
      let cast_to = try type(next_token)

      node = TypeCast
        .new(expression: node, cast_to: cast_to, location: as_token.location)
    }

    node
  }

  def postfix(token: Token) !! ParseError -> Node {
    let mut node = try value(token)

    loop {
      let step = try postfix_step(node)

      step.same_object?(node).if(true: { return node }, false: { node = step })
    }
  }

  def postfix_step(node: Node) !! ParseError -> Node {
    let peeked = peek_token

    match(peeked.type) {
      'dot' -> {
        next_token
        try send_with_receiver(node)
      }
      'bracket_open' -> { try bracket_send(start: next_token, receiver: node) }
      else -> { node }
    } as Node
  }

  def bracket_send(start: Token, receiver: Node) !! ParseError -> Node {
    let arguments = Array.new(try expression(next_token))

    try token_of_type('bracket_close')

    let message = (peek_token.type == 'assign').if(
      true: {
        # Skip the "="
        next_token

        arguments.push(try expression(next_token))

        '[]='
      },
      false: { '[]' }
    )

    Send.new(
      message: message,
      receiver: receiver,
      arguments: arguments,
      type_arguments: Array.new,
      location: start.location
    )
  }

  def return_value(
    token: Token,
    local_return = False,
    location = token.location
  ) !! ParseError -> Node {
    let peeked = peek_token
    let expr = match(peeked.type) {
      'identifier',
      'attribute',
      'constant',
      'curly_open',
      'do',
      'lambda',
      'integer',
      'float',
      'string',
      'self',
      'match',
      'paren_open',
      'let',
      'return',
      'throw',
      'try',
      'local',
      'colon_colon'
      when peeked.same_line?(token) -> {
        Option.some(try expression(next_token))
      }
      else -> { Option.none }
    }

    Return.new(expression: expr, local_return: local_return, location: location)
  }

  def throw_value(
    token: Token,
    local_throw = False,
    location = token.location
  ) !! ParseError -> Node {
    let expr = try expression(next_token)

    Throw.new(expression: expr, local_throw: local_throw, location: location)
  }

  def yield_value(token: Token) !! ParseError -> Node {
    let expr = try expression(next_token)

    Yield.new(expression: expr, location: token.location)
  }

  def local_expression(token: Token) !! ParseError -> Node {
    let next = next_token
    let loc = token.location

    match(next.type) {
      'return' -> {
        try return_value(token: next, local_return: True, location: loc)
      }
      'throw' -> {
        try throw_value(token: next, local_throw: True, location: loc)
      }
      'try' -> {
        try try_expression(token: next, local_throw: True, location: loc)
      }
      else -> { throw ParseError.unexpected_token(next_token) }
    }
  }

  def try_expression(
    token: Token,
    local_throw = False,
    location = token.location
  ) !! ParseError -> Node {
    (peek_token.type == 'exclamation').if_true {
      return try try_panic(token)
    }

    let expr = try try_expression_value

    match(let matched = expr) {
      as TryExpressionNode -> { matched.inside_try }
      else -> {}
    }

    (peek_token.type == 'else').if(
      true: {
        try try_with_else(
          token: token,
          expression: expr,
          local_throw: local_throw,
          location: location
        )
      },
      false: {
        try_without_else(
          token: token,
          expression: expr,
          local_throw: local_throw,
          location: location
        )
      }
    )
  }

  def try_panic(token: Token) !! ParseError -> TryPanic {
    # Skip the "!"
    next_token

    let expr = try try_expression_value

    TryPanic.new(expression: expr, location: token.location)
  }

  def try_with_else(
    token: Token,
    expression: Node,
    local_throw = False,
    location = token.location
  ) !! ParseError -> Try {
    # Skip the "else" keyword
    next_token

    let else_var = (peek_token.type == 'paren_open').if(
      true: {
        # Skip the "("
        next_token

        let var = try token_of_type('identifier')

        try token_of_type('paren_close')
        Option.some(var.value)
      },
      false: { Option.none }
    )

    let else_body = (peek_token.type == 'curly_open').if(
      true: { try body },
      false: {
        let body = try expression(next_token)

        Body.new(children: Array.new(body), location: body.location)
      }
    )

    Try.new(
      expression: expression,
      error_variable: else_var,
      else_body: else_body,
      local_throw: local_throw,
      location: location
    )
  }

  def try_without_else(
    token: Token,
    expression: Node,
    local_throw = False,
    location = token.location
  ) -> Try {
    let else_expr =
      Body.new(children: Array.new, location: token.location)

    Try.new(
      expression: expression,
      error_variable: Option.none,
      else_body: else_expr,
      local_throw: local_throw,
      location: location
    )
  }

  def try_expression_value !! ParseError -> Node {
    let expr = try expression(next_token)

    match(let matched = expr) {
      as TryExpressionNode -> { matched.inside_try }
      else -> {}
    }

    expr
  }

  def self_object(token: Token) -> SelfObject {
    SelfObject.new(location: token.location)
  }

  def identifier(token: Token) !! ParseError -> Node {
    let peeked = peek_token
    let peeked_type = peeked.type

    (peeked_type == 'type_args_open')
      .or { peeked_type == 'paren_open' }
      .or { next_token_is_argument?(token) }
      .if_true {
        return try identifier_send(token)
      }

    let ident = identifier_from_token(token)

    (peeked_type == 'assign').if_true {
      return try assign_local(ident)
    }

    peeked.binary_assign?.if_true {
      return AssignLocal.new(name: ident, value: try binary_assign(ident))
    }

    ident
  }

  def identifier_send(token: Token) !! ParseError -> Send {
    let type_args = try type_arguments
    let args = try message_arguments(name: token, setter: False)
    let rec = self_object(token)

    Send.new(
      message: token.value,
      receiver: rec,
      arguments: args,
      type_arguments: type_args,
      location: token.location
    )
  }

  def assign_local(identifier: Identifier) !! ParseError -> AssignLocal {
    # Skip the "="
    next_token

    AssignLocal.new(name: identifier, value: try expression(next_token))
  }

  def binary_assign(variable: Node) !! ParseError -> Send {
    let operator = next_token
    let message =
      operator.value.slice(start: 0, length: operator.value.length - 1)

    let operand = try expression(next_token)

    Send.new(
      message: message,
      receiver: variable,
      arguments: Array.new(operand),
      type_arguments: Array.new,
      location: operator.location
    )
  }

  def value(token: Token) !! ParseError -> Node {
    # When adding a new token to the "match" below, make sure to also update the
    # "match" in the return_value() method.
    match(token.type) {
      'identifier' -> { try identifier(token) }
      'attribute' -> { try attribute(token) }
      'constant' -> { try constant_or_constructor(token) }
      'curly_open' -> { try basic_closure(token) }
      'do' -> { try closure(token) }
      'lambda' -> { try self.lambda(token) }
      'integer' -> { integer(token) }
      'float' -> { float(token) }
      'string' -> { string(token) }
      'self' -> { self_object(token) }
      'match' -> { try pattern_match(token) }
      'paren_open' -> { try grouped_expression }
      'let' -> {
        try define_local_variable(token: token, mutable: next_token_is_mutable?)
      }
      'return' -> { try return_value(token) }
      'throw' -> { try throw_value(token) }
      'try' -> { try try_expression(token) }
      'yield' -> { try yield_value(token) }
      'local' -> { try local_expression(token) }
      'colon_colon' -> { try global(token) }
      else -> { throw ParseError.unexpected_token(token) }
    } as Node
  }

  def integer(token: Token) -> IntegerLiteral {
    IntegerLiteral.new(value: token.value, location: token.location)
  }

  def float(token: Token) -> FloatLiteral {
    FloatLiteral.new(value: token.value, location: token.location)
  }

  def string(token: Token) -> StringLiteral {
    StringLiteral.new(value: token.value, location: token.location)
  }

  def constant(token: Token) !! ParseError -> Constant {
    let node = constant_from_token(token)

    (peek_token.type == 'type_args_open').if_true {
      # Skip the "!("
      next_token

      try greedy_list(stop: 'paren_close') {
        node.type_arguments.push(try type(next_token))
      }
    }

    node
  }

  def constant_or_constructor(token: Token) !! ParseError -> Node {
    let peeked = peek_token

    (peeked.type == 'curly_open')
      .and { peeked.same_line?(token) }
      .if_true { return try constructor(token) }

    try constant(token)
  }

  def constructor(token: Token) !! ParseError -> Constructor {
    try token_of_type('curly_open')

    let attrs = try collect_list(stop: 'curly_close') do (attr) {
      require_token_type(token: attr, expected: 'attribute')

      try token_of_type('assign')

      let value = try expression(next_token)

      ConstructorAttribute
        .new(name: attr.value, value: value, location: attr.location)
    }

    try token_of_type('curly_close')

    Constructor
      .new(name: token.value, attributes: attrs, location: token.location)
  }

  def global(token: Token) !! ParseError -> Global {
    let name_token = next_token

    (name_token.type == 'identifier')
      .or { name_token.type == 'constant' }
      .if_false {
        throw ParseError.unexpected_token(name_token)
      }

    Global.new(name: name_token.value, location: token.location)
  }

  def define_local_variable_or_constant(token: Token) !! ParseError -> Node {
    let mutable = next_token_is_mutable?

    mutable.if_true {
      return try define_local_variable(token: token, mutable: True)
    }

    (peek_token.type == 'constant').if_true {
      return try define_constant(token)
    }

    try define_local_variable(token: token, mutable: False)
  }

  def define_local_variable(
    token: Token, mutable: Boolean
  ) !! ParseError -> DefineLocalVariable {
    let name = identifier_from_token(try token_of_type('identifier'))
    let type = try optional_identifier_type

    try token_of_type('assign')

    let value = try expression(next_token)

    DefineLocalVariable.new(
      name: name,
      value_type: type,
      value: value,
      mutable: mutable,
      location: token.location
    )
  }

  def define_constant(token: Token) !! ParseError -> DefineConstant {
    let name = constant_from_token(try token_of_type('constant'))
    let type = try optional_identifier_type

    try token_of_type('assign')

    let value = try expression(next_token)

    DefineConstant.new(
      name: name,
      value_type: type,
      value: value,
      location: token.location
    )
  }

  def send_with_receiver(receiver: Node) !! ParseError -> Node {
    let name_token = next_token
    let name =
      try message_name_from_token(token: name_token, consume_assign: False)

    # If the message is a setter message (e.g. `bar=` in `foo.bar = 10`), we
    # need to limit its argument to a single expression. The `=` is already part
    # of the message name retrieved above, so we can consume the token if
    # present; without having to append it to the message name.
    let setter = (peek_token.type == 'assign').if(
      true: {
        next_token
        True
      },
      false: { False }
    )

    let type_arguments = try type_arguments
    let arguments = try message_arguments(name: name_token, setter: setter)

    Send.new(
      message: name,
      receiver: receiver,
      arguments: arguments,
      type_arguments: type_arguments,
      location: name_token.location
    )
  }

  def message_name_from_token(
    token: Token,
    consume_assign: Boolean
  ) !! ParseError -> String {
    token.valid?.if_false {
      throw ParseError.new(
        message: 'More input was expected, but we ran out of input',
        location: token.location
      )
    }

    (token.type == 'identifier')
      .or { token.type == 'constant' }
      .or { token.binary? }
      .or { token.keyword? }
      .or {
        (token.type == 'bracket_open')
          .and { peek_token.type == 'bracket_close' }
      }
      .if_false {
        throw ParseError.unexpected_token(token)
      }

    let mut name = token.value

    (token.type == 'bracket_open').if_true {
      name += next_token.value
    }

    (peek_token.type == 'assign').if_true {
      consume_assign.if_true {
        next_token
      }

      name += '='
    }

    name
  }

  def message_arguments(
    name: Token,
    setter: Boolean
  ) !! ParseError -> Array!(Node) {
    # Setter messages have their arguments limited to a single expression.
    # Example: `foo.bar = 10`.
    setter.if_true {
      return Array.new(try expression(next_token))
    }

    let peeked = peek_token

    (peeked.type == 'paren_open')
      .and { peeked.same_line?(name) }
      .if_true {
        return try message_arguments_with_parentheses
      }

    next_token_is_argument?(name).if_true {
      return try message_arguments_without_parentheses
    }

    Array.new
  }

  def message_arguments_with_parentheses !! ParseError -> Array!(Node) {
    let mut allow_positional = True

    # Skip the opening "("
    next_token

    let arguments = try collect_list(stop: 'paren_close') do (token) {
      match {
        token.type == 'identifier' when peek_token.type == 'colon' -> {
          allow_positional = False

          try keyword_argument(token)
        }
        allow_positional -> { try expression(token) }
        else -> {
          throw ParseError.new(
            message: 'Positional arguments must come before any keyword arguments',
            location: token.location
          )
        }
      }
    }

    let closing_paren = try token_of_type('paren_close')

    next_token_is_argument?(closing_paren).if_true {
      arguments.push(try expression(next_token))
    }

    arguments
  }

  def message_arguments_without_parentheses !! ParseError -> Array!(Node) {
    let arguments = Array.new

    loop {
      let token = next_token

      arguments.push(try value(token))

      (peek_token.type == 'comma').if(
        true: { next_token },
        false: { return arguments }
      )
    }
  }

  def keyword_argument(token: Token) !! ParseError -> Node {
    # Skip the colon
    next_token

    let name = identifier_from_token(token)
    let value = try expression(next_token)

    KeywordArgument.new(name: name, value: value, location: name.location)
  }

  def type_arguments !! ParseError -> Array!(TypeNode) {
    try collect_optional_greedy_list(
      start: 'type_args_open',
      stop: 'paren_close'
    ) do (token) {
      try type(token)
    }
  }

  def type(token: Token) !! ParseError -> TypeNode {
    match(token.type) {
      'constant' -> { try constant(token) }
      'question' -> { try option_type(token) }
      'do' -> { try closure_type(token) }
      'lambda' -> { try lambda_type(token) }
      else -> { throw ParseError.unexpected_token(token) }
    } as TypeNode
  }

  def option_type(token: Token) !! ParseError -> Constant {
    let node = Constant.new(name: OPTION_TYPE, location: token.location)

    node.type_arguments.push(try type(next_token))
    node
  }

  def closure_type(token: Token) !! ParseError -> ClosureType {
    ClosureType.new(
      type_parameters: try type_parameter_definitions,
      arguments: try block_argument_types,
      throw_type: try optional_throw_type,
      return_type: try optional_return_type,
      location: token.location
    )
  }

  def lambda_type(token: Token) !! ParseError -> LambdaType {
    LambdaType.new(
      type_parameters: try type_parameter_definitions,
      arguments: try block_argument_types,
      throw_type: try optional_throw_type,
      return_type: try optional_return_type,
      location: token.location
    )
  }

  def block_argument_types !! ParseError -> Array!(TypeNode) {
    try collect_optional_greedy_list(
      start: 'paren_open',
      stop: 'paren_close'
    ) do (token) {
      try type(token)
    }
  }

  def optional_yield_type !! ParseError -> ?TypeNode {
    (peek_token.type == 'double_arrow').if_false { return Option.none }

    # Skip the "=>"
    next_token

    Option.some(try type(next_token))
  }

  def optional_throw_type !! ParseError -> ?TypeNode {
    (peek_token.type == 'throws').if_false { return Option.none }

    # Skip the "!!"
    next_token

    Option.some(try type(next_token))
  }

  def optional_return_type !! ParseError -> ?TypeNode {
    (peek_token.type == 'arrow').if_false { return Option.none }

    # Skip the "->"
    next_token

    Option.some(try type(next_token))
  }

  def attribute(token: Token) !! ParseError -> Node {
    let attr = Attribute.new(name: token.value, location: token.location)
    let peeked = peek_token

    (peeked.type == 'assign').if_true {
      return try assign_attribute(attr)
    }

    peeked.binary_assign?.if_true {
      return AssignAttribute.new(name: attr, value: try binary_assign(attr))
    }

    attr
  }

  def assign_attribute(attribute: Attribute) !! ParseError -> AssignAttribute {
    # Skip the "="
    next_token

    AssignAttribute.new(name: attribute, value: try expression(next_token))
  }

  def identifier_from_token(token: Token) -> Identifier {
    Identifier.new(name: token.value, location: token.location)
  }

  def next_token_is_argument?(start_token: Token) -> Boolean {
    let peeked = peek_token

    peeked.valid?
      .and { peeked.same_line?(start_token) }
      .and {
        (peeked.type == 'curly_open')
          .or { peeked.type == 'do' }
          .or { peeked.type == 'lambda' }
      }
  }

  def next_token_is_mutable? -> Boolean {
    (peek_token.type == 'mut').if_false {
      return False
    }

    # Skip the "mut"
    next_token

    True
  }

  def require_token_type(token: Token, expected: String) !! ParseError {
    (token.type == expected).if_true {
      return
    }

    throw ParseError.unexpected_token(token)
  }

  def token_of_type(type: String) !! ParseError -> Token {
    let token = next_token

    try require_token_type(token: token, expected: type)

    token
  }

  def next_as_constant !! ParseError -> Constant {
    try constant(try token_of_type('constant'))
  }

  def constant_from_token(token: Token) -> Constant {
    Constant.new(name: token.value, location: token.location)
  }

  def body !! ParseError -> Body {
    try block_body(try token_of_type('curly_open'))
  }

  def object_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_object_body_node(token)
    }
  }

  def trait_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_trait_body_node(token)
    }
  }

  def reopen_object_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_reopen_object_body_node(token)
    }
  }

  def trait_implementation_body !! ParseError -> Body {
    let start = try token_of_type('curly_open')

    try collect_block_body_nodes(start.location) do (token) {
      try restricted_trait_implementation_body_node(token)
    }
  }

  def pattern_match(start: Token) !! ParseError -> Match {
    let cases: Array!(MatchCase) = Array.new
    let mut else_branch: ?MatchElse = Option.none
    let mut binding: ?Identifier = Option.none
    let mut match_expr: ?Node = Option.none

    # For the sake of keeping this code's complexity under control we require
    # that when a "(" is given, an expression (and optional binding) is also
    # given. In other words, this is valid:
    #
    #     match { ...  }
    #
    # But this is not:
    #
    #     match() { ... }
    (peek_token.type == 'paren_open').if_true {
      try token_of_type('paren_open')

      (peek_token.type == 'let').if_true {
        next_token

        binding =
          Option.some(identifier_from_token(try token_of_type('identifier')))

        try token_of_type('assign')
      }

      match_expr = Option.some(try expression(next_token))

      try token_of_type('paren_close')
    }

    try token_of_type('curly_open')

    while({ peek_token.valid?.and { peek_token.type != 'curly_close' } }) {
      let token = next_token

      match(token.type) {
        'as' -> {
          let pattern = constant_from_token(try token_of_type('constant'))
          let type_guard = try optional_pattern_match_guard

          try token_of_type('arrow')

          cases.push(MatchType.new(
            pattern: pattern,
            guard: type_guard,
            body: try body,
            location: token.location
          ))
        }
        'else' -> {
          else_branch.if_true { throw ParseError.unexpected_token(token) }

          try token_of_type('arrow')

          else_branch = Option.some(
            MatchElse.new(
              body: try block_body(try token_of_type('curly_open')),
              location: token.location
            )
          )
        }
        else -> {
          let patterns = Array.new(try expression(token))

          while({ peek_token.type == 'comma' }) {
            next_token
            patterns.push(try expression(next_token))
          }

          let expr_guard = try optional_pattern_match_guard

          try token_of_type('arrow')

          cases.push(MatchExpressions.new(
            patterns: patterns,
            guard: expr_guard,
            body: try body,
            location: token.location
          ))
        }
      }
    }

    try token_of_type('curly_close')

    Match.new(
      expression: match_expr,
      binding: binding,
      cases: cases,
      else_branch: else_branch,
      location: start.location
    )
  }

  def optional_pattern_match_guard !! ParseError -> ?Node {
    (peek_token.type == 'when').if_false { return Option.none }

    # Skip the "when" keyword.
    next_token
    Option.some(try expression(next_token))
  }

  def next_token -> Token {
    @peeked_token.let do (token) {
      @peeked_token = Option.none
      return token
    }

    next_token_from_lexer
  }

  def peek_token -> Token {
    @peeked_token
      .else { @peeked_token = Option.some(next_token_from_lexer) }
      .get
  }

  def next_token_from_lexer -> Token {
    let token = @lexer.next

    (token.type == 'comment').if_false {
      return token
    }

    @parse_comments.if_true {
      @comments.push(Comment.new(text: token.value, location: token.location))
    }

    next_token_from_lexer
  }

  def collect_block_body_nodes(
    location: SourceLocation,
    block: do (Token) !! ParseError -> Node
  ) !! ParseError -> Body {
    let nodes = Array.new

    loop {
      let token = next_token

      (token.type == 'curly_close').if_true {
        return Body.new(children: nodes, location: location)
      }

      nodes.push(try block.call(token))
    }
  }

  def collect_optional_greedy_list!(T)(
    start: String,
    stop: String,
    block: do (Token) !! ParseError -> T
  ) !! ParseError -> Array!(T) {
    (peek_token.type == start).if_false {
      return Array.new
    }

    try collect_greedy_list(stop: stop, block: block)
  }

  def collect_greedy_list!(T)(
    stop: String,
    block: do (Token) !! ParseError -> T
  ) !! ParseError -> Array!(T) {
    # Skip the opening token.
    next_token

    let values = try collect_list(stop: stop, block: block)

    try token_of_type(stop)

    values
  }

  def collect_list!(T)(
    stop: String,
    block: do (Token) !! ParseError -> T
  ) !! ParseError -> Array!(T) {
    let values = Array.new

    try list(stop) {
      values.push(block.call(next_token))
    }

    values
  }

  def greedy_list(stop: String, block: do !! ParseError) !! ParseError {
    try list(stop: stop, block: block)
    try token_of_type(stop)
  }

  def list(stop: String, block: do !! ParseError) !! ParseError {
    while({ peek_token.type != stop }) {
      try block.call
      try list_separator_or_terminal(stop)
    }
  }

  def list_separator_or_terminal(type: String) !! ParseError {
    let peeked = peek_token

    match(peeked.type) {
      'comma' -> {
        next_token
        return
      }
      type -> { return }
      else -> { throw ParseError.unexpected_token(peeked) }
    }
  }
}
