# Extensions for the `Array` type that can only be defined later on in the
# bootstrapping process.
#
# These types and methods are defined separately as otherwise `std::iterator`
# would depend on `std::array` while `std::array` would depend on
# `std::iterator`.
import std::format::(self, Formatter, Inspect)
import std::iterator::(self, Iterator)

impl Array!(T) {
  # Returns an `Iterator` that iterates over all values in `self`.
  #
  # # Examples
  #
  # Iterating over an `Array`:
  #
  #     let numbers = Array.new(10, 20, 30)
  #     let iter = numbers.iter
  #
  #     iter.next # => 10
  #     iter.next # => 20
  #     iter.next # => 30
  #     iter.next # => Nil
  def iter -> Iterator!(T) {
    iterator.index_enumerator(length) do (index) {
      self[index]
    }
  }
}

impl Inspect for Array!(T) {
  # Returns a human-readable representation of this `Array`.
  #
  # # Examples
  #
  # Converting an empty `Array`:
  #
  #     Array.new.inspect # => 'Array'
  #
  # Converting an `Array` with one value:
  #
  #     Array.new(10).inspect # => 'Array { 10 }'
  #
  # Converting an `Array` containing multiple values:
  #
  #     Array.new(10, 20, 30).inspect # => 'Array { 10, 20, 30 }'
  def inspect -> String where T: Inspect {
    ::format.inspect(self)
  }

  # Formats this `Array` into a human-readable representation.
  def format_for_inspect(formatter: Formatter) where T: Inspect {
    let last = length - 1

    formatter.push('Array')

    empty?.if_true {
      return
    }

    formatter.push(' { ')

    each_with_index do (value, index) {
      formatter.descend {
        value.format_for_inspect(formatter)
      }

      (index < last).if_true {
        formatter.push(', ')
      }
    }

    formatter.push(' }')
  }
}
