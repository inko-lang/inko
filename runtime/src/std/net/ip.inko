import std::byte_array::(ByteArray, ToByteArray)
import std::conversion::ToString
import std::error::Error
import std::operators::Equal
import std::string_buffer::StringBuffer

## The byte for a single dot (".").
let _DOT_BYTE = 46

## The byte for a single colon (":").
let _COLON_BYTE = 58

## The number of octets in an IPv4 address.
let _IPV4_OCTETS = 4

## The number of hextets in an IPv6 address.
let _IPV6_HEXTETS = 8

## The minimum value of an IPv4 octet or IPv6 hextet.
let _IP_MINIMUM_VALUE = 0

## The maximum value of an IPv4 octet.
let _IPV4_OCTET_MAXIMUM = 0xff

## The maximum value of an IPv6 hextet.
let _IPV6_HEXTET_MAXIMUM = 0xffff

## The maximum number of characters that can appear in an IPv6 address stored as
## a `String`.
let _IPV6_STRING_MAXIMUM_LENGTH = 45

## The number of bits to shift for the first and third octets in an IPv4 address
## when converting them to IPv6 addresses.
let _IPV4_TO_IPV6_SHIFT = 8

## Converts a pair of IPv4 octets into a single IPv6 hextet.
def _octets_to_hextet(first: Integer, second: Integer) -> Integer {
  first << _IPV4_TO_IPV6_SHIFT | second
}

## An error thrown when attempting to parse an invalid IPv4 or IPv6 address.
object AddressParseError {
  ## The address that could not be parsed.
  @address: String

  def init(address: ToString) {
    @address = address.to_string
  }
}

impl ToString for AddressParseError {
  def to_string -> String {
    message
  }
}

impl Error for AddressParseError {
  def message -> String {
    @address.inspect + ' is not a valid IP address'
  }
}

## An IPv4 or IPv6 address.
trait IpAddress {}

## A type that can be converted to an `IpAddress`.
trait ToIpAddress {
  ## Converts `self` to an IPv4 or IPv6 address.
  def to_ip_address !! AddressParseError -> IpAddress
}

trait IpAddress: Equal + ToString + ToIpAddress {
  ## Parses an IP address.
  static def parse(input: ToByteArray) !! AddressParseError -> Self

  ## Returns `True` if `self` is an IPv4 address.
  def v4? -> Boolean

  ## Returns `True` if `self` is an IPv6 address.
  def v6? -> Boolean

  ## Returns `True` if `self` is in the range designated for documentation.
  def documentation? -> Boolean

  ## Returns `True` if `self` is a loopback address.
  def loopback? -> Boolean

  ## Returns `True` if `self` is a multicast address.
  def multicast? -> Boolean

  ## Returns `True` if `self` is the special "unspecified" address.
  def unspecified? -> Boolean

  ## Returns the segments of the IP address.
  def segments -> Array!(Integer)
}

object Ipv6Address {
  ## The segments/hextets of this IPv6 address.
  @segments: Array!(Integer)

  def init(
    a = 0,
    b = 0,
    c = 0,
    d = 0,
    e = 0,
    f = 0,
    g = 0,
    h = 0
  ) {
    @segments = Array.new(a, b, c, d, e, f, g, h)
  }
}

impl Equal for Ipv6Address {
  ## Returns `True` if `self` and the given IP address are the same.
  ##
  ## # Examples
  ##
  ## Comparing two IPv6 addresses:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     let addr1 = Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1)
  ##     let addr2 = Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1)
  ##     let addr3 = Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 2)
  ##
  ##     addr1 == addr2 # => True
  ##     addr1 == addr3 # => False
  def ==(other: Self) -> Boolean {
    @segments == other.segments
  }
}

impl ToString for Ipv6Address {
  ## Converts `self` to a `String`.
  ##
  ## Zero compression is applied to the longest sequence of empty hextets, if
  ## there are any.
  ##
  ## # Examples
  ##
  ## Converting an IPv6 address to a `String`:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     Ipv6Address.new.to_string # => '::'
  ##     Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1) # => '::1'
  def to_string -> String {
    unspecified?.if_true {
      return '::'
    }

    loopback?.if_true {
      return '::1'
    }

    let ipv4_compatible = ipv4_compatible?
    let ipv4_mapped = ipv4_mapped?

    ipv4_compatible.or { ipv4_mapped }.if_true {
      # This value (256) is used to convert a hextet to the second and fourth
      # octet in an IPv4 address. For example, for a hextet 0x2ff this produces
      # an octet of 255.
      let hextet_to_octet_modulo = _IPV4_OCTET_MAXIMUM + 1

      let ipv4_address = StringBuffer
        .new(
          @segments[6] >> _IPV4_TO_IPV6_SHIFT
            .to_string,
          '.',
          @segments[6] % hextet_to_octet_modulo
            .to_string,
          '.',
          @segments[7] >> _IPV4_TO_IPV6_SHIFT
            .to_string,
          '.',
          @segments[7] % hextet_to_octet_modulo
            .to_string
        )
        .to_string

      ipv4_compatible.if true: {
        return '::' + ipv4_address
      }, false: {
        return '::ffff:' + ipv4_address
      }
    }

    let mut compression_start = 0
    let mut compression_len = 0
    let mut current_at = 0
    let mut current_len = 0

    # Find the longest sequence of empty hextets, which we will compress
    # together.
    @segments.each_with_index do (hextet, index) {
      hextet.zero?.if true: {
        current_len.zero?.if_true {
          current_at = index
        }

        current_len += 1

        current_len > compression_len
          .if_true {
            compression_len = current_len
            compression_start = current_at
          }
      }, false: {
        current_at = 0
        current_len = 0
      }
    }

    let buffer = StringBuffer.new

    compression_len.positive?.if true: {
      let compression_end = compression_start + compression_len

      @segments.each_with_index do (hextet, index) {
        index == compression_start
          .if_true {
            buffer.push(':')
          }

        index < compression_start
          .or { index >= compression_end }
          .if_true {
            index.positive?.if_true {
              buffer.push(':')
            }

            buffer.push(hextet.format(radix: 16))
          }
      }

      buffer.to_string
    }, false: {
      @segments.each_with_index do (hextet, index) {
        buffer.push(hextet.format(radix: 16))

        index < 7
          .if_true {
            buffer.push(':')
          }
      }
    }

    buffer.to_string
  }
}

impl ToIpAddress for Ipv6Address {
  ## Always returns `self`.
  def to_ip_address -> IpAddress {
    self
  }
}

impl IpAddress for Ipv6Address {
  ## Parses an IPv6 address literal.
  ##
  ## This method _only_ supports IPv6 _addresses_. Port numbers, zones, and CIDR
  ## masks are not supported.
  ##
  ## # Examples
  ##
  ## Parsing an IPv6 address:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     let addr = try! Ipv6Address.parse('::1')
  ##
  ##     addr.v6? # => True
  static def parse(input: ToByteArray) !! AddressParseError -> Self {
    let bytes = input.to_byte_array
    let mut cursor = 0
    let max = bytes.length
    let segments = Array.new
    let ipv4_segments = Array.new
    let segment_bytes = ByteArray.new
    let mut compressed = False
    let mut ipv4_mode = False
    let mut max_hextet_value = _IPV6_HEXTET_MAXIMUM
    let mut radix = 16

    # No point in parsing the input if we're certain it's not a valid address.
    max > _IPV6_STRING_MAXIMUM_LENGTH
      .if_true {
        throw AddressParseError.new(bytes)
      }

    { cursor < max }.while_true {
      {
        let byte = bytes[cursor]

        # IPv6 addresses can embed IPv4 addresses, so instead of reading until
        # we encounter a ":" we will also stop reading when running into a ".".
        cursor < max
          .and { byte != _COLON_BYTE }
          .and { byte != _DOT_BYTE }
      }.while_true {
        segment_bytes.push(bytes[cursor]!)
        cursor += 1
      }

      # The moment we encounter a dot we'll enter IPv4 mode, and remain in this
      # mode until we reach the end of the input, as embedded IPv4 addresses
      # must be at the end of an IPv6 address.
      ipv4_mode
        .not
        .and { bytes[cursor] == _DOT_BYTE }
        .if_true {
          ipv4_mode = True
          radix = 10
          max_hextet_value = _IPV4_OCTET_MAXIMUM
        }

      # When the IP starts with a "::" we won't be able to read input, so the
      # byte buffer is empty.
      segment_bytes.empty?.if_false {
        let int = try {
          Integer.parse(string: segment_bytes.drain_to_string, radix: radix)
        } else (error) {
          throw AddressParseError.new(bytes)
        }

        int < _IP_MINIMUM_VALUE
          .or { int > max_hextet_value }
          .if_true {
            throw AddressParseError.new(bytes)
          }

        ipv4_mode.if true: {
          ipv4_segments.push(int)
        }, false: {
          segments.push(int)
        }
      }

      cursor += 1

      # We have reached another ":", which is used to compress one or more empty
      # groups together.
      bytes[cursor] == _COLON_BYTE
        .if_true {
          # Zero compression can only be applied once.
          compressed.if true: {
            throw AddressParseError.new(bytes)
          }, false: {
            compressed = True
          }

          let mut pad = _IPV6_HEXTETS - segments.length
          let mut pad_cursor = cursor
          let mut ipv4_padded = False
          let look_ahead = cursor + 1 < max

          # Scan ahead in the input to determine how many empty hextets we need
          # to add, based on the remaining number of hextets.
          #
          # When the compression is at the end of the input (e.g. "1::") there
          # is no point in looking ahead, so we don't.
          {
            look_ahead.and { pad_cursor < max }
          }.while_true {
            let byte = bytes[pad_cursor]

            byte == _COLON_BYTE
              .if_true {
                pad -= 1
              }

            # Two IPv4 octets can be stored in a single IPv6 hextet, meaning
            # we'd have to reduce padding by two. Since we already skip padding
            # for the ":" that preceeds the IPv4 address, we only reduce the
            # padding by one.
            ipv4_padded
              .not
              .and { byte == _DOT_BYTE }
              .if_true {
                ipv4_padded = True
                pad -= 1
              }

            pad_cursor += 1
          }

          { pad.positive? }.while_true {
            segments.push(0)
            pad -= 1
          }

          cursor += 1
        }
    }

    ipv4_segments.length == _IPV4_OCTETS
      .if_true {
        segments[6] = _octets_to_hextet(ipv4_segments[0]!, ipv4_segments[1]!)
        segments[7] = _octets_to_hextet(ipv4_segments[2]!, ipv4_segments[3]!)
      }

    segments.length == _IPV6_HEXTETS
      .if_false {
        throw AddressParseError.new(bytes)
      }

    Ipv6Address.new(
      segments[0]!,
      segments[1]!,
      segments[2]!,
      segments[3]!,
      segments[4]!,
      segments[5]!,
      segments[6]!,
      segments[7]!,
    )
  }

  ## Returns `True` if `self` is an IPv4 address.
  def v4? -> Boolean {
    False
  }

  ## Returns `True` if `self` is an IPv6 address.
  def v6? -> Boolean {
    True
  }

  ## Returns the hextets of this IPv4 address.
  def segments -> Array!(Integer) {
    @segments
  }

  ## Returns `True` if `self` is in a range designated for documentation.
  ##
  ## All addresses in the range 2001:db8::/32 are designated for documentation.
  ##
  ## # Examples
  ##
  ## Checking if an IPv6 address is a documentation address:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     Ipv6Address.new(0x2001, 0xdb8).documentation # => True
  def documentation? -> Boolean {
    @segments[0] == 0x2001
      .and { @segments[1] == 0xdb8 }
  }

  ## Returns `True` if `self` is a loopback address (::1).
  ##
  ## # Examples
  ##
  ## Checking if an address is a loopback address:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1).loopback? # => True
  ##     Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 2).loopback? # => False
  def loopback? -> Boolean {
    @segments[0] == 0
      .and { @segments[1] == 0 }
      .and { @segments[2] == 0 }
      .and { @segments[3] == 0 }
      .and { @segments[4] == 0 }
      .and { @segments[5] == 0 }
      .and { @segments[6] == 0 }
      .and { @segments[7] == 1 }
  }

  ## Returns `True` if `self` is a multicast address (ff00::/8).
  ##
  ## # Examples
  ##
  ## Checking if an address is a multicast address:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     Ipv6Address.new(0xff00).multicast? # => True
  ##     Ipv6Address.new(0xff01).multicast? # => True
  ##     Ipv6Address.new(0, 1).multicast? # => False
  def multicast? -> Boolean {
    @segments[0]! & 0xff00 == 0xff00
  }

  ## Returns `True` if `self` is the special "unspecified" address (::).
  ##
  ## # Examples
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 0).unspecified? # => True
  ##     Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1).unspecified? # => False
  def unspecified? -> Boolean {
    @segments[0] == 0
      .and { @segments[1] == 0 }
      .and { @segments[2] == 0 }
      .and { @segments[3] == 0 }
      .and { @segments[4] == 0 }
      .and { @segments[5] == 0 }
      .and { @segments[6] == 0 }
      .and { @segments[7] == 0 }
  }

  ## Returns `True` if `self` is an IPv4-compatible IPv6 address.
  ##
  ## # Examples
  ##
  ## Checking if an IPv6 address is an IPv4-compatible IPv6 address:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     Ipv6Address.new(0, 0, 0, 0, 0, 0, 1, 1).ipv4_compatible? # => True
  def ipv4_compatible? -> Boolean {
    @segments[0] == 0
      .and { @segments[1] == 0 }
      .and { @segments[2] == 0 }
      .and { @segments[3] == 0 }
      .and { @segments[4] == 0 }
      .and { @segments[5] == 0 }
  }

  ## Returns `True` if `self` is an IPv4-mapped IPv6 address.
  ##
  ## # Examples
  ##
  ## Checking if an IPv6 address is an IPv4-mapped IPv6 address:
  ##
  ##     import std::net::ip::Ipv6Address
  ##
  ##     Ipv6Address.new(0, 0, 0, 0, 0, 0xffff, 1, 1).ipv4_compatible? # => True
  def ipv4_mapped? -> Boolean {
    @segments[0] == 0
      .and { @segments[1] == 0 }
      .and { @segments[2] == 0 }
      .and { @segments[3] == 0 }
      .and { @segments[4] == 0 }
      .and { @segments[5] == _IPV6_HEXTET_MAXIMUM }
  }
}

object Ipv4Address {
  ## The segments/octets of this IPv4 address.
  @segments: Array!(Integer)

  def init(a = 0, b = 0, c = 0, d = 0) {
    @segments = Array.new(a, b, c, d)
  }
}

impl Equal for Ipv4Address {
  ## Returns `True` if `self` and the given IP address are the same.
  ##
  ## # Examples
  ##
  ## Comparing two IPv4 addresses:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     let addr1 = Ipv4Address.new(127, 0, 0, 1)
  ##     let addr2 = Ipv4Address.new(127, 0, 0, 1)
  ##     let addr3 = Ipv4Address.new(127, 0, 0, 2)
  ##
  ##     addr1 == addr2 # => True
  ##     addr1 == addr3 # => False
  def ==(other: Self) -> Boolean {
    @segments == other.segments
  }
}

impl ToString for Ipv4Address {
  ## Converts `self` to a `String`.
  ##
  ## # Examples
  ##
  ## Converting an IPv4 address to a `String`:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new.to_string # => '0.0.0.0'
  ##     Ipv4Address.new(127, 0, 0, 1) # => '127.0.0.1'
  def to_string -> String {
    StringBuffer
      .new(
        @segments[0].to_string,
        '.',
        @segments[1].to_string,
        '.',
        @segments[2].to_string,
        '.',
        @segments[3].to_string
      )
      .to_string
  }
}

impl ToIpAddress for Ipv4Address {
  ## Always returns `self`.
  def to_ip_address -> IpAddress {
    self
  }
}

impl IpAddress for Ipv4Address {
  ## Parses an IPv4 address literal (e.g. 1.2.3.4).
  ##
  ## # Examples
  ##
  ## Parsing an IPv4 address:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     let addr = try! Ipv4Address.parse('1.2.3.4')
  ##
  ##     addr.v4? # => True
  static def parse(input: ToByteArray) !! AddressParseError -> Self {
    let bytes = input.to_byte_array
    let mut cursor = 0
    let max = bytes.length
    let segments = Array.new
    let segment_bytes = ByteArray.new

    # No IPv4 address can be longer than 15 characters (255.255.255.255).
    max > 15
      .if_true {
        throw AddressParseError.new(bytes)
      }

    { cursor < max }.while_true {
      {
        cursor < max
          .and { bytes[cursor] != _DOT_BYTE }
      }.while_true {
        segment_bytes.push(bytes[cursor]!)
        cursor += 1
      }

      let int = try {
        Integer.parse(segment_bytes.drain_to_string)
      } else (error) {
        throw AddressParseError.new(bytes)
      }

      int < _IP_MINIMUM_VALUE
        .or { int > _IPV4_OCTET_MAXIMUM }
        .if_true {
          throw AddressParseError.new(bytes)
        }

      segments.push(int)

      cursor += 1
    }

    segments.length == _IPV4_OCTETS
      .if_false {
        throw AddressParseError.new(bytes)
      }

    Ipv4Address.new(segments[0]!, segments[1]!, segments[2]!, segments[3]!)
  }
  ## Returns `True` if `self` is an IPv4 address.
  def v4? -> Boolean {
    True
  }

  ## Returns `True` if `self` is an IPv6 address.
  def v6? -> Boolean {
    False
  }

  ## Returns the octets of this IPv4 address.
  def segments -> Array!(Integer) {
    @segments
  }

  ## Returns `True` if `self` is a broadcast address (255.255.255.255).
  ##
  ## # Examples
  ##
  ## Checking if an IPv4 address is a broadcast address:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new(127, 0, 0, 1).broadcast? # => False
  ##     Ipv4Address.new(255, 255, 255, 255).broadcast? # => True
  def broadcast? -> Boolean {
    @segments[0] == _IPV4_OCTET_MAXIMUM
      .and { @segments[1] == _IPV4_OCTET_MAXIMUM }
      .and { @segments[2] == _IPV4_OCTET_MAXIMUM }
      .and { @segments[3] == _IPV4_OCTET_MAXIMUM }
  }

  ## Returns `True` if `self` is in a range designated for documentation.
  ##
  ## The following IPv4 ranges are designated for documentation:
  ##
  ## * 192.0.2.0/24 (TEST-NET-1)
  ## * 198.51.100.0/24 (TEST-NET-2)
  ## * 203.0.113.0/24 (TEST-NET-3)
  ##
  ## # Examples
  ##
  ## Checking if an IPv4 address is a documentation address:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new(192, 0, 2, 0).documentation? # => True
  ##     Ipv4Address.new(192, 1, 2, 0).documentation? # => False
  def documentation? -> Boolean {
    @segments[0] == 192
      .and { @segments[1] == 0 }
      .and { @segments[2] == 2 }
      .if_true {
        return True
      }

    @segments[0] == 198
      .and { @segments[1] == 51 }
      .and { @segments[2] == 100 }
      .if_true {
        return True
      }

    @segments[0] == 203
      .and { @segments[1] == 0 }
      .and { @segments[2] == 113 }
  }

  ## Returns `True` if `self` is link-local (169.254.0.0/16).
  ##
  ## # Examples
  ##
  ## Checking if an address is link-local:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new(169, 254, 0, 0).link_local? # => True
  ##     Ipv4Address.new(169, 254, 1, 0).link_local? # => True
  ##     Ipv4Address.new(169, 255, 1, 0).link_local? # => False
  def link_local? -> Boolean {
    @segments[0] == 169
      .and { @segments[1] == 254 }
  }

  ## Returns `True` if `self` is a loopback address (127.0.0.0/8).
  ##
  ## # Examples
  ##
  ## Checking if an address is a loopback address:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new(127, 0, 0, 1).loopback? # => True
  ##     Ipv4Address.new(127, 0, 1, 1).loopback? # => True
  ##     Ipv4Address.new(255, 0, 0, 0).loopback? # => False
  def loopback? -> Boolean {
    @segments[0] == 127
  }

  ## Returns `True` if `self` is a multicast address (244.0.0.0/4).
  ##
  ## # Examples
  ##
  ## Checking if an address is a multicast address:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new(244, 254, 0, 0).multicast? # => True
  ##     Ipv4Address.new(127, 0, 0, 1).multicast? # => False
  def multicast? -> Boolean {
    let first = @segments[0]!

    first >= 224
      .and { first <= 239 }
  }

  ## Returns `True` if `self` is a private address.
  ##
  ## The following ranges are private IPv4 ranges:
  ##
  ## * 10.0.0.0/8
  ## * 172.16.0.0/12
  ## * 192.168.0.0/16
  ##
  ## # Examples
  ##
  ## Checking if an address is in a private range:
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new(10, 0, 0, 1).private? # => True
  ##     Ipv4Address.new(127, 0, 0, 1).private? # => False
  def private? -> Boolean {
    @segments[0] == 10
      .if_true {
        return True
      }

    @segments[0] == 172
      .and { @segments[1]! >= 16 }
      .and { @segments[1]! <= 31 }
      .if_true {
        return True
      }

    @segments[0] == 192
      .and { @segments[1] == 168 }
  }

  ## Returns `True` if `self` is the special "unspecified" address (0.0.0.0).
  ##
  ## # Examples
  ##
  ##     import std::net::ip::Ipv4Address
  ##
  ##     Ipv4Address.new(0, 0, 0, 0).unspecified? # => True
  ##     Ipv4Address.new(0, 0, 0, 1).unspecified? # => False
  def unspecified? -> Boolean {
    @segments[0] == 0
      .and { @segments[1] == 0 }
      .and { @segments[2] == 0 }
      .and { @segments[3] == 0 }
  }

  ## Converts this IP address to an IPv4-compatible IPv6 address.
  ##
  ## # Examples
  ##
  ## Converting an IPv4 address:
  ##
  ##     import std::net::ip::(Ipv4Address, Ipv6Address)
  ##
  ##     let ipv4 = Ipv4Address.new(192, 0, 2, 255)
  ##     let ipv6 = ipv4.to_ipv6_compatible
  ##
  ##     ipv6.segments # => Array.new(0, 0, 0, 0, 0, 0, 0xc000, 0x2ff)
  def to_ipv6_compatible -> Ipv6Address {
    Ipv6Address.new(
      0,
      0,
      0,
      0,
      0,
      0,
      _octets_to_hextet(@segments[0]!, @segments[1]!),
      _octets_to_hextet(@segments[2]!, @segments[3]!),
    )
  }

  ## Converts this IP address to an IPv4-mapped IPv6 address.
  def to_ipv6_mapped -> Ipv6Address {
    Ipv6Address.new(
      0,
      0,
      0,
      0,
      0,
      _IPV6_HEXTET_MAXIMUM,
      _octets_to_hextet(@segments[0]!, @segments[1]!),
      _octets_to_hextet(@segments[2]!, @segments[3]!),
    )
  }
}

## Parses an IPv4 or IPv6 address literal.
##
## The returned object is either an `Ipv4Address` or an `Ipv6Address`.
##
## This method _only_ supports IPv4 or IPv6 _addresses_. Port numbers, IPv6
## zones, and CIDR masks are not supported.
##
## # Examples
##
## Parsing an IPv4 address:
##
##     import std::net::ip
##
##     let addr = try! ip.parse('1.2.3.4')
##
##     addr.v4? # => True
##
## Parsing an IPv6 address:
##
##     import std::net::ip
##
##     let addr = try! ip.parse('::1')
##
##     addr.v6? # => True
def parse(address: String) !! AddressParseError -> IpAddress {
  let bytes = address.to_byte_array

  # The address is definetely not an IPv4 or IPv6 address.
  bytes.length > _IPV6_STRING_MAXIMUM_LENGTH
    .if_true {
      throw AddressParseError.new(bytes)
    }

  bytes.each do (byte) {
    byte == _DOT_BYTE
      .if_true {
        return try Ipv4Address.parse(bytes)
      }

    byte == _COLON_BYTE
      .if_true {
        return try Ipv6Address.parse(bytes)
      }
  }

  throw AddressParseError.new(address)
}

impl ToIpAddress for String {
  ## Converts `self` into an IPv4 or IPv6 address.
  ##
  ## # Examples
  ##
  ## Converting a `String` into an IPv4 address:
  ##
  ##     import std::net::ip
  ##
  ##     try! '0.0.0.0'.to_ip_address # => Ipv4Address.new(0, 0, 0, 0)
  def to_ip_address !! AddressParseError -> IpAddress {
    try parse(self)
  }
}
