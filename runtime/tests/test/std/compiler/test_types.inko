import std::compiler::module_name::ModuleName
import std::compiler::symbol_table::SymbolTable
import std::compiler::types
import std::compiler::types::*
import std::hash::DefaultHasher
import std::operators::Equal
import std::test::*
import std::test::test::Failure

class DummyType {
  static def new -> Self {
    Self {}
  }
}

impl Equal for DummyType {}

impl Type for DummyType {
  def type_name -> String {
    'DummyType'
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeScope
  ) -> Boolean {
    False
  }
}

class DummyBlock {
  @layout: BlockLayout

  static def new -> Self {
    Self { @layout = BlockLayout.new(NeverType.new) }
  }
}

impl Equal for DummyBlock {}

impl Type for DummyBlock {
  def type_name -> String {
    '<block>'
  }

  def type_compatible?(
    with: Type,
    builtins: Builtins,
    scope: TypeScope
  ) -> Boolean {
    False
  }
}

impl BlockType for DummyBlock {
  def layout -> BlockLayout {
    @layout
  }
}

def type_scope(self_type: Type) -> TypeScope {
  let module = ModuleType.new(ModuleName.new(Array.new('foo')))

  TypeScope.new(module: module, self_type: self_type)
}

def assert_compatible(
  compare: Type,
  with: Type,
  builtins = Builtins.new,
  self_type = compare
) !! Failure {
  let scope = TypeScope.new(module: new_module, self_type: self_type)

  try assert_true(
    compare.type_compatible?(with: with, builtins: builtins, scope: scope)
  )
}

def assert_not_compatible(
  compare: Type,
  with: Type,
  builtins = Builtins.new,
  self_type = compare
) !! Failure {
  let scope = TypeScope.new(module: new_module, self_type: self_type)

  try assert_false(
    compare.type_compatible?(with: with, builtins: builtins, scope: scope)
  )
}

def new_module(name = 'foo') -> ModuleType {
  ModuleType.new(ModuleName.new(Array.new(name)))
}

def with_generic_type(block: do (ClassInstance, TypeParameterType)) {
  let array_type = ClassType.new('Array')
  let param = TypeParameterType.new('T')

  array_type.type_parameters.define(name: param.name, type: param)
  block.call(array_type.new_instance, param)
}

def tests(t: Tests) {
  t.group('std::compiler::types.format_type_name') do (g) {
    g.test('Formatting a type name without any type parameters') {
      let name =
        types.format_type_name(name: 'String', type_parameters: SymbolTable.new)

      try assert_equal(name, 'String')
    }

    g.test('Formatting a type name with type parameters') {
      let table = SymbolTable.new

      table.define(name: 'A', type: TypeParameterType.new('A'))
      table.define(name: 'B', type: TypeParameterType.new('B'))

      let name = types.format_type_name(name: 'Pair', type_parameters: table)

      try assert_equal(name, 'Pair!(A, B)')
    }

    g.test('Formatting a type name with initialised type parameters') {
      let table = SymbolTable.new
      let types = TypeParameterTypes.new
      let param = TypeParameterType.new('A')

      table.define(name: param.name, type: param)
      table.define(name: 'B', type: TypeParameterType.new('B'))

      types[param] = NeverType.new

      let name = ::types.format_type_name(
        name: 'Pair',
        type_parameters: table,
        type_parameter_types: types
      )

      try assert_equal(name, 'Pair!(Never, B)')
    }
  }

  t.group('std::compiler::types::Type.error?') do (g) {
    g.test('Types are not error types by default') {
      try assert_false(DummyType.new.error?)
    }
  }

  t.group('std::compiler::types::Type.self_type?') do (g) {
    g.test('Types are not self types by default') {
      try assert_false(DummyType.new.self_type?)
    }
  }

  t.group('std::compiler::types::Type.initialise?') do (g) {
    g.test("Types can't be initialised by default") {
      try assert_false(DummyType.new.initialise?)
    }
  }

  t.group('std::compiler::types::Type.number_of_type_parameters') do (g) {
    g.test('Types have no type parameters by default') {
      try assert_true(DummyType.new.number_of_type_parameters.zero?)
    }
  }

  t.group('std::compiler::types::Type.lookup_attribute') do (g) {
    g.test('Looking up attributes returns a None') {
      try assert_true(DummyType.new.lookup_attribute('foo').none?)
    }
  }

  t.group('std::compiler::types::Type.lookup_method') do (g) {
    g.test('Looking up methods returns a None') {
      try assert_true(DummyType.new.lookup_method('foo').none?)
    }
  }

  t.group('std::compiler::types::Type.lookup_type') do (g) {
    g.test('Looking up types returns a None') {
      try assert_true(DummyType.new.lookup_type('Foo').none?)
    }
  }

  t.group('std::compiler::types::Type.lookup_type_parameter') do (g) {
    g.test('Looking up type parameters returns a None') {
      try assert_true(DummyType.new.lookup_type_parameter('T').none?)
    }
  }

  t.group('std::compiler::types::Type.lookup_type_parameter_type') do (g) {
    g.test('Looking up type parameter types returns a None') {
      let param = TypeParameterType.new('T')

      try assert_true(DummyType.new.lookup_type_parameter_type(param).none?)
    }
  }

  t.group('std::compiler::types::Type.new_instance') do (g) {
    g.test('Obtaining a new instance of a type returns the type itself') {
      let type = DummyType.new

      try assert_equal(type.new_instance, type)
    }
  }

  t.group('std::compiler::types::Type.type_compatible_with_all?') do (g) {
    g.test('Compares for type equality with all the given types') {
      let type = DummyType.new
      let types = Array.new(NeverType.new)

      try assert_false(
        type.type_compatible_with_all?(
          types: types,
          builtins: Builtins.new,
          scope: TypeScope.new(module: new_module, self_type: type)
        )
      )
    }
  }

  t.group('std::compiler::types::Type.substitute') do (g) {
    g.test('Substituting a type returns the type itself') {
      let type = DummyType.new

      try assert_same_object(type.substitute(type_scope(type)), type)
    }
  }

  t.group('std::compiler::types::TypeParameterTypes.assign_in_order') do (g) {
    g.test('Initialising type parameters in the order they are defined in') {
      let table = SymbolTable.new
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let types = TypeParameterTypes.new
      let type1 = ClassType.new('A')
      let type2 = NeverType.new

      table.define(name: param1.name, type: param1)
      table.define(name: param2.name, type: param2)

      types.assign_in_order(
        table: table,
        arguments: Array.new!(Type)(type1, type2)
      )

      try assert_same_object(types[param1], type1)
      try assert_same_object(types[param2], type2)
    }
  }

  t.group('std::compiler::types::TypeParameterTypes.substitute') do (g) {
    g.test('Substituting all type parameter types') {
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let types = TypeParameterTypes.new
      let self_type = ClassType.new('String')

      types[param1] = SelfType.new
      types[param2] = NeverType.new

      let new_types = types.substitute(type_scope(self_type))

      try assert_true(new_types[param1].object_instance_of?(self_type))
      try assert_same_object(new_types[param2], types[param2])
    }
  }

  t.group('std::compiler::types::TypeParameterTypes.type_compatible?') do (g) {
    g.test('Checking if a TypeParameterTypes is compatible with another TypeParameterTypes') {
      let types1 = TypeParameterTypes.new
      let types2 = TypeParameterTypes.new
      let types3 = TypeParameterTypes.new
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let self_type = ClassType.new('Foo')
      let builtins = Builtins.new
      let object_type = ClassType.new('A')
      let scope = TypeScope.new(module: new_module, self_type: self_type)

      types1[param1] = object_type
      types1[param2] = NeverType.new
      types2[param1] = object_type
      types2[param2] = object_type

      try assert_false(
        types1.type_compatible?(
          with: types3,
          builtins: builtins,
          scope: scope
        )
      )

      try assert_true(
        types1.type_compatible?(
          with: types2,
          builtins: builtins,
          scope: scope
        )
      )

      try assert_false(
        types2.type_compatible?(
          with: types1,
          builtins: builtins,
          scope: scope
        )
      )
    }
  }

  t.group('std::compiler::types::TypeParameterTypes.copy_into_type') do (g) {
    g.test('Copying the type arguments of an object instance') {
      let builtins = Builtins.new
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let list_type = ClassType.new('List')

      list_type.type_parameters.define(name: param1.name, type: param1)

      let list_instance = list_type.new_instance
      let ptypes = TypeParameterTypes.new

      ptypes[param1] = builtins.integer_type.new_instance
      ptypes[param2] = builtins.float_type.new_instance

      ptypes.copy_into_type(list_instance)

      try assert_equal(list_instance.type_parameter_types.length, 1)
      try assert_same_object(list_instance.type_parameter_types[param1], ptypes[param1])
    }

    g.test('Copying the type arguments of a trait instance') {
      let builtins = Builtins.new
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let to_list_type = ClassType.new('ToList')

      to_list_type.type_parameters.define(name: param1.name, type: param1)

      let to_list_instance = to_list_type.new_instance
      let ptypes = TypeParameterTypes.new

      ptypes[param1] = builtins.integer_type.new_instance
      ptypes[param2] = builtins.float_type.new_instance

      ptypes.copy_into_type(to_list_instance)

      try assert_equal(to_list_instance.type_parameter_types.length, 1)
      try assert_same_object(to_list_instance.type_parameter_types[param1], ptypes[param1])
    }

    g.test('Copying the type arguments of a regular object') {
      let builtins = Builtins.new
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let list_type = ClassType.new('List')
      let list_instance = list_type.new_instance
      let ptypes = TypeParameterTypes.new

      ptypes[param1] = builtins.integer_type.new_instance
      ptypes[param2] = builtins.float_type.new_instance

      ptypes.copy_into_type(list_instance)

      try assert_true(list_instance.type_parameter_types.empty?)
    }
  }

  t.group('std::compiler::types::TypeParameterTypes.copy_into_type_parameter_types') do (g) {
    g.test('Unassigned type parameters are assigned their new types') {
      let builtins = Builtins.new
      let params = SymbolTable.new
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')

      params.define(name: param1.name, type: param1)

      let source = TypeParameterTypes.new
      let target = TypeParameterTypes.new

      source[param1] = builtins.integer_type.new_instance
      source[param2] = builtins.float_type.new_instance

      source.copy_into_type_parameter_types(parameters: params, arguments: target)

      try assert_equal(target.length, 1)
      try assert_same_object(target[param1], source[param1])
    }

    g.test('Type parameters already assigned are not re-assigned') {
      let builtins = Builtins.new
      let params = SymbolTable.new
      let param = TypeParameterType.new('A')

      params.define(name: param.name, type: param)

      let source = TypeParameterTypes.new
      let target = TypeParameterTypes.new
      let float = builtins.float_type.new_instance

      source[param] = builtins.integer_type.new_instance
      target[param] = float

      source.copy_into_type_parameter_types(parameters: params, arguments: target)

      try assert_equal(target.length, 1)
      try assert_same_object(target[param], float)
    }

    g.test('Type parameters that are not owned are not assigned') {
      let builtins = Builtins.new
      let params = SymbolTable.new
      let param = TypeParameterType.new('A')
      let source = TypeParameterTypes.new
      let target = TypeParameterTypes.new

      source[param] = builtins.integer_type.new_instance

      source.copy_into_type_parameter_types(parameters: params, arguments: target)

      try assert_true(target.empty?)
    }
  }

  t.group('std::compiler::types::TypeParameterTypes.length') do (g) {
    g.test('Obtaining the number of types') {
      let types = TypeParameterTypes.new
      let param = TypeParameterType.new('A')

      try assert_equal(types.length, 0)

      types[param] = NeverType.new

      try assert_equal(types.length, 1)
    }
  }

  t.group('std::compiler::types::TypeParameterTypes.[]') do (g) {
    g.test('Obtaining the type of a type parameter') {
      let types = TypeParameterTypes.new
      let param = TypeParameterType.new('A')
      let type = NeverType.new

      try assert_true(types.get(param).none?)

      types[param] = type

      try assert_same_object(types[param], type)
    }
  }

  t.group('std::compiler::types::Builtins.boolean_type') do (g) {
    g.test('Obtaining the built-in Boolean type') {
      try assert_equal(Builtins.new.boolean_type.name, 'Boolean')
    }
  }

  t.group('std::compiler::types::Builtins.true_singleton') do (g) {
    g.test('Obtaining the built-in True singleton') {
      let builtins = Builtins.new

      try assert_same_object(builtins.true_singleton.instance_of, builtins.boolean_type)
    }
  }

  t.group('std::compiler::types::Builtins.false_singleton') do (g) {
    g.test('Obtaining the built-in False singleton') {
      let builtins = Builtins.new

      try assert_same_object(builtins.false_singleton.instance_of, builtins.boolean_type)
    }
  }

  t.group('std::compiler::types::Builtins.nil_type') do (g) {
    g.test('Obtaining the built-in NilType type') {
      try assert_equal(Builtins.new.nil_type.name, 'NilType')
    }
  }

  t.group('std::compiler::types::Builtins.nil_singleton') do (g) {
    g.test('Obtaining the built-in Nil singleton') {
      let builtins = Builtins.new

      try assert_same_object(builtins.nil_singleton.instance_of, builtins.nil_type)
    }
  }

  t.group('std::compiler::types::Builtins.block_type') do (g) {
    g.test('Obtaining the built-in Block type') {
      try assert_equal(Builtins.new.block_type.name, 'Block')
    }
  }

  t.group('std::compiler::types::Builtins.integer_type') do (g) {
    g.test('Obtaining the built-in Integer type') {
      try assert_equal(Builtins.new.integer_type.name, 'Integer')
    }
  }

  t.group('std::compiler::types::Builtins.float_type') do (g) {
    g.test('Obtaining the built-in Float type') {
      try assert_equal(Builtins.new.float_type.name, 'Float')
    }
  }

  t.group('std::compiler::types::Builtins.string_type') do (g) {
    g.test('Obtaining the built-in String type') {
      try assert_equal(Builtins.new.string_type.name, 'String')
    }
  }

  t.group('std::compiler::types::Builtins.module_type') do (g) {
    g.test('Obtaining the built-in Module type') {
      try assert_equal(Builtins.new.module_type.name, 'Module')
    }
  }

  t.group('std::compiler::types::Builtins.array_type') do (g) {
    g.test('Obtaining the built-in Array type') {
      let builtins = Builtins.new
      let array = builtins.array_type
      let param = array.type_parameters[ARRAY_TYPE_PARAMETER].type

      try assert_equal(array.name, 'Array')
      try assert_equal(array.number_of_type_parameters, 1)
      try assert_true(param.required_traits.empty?)
    }
  }

  t.group('std::compiler::types::Builtins.byte_array_type') do (g) {
    g.test('Obtaining the built-in ByteArray type') {
      try assert_equal(Builtins.new.byte_array_type.name, 'ByteArray')
    }
  }

  t.group('std::compiler::types::NeverType.type_name') do (g) {
    g.test('Obtaining the type name of a NeverType') {
      try assert_equal(NeverType.new.type_name, 'Never')
    }
  }

  t.group('std::compiler::types::NeverType.type_compatible?') do (g) {
    g.test('Comparing a NeverType with an ErrorType') {
      try assert_compatible(NeverType.new, ErrorType.new)
    }

    g.test('Comparing a NeverType with an AnyType') {
      try assert_compatible(NeverType.new, AnyType.new)
    }

    g.test('Comparing a NeverType with another NeverType') {
      try assert_compatible(NeverType.new, NeverType.new)
    }

    g.test('Comparing a NeverType with an ClassType') {
      try assert_compatible(NeverType.new, ClassType.new('String'))
    }

    g.test('Comparing a NeverType with an ClassInstance') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_compatible(NeverType.new, instance)
    }

    g.test('Comparing a NeverType with a TraitType') {
      try assert_compatible(NeverType.new, TraitType.new('ToString'))
    }

    g.test('Comparing a NeverType with a TraitInstance') {
      let trait_instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_compatible(NeverType.new, trait_instance)
    }

    g.test('Comparing a NeverType with a TypeParameterType') {
      with_generic_type do (type, param) {
        let never = NeverType.new

        try assert_compatible(compare: never, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, never)
      }
    }

    g.test('Comparing a NeverType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_compatible(compare: NeverType.new, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing a NeverType with a ModuleType') {
      let mod_type = new_module

      try assert_compatible(NeverType.new, mod_type)
    }

    g.test('Comparing a NeverType with a SelfType') {
      try assert_compatible(NeverType.new, SelfType.new)
    }
  }

  t.group('std::compiler::types::InferType.type_name') do (g) {
    g.test('Obtaining the type name of an InferType') {
      try assert_equal(InferType.new.type_name, '?')
    }
  }

  t.group('std::compiler::types::InferType.type_compatible?') do (g) {
    g.test('Comparing an InferType with another InferType') {
      try assert_compatible(InferType.new, InferType.new)
    }

    g.test('Comparing an InferType with an ErrorType') {
      try assert_compatible(InferType.new, ErrorType.new)
    }

    g.test('Comparing an InferType with an AnyType') {
      try assert_not_compatible(InferType.new, AnyType.new)
    }

    g.test('Comparing an InferType with a NeverType') {
      try assert_not_compatible(InferType.new, NeverType.new)
    }

    g.test('Comparing an InferType with an ClassType') {
      try assert_not_compatible(InferType.new, ClassType.new('String'))
    }

    g.test('Comparing an InferType with an ClassInstance') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_not_compatible(InferType.new, instance)
    }

    g.test('Comparing an InferType with a TraitType') {
      try assert_not_compatible(InferType.new, TraitType.new('ToString'))
    }

    g.test('Comparing an InferType with a TraitInstance') {
      let trait_instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_not_compatible(InferType.new, trait_instance)
    }

    g.test('Comparing an Infertype with a TypeParameterType') {
      with_generic_type do (type, param) {
        let infer = InferType.new

        try assert_not_compatible(compare: infer, with: param, self_type: type)
      }
    }

    g.test('Comparing an InferType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: InferType.new, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing an InferType with a ModuleType') {
      let mod_type = new_module

      try assert_not_compatible(InferType.new, mod_type)
    }

    g.test('Comparing an InferType with a SelfType') {
      try assert_not_compatible(InferType.new, SelfType.new)
    }
  }

  t.group('std::compiler::types::AnyType.type_name') do (g) {
    g.test('Obtaining the type name of an AnyType') {
      try assert_equal(AnyType.new.type_name, 'Any')
    }
  }

  t.group('std::compiler::types::AnyType.type_compatible?') do (g) {
    g.test('Comparing an AnyType with an InferType') {
      try assert_compatible(AnyType.new, InferType.new)
    }

    g.test('Comparing an AnyType with an ErrorType') {
      try assert_compatible(AnyType.new, ErrorType.new)
    }

    g.test('Comparing an AnyType with another AnyType') {
      try assert_compatible(AnyType.new, AnyType.new)
    }

    g.test('Comparing an AnyType with a NeverType') {
      try assert_not_compatible(AnyType.new, NeverType.new)
    }

    g.test('Comparing an AnyType with an ClassType') {
      try assert_not_compatible(AnyType.new, ClassType.new('String'))
    }

    g.test('Comparing an AnyType with an ClassInstance') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_not_compatible(AnyType.new, instance)
    }

    g.test('Comparing an AnyType with a TraitType') {
      try assert_not_compatible(AnyType.new, TraitType.new('ToString'))
    }

    g.test('Comparing an AnyType with a TraitInstance') {
      let trait_instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_not_compatible(AnyType.new, trait_instance)
    }

    g.test('Comparing an AnyType with a TypeParameterType') {
      with_generic_type do (type, param) {
        let any = AnyType.new

        try assert_compatible(compare: any, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, any)
      }
    }

    g.test('Comparing an AnyType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: AnyType.new, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing an AnyType with a ModuleType') {
      let mod_type = new_module

      try assert_not_compatible(AnyType.new, mod_type)
    }

    g.test('Comparing an AnyType with a SelfType') {
      try assert_compatible(
        compare: AnyType.new,
        with: SelfType.new,
        self_type: AnyType.new
      )

      try assert_not_compatible(
        compare: AnyType.new,
        with: SelfType.new,
        self_type: ClassType.new('String')
      )
    }
  }

  t.group('std::compiler::types::SelfType.type_name') do (g) {
    g.test('Obtaining the type name of a SelfType') {
      try assert_equal(SelfType.new.type_name, 'Self')
    }
  }

  t.group('std::compiler::types::SelfType.self_type?') do (g) {
    g.test('Checking if a type is a SelfType') {
      try assert_true(SelfType.new.self_type?)
    }
  }

  t.group('std::compiler::types::SelfType.type_compatible?') do (g) {
    g.test('Comparing a SelfType with a type that is not the current Self type') {
      try assert_not_compatible(
        compare: SelfType.new,
        with: ClassType.new('String'),
        builtins: Builtins.new,
        self_type: ClassType.new('Integer')
      )
    }

    g.test('Comparing a SelfType with a type that is the current Self type') {
      let obj_type = ClassType.new('String')
      let obj_instance = obj_type.new_instance

      try assert_compatible(
        compare: SelfType.new,
        with: obj_instance,
        builtins: Builtins.new,
        self_type: obj_instance
      )
    }

    g.test('Comparing a SelfType with another SelfType') {
      let obj_type = ClassType.new('String')

      try assert_compatible(
        compare: SelfType.new,
        with: SelfType.new,
        builtins: Builtins.new,
        self_type: obj_type
      )
    }

    g.test('Comparing a SelfType with another SelfType when the self type is also a SelfType') {
      try assert_not_compatible(
        compare: SelfType.new,
        with: SelfType.new,
        builtins: Builtins.new,
        self_type: SelfType.new
      )
    }

    g.test('Comparing a SelfType with an AnyType') {
      try assert_compatible(SelfType.new, AnyType.new)
    }

    g.test('Comparing a SelfType with an ErrorType') {
      try assert_compatible(SelfType, ErrorType.new)
    }
  }

  t.group('std::compiler::types::SelfType.substitute') do (g) {
    g.test('Substituting Self for the self type') {
      let type = ClassType.new('String')
      let sub = SelfType.new.substitute(type_scope(type))

      try assert_true(sub.object_instance_of?(type))
    }
  }

  t.group('std::compiler::types::ErrorType.type_name') do (g) {
    g.test('Obtaining the type name of an ErrorType') {
      try assert_equal(ErrorType.new.type_name, '<type error>')
    }
  }

  t.group('std::compiler::types::ErrorType.error?') do (g) {
    g.test('Checking if a type is an error type') {
      try assert_true(ErrorType.new.error?)
    }
  }

  t.group('std::compiler::types::ErrorType.type_compatible?') do (g) {
    g.test('Comparing a ErrorType with another ErrorType') {
      try assert_compatible(ErrorType.new, ErrorType.new)
    }

    g.test('Comparing a ErrorType with an AnyType') {
      try assert_compatible(ErrorType.new, AnyType.new)
    }

    g.test('Comparing a ErrorType with a NeverType') {
      try assert_compatible(ErrorType.new, NeverType.new)
    }

    g.test('Comparing a ErrorType with an ClassType') {
      try assert_compatible(ErrorType.new, ClassType.new('String'))
    }

    g.test('Comparing a ErrorType with an ClassInstance') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_compatible(ErrorType.new, instance)
    }

    g.test('Comparing a ErrorType with a TraitType') {
      try assert_compatible(ErrorType.new, TraitType.new('ToString'))
    }

    g.test('Comparing a ErrorType with a TraitInstance') {
      let trait_instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_compatible(ErrorType.new, trait_instance)
    }

    g.test('Comparing a ErrorType with a TypeParameterType') {
      try assert_compatible(ErrorType.new, TypeParameterType.new('T'))
    }

    g.test('Comparing a ErrorType with a ModuleType') {
      let mod_type = new_module

      try assert_compatible(ErrorType.new, mod_type)
    }

    g.test('Comparing a ErrorType with a SelfType') {
      try assert_compatible(ErrorType.new, SelfType.new)
    }
  }

  t.group('std::compiler::types::TypeParameterType.name') do (g) {
    g.test('Obtaining the name of a type parameter') {
      try assert_equal(TypeParameterType.new('T').name, 'T')
    }
  }

  t.group('std::compiler::types::TypeParameterType.required_traits') do (g) {
    g.test('Obtaining the required traits of a type parameter') {
      let required = Array.new(TraitInstance.new(TraitType.new('ToString')))
      let param = TypeParameterType.new(name: 'T', required_traits: required)

      try assert_same_object(param.required_traits, required)
    }
  }

  t.group('std::compiler::types::TypeParameterType.lookup_method') do (g) {
    g.test('Looking up a method from a required trait') {
      let to_string_trait = TraitType.new('ToString')
      let to_string = MethodType
        .new(name: 'to_string', layout: BlockLayout.new(AnyType.new))

      to_string_trait
        .default_methods
        .define(name: to_string.name, type: to_string)

      let required = Array.new(to_string_trait.new_instance)
      let param = TypeParameterType.new(name: 'T', required_traits: required)

      try assert_same_object(param.lookup_method(to_string.name).get.type, to_string)
    }
  }

  t.group('std::compiler::types::TypeParameterType.type_name') do (g) {
    g.test('Obtaining the type name of an empty TypeParameterType') {
      try assert_equal(TypeParameterType.new('T').type_name, 'T')
    }

    g.test('Obtaining the type name of a TypeParameterType with a required trait') {
      let instance = TraitInstance.new(TraitType.new('ToString'))
      let param =
        TypeParameterType.new(name: 'T', required_traits: Array.new(instance))

      try assert_equal(param.type_name, 'T: ToString')
    }

    g.test('Obtaining the type name of a TypeParameterType with multiple required traits') {
      let instance1 = TraitInstance.new(TraitType.new('ToString'))
      let instance2 = TraitInstance.new(TraitType.new('ToInteger'))
      let param = TypeParameterType
        .new(name: 'T', required_traits: Array.new(instance1, instance2))

      try assert_equal(param.type_name, 'T: ToString + ToInteger')
    }
  }

  t.group('std::compiler::types::TypeParameterType.type_compatible?') do (g) {
    g.test('Comparing a TypeParameterType with a ErrorType') {
      try assert_compatible(TypeParameterType.new('T'), ErrorType.new)
    }

    g.test('Comparing a TypeParameterType with an AnyType') {
      try assert_compatible(TypeParameterType.new('T'), AnyType.new)
    }

    g.test('Comparing a TypeParameterType with a NeverType') {
      try assert_not_compatible(TypeParameterType.new('T'), NeverType.new)
    }

    g.test('Comparing a TypeParameterType with an ClassType') {
      try assert_not_compatible(TypeParameterType.new('T'), ClassType.new('String'))
    }

    g.test('Comparing a TypeParameterType with an ClassInstance') {
      let instance = ClassInstance.new(ClassType.new('String'))
      let param = TypeParameterType.new('T')

      try assert_not_compatible(param, instance)
    }

    g.test('Comparing a TypeParameterType with a TraitType') {
      let trait_type = TraitType.new('ToString')
      let param1 = TypeParameterType.new('T')
      let param2 = TypeParameterType
        .new(name: 'T', required_traits: Array.new(TraitInstance.new(trait_type)))

      try assert_not_compatible(param1, trait_type)
      try assert_not_compatible(param2, trait_type)
    }

    g.test('Comparing a TypeParameterType with a TraitInstance') {
      let trait_type = TraitType.new('ToString')
      let param1 = TypeParameterType.new('T')
      let param2 = TypeParameterType
        .new(name: 'T', required_traits: Array.new(TraitInstance.new(trait_type)))

      let trait_instance = TraitInstance.new(trait_type)

      try assert_not_compatible(param1, trait_instance)
      try assert_compatible(param2, trait_instance)
    }

    g.test('Comparing a TypeParameterType with an empty TypeParameterType') {
      with_generic_type do (type, param) {
        let xparam = TypeParameterType.new('X')

        try assert_compatible(compare: xparam, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, xparam)
      }
    }

    g.test('Comparing a TypeParameterType with a non-empty TypeParameterType') {
      let trait_type = TraitType.new('ToString')
      let param1 = TypeParameterType.new('T')
      let param2 = TypeParameterType
        .new(name: 'T', required_traits: Array.new(TraitInstance.new(trait_type)))

      let param3 = TypeParameterType
        .new(name: 'T', required_traits: Array.new(TraitInstance.new(trait_type)))

      try assert_not_compatible(param1, param2)
      try assert_compatible(param2, param2)
      try assert_compatible(param2, param3)
    }

    g.test('Comparing a TypeParameterType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let aparam = TypeParameterType.new('A')
        let assigned = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: aparam, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing a TypeParameterType with a ModuleType') {
      let mod_type = new_module

      try assert_not_compatible(TypeParameterType.new('T'), mod_type)
    }

    g.test('Comparing a TypeParameterType with a SelfType') {
      let obj_type = ClassType.new('String')

      # A type parameter can never be used as a type for `self`, so this
      # comparison will always produce False.
      try assert_not_compatible(
        compare: TypeParameterType.new('T'),
        with: SelfType.new,
        builtins: Builtins.new,
        self_type: obj_type
      )
    }
  }

  t.group('std::compiler::types::TypeParameterType.substitute') do (g) {
    g.test('Substituting a type parameter with a type') {
      let obj_type = ClassType.new('Array')
      let param = TypeParameterType.new('T')

      obj_type.type_parameters.define(name: param.name, type: param)

      let assigned = NeverType.new
      let instance = obj_type.new_instance(Array.new(assigned))

      try assert_same_object(param.substitute(type_scope(instance)), assigned)
    }

    g.test('Substituting a type parameter without a type') {
      let obj_type = ClassType.new('Array')
      let param = TypeParameterType.new('T')

      try assert_same_object(param.substitute(type_scope(obj_type)), param)
    }

    g.test('Substituting a type parameter assigned to itself') {
      let obj_type = ClassType.new('Array')
      let param = TypeParameterType.new('T')

      obj_type.type_parameters.define(name: param.name, type: param)

      let instance = obj_type.new_instance(Array.new(param))

      try assert_same_object(param.substitute(type_scope(instance)), param)
    }

    g.test('Substituting a type parameter with a rigid type parameter') {
      let obj_type = ClassType.new('Array')
      let param = TypeParameterType.new('T')
      let rigid = RigidTypeParameterType.new(param)

      obj_type.type_parameters.define(name: param.name, type: param)

      let instance = obj_type.new_instance(Array.new(rigid))

      try assert_same_object(param.substitute(type_scope(instance)), rigid)
    }
  }

  t.group('std::compiler::types::RigidTypeParamter.type') do (g) {
    g.test('Obtaining the wrapped type parameter') {
      let param = TypeParameterType.new('A')
      let rigid = RigidTypeParameterType.new(param)

      try assert_same_object(rigid.type, param)
    }
  }

  t.group('std::compiler::types::RigidTypeParameterType.type_name') do (g) {
    g.test('Obtaining the type name of a rigid type parameter') {
      let to_string = TraitType.new('ToString')
      let param = TypeParameterType
        .new(name: 'A', required_traits: Array.new(to_string.new_instance))

      let rigid = RigidTypeParameterType.new(param)

      try assert_equal(rigid.type_name, param.type_name)
    }
  }

  t.group('std::compiler::types::RigidTypeParameterType.lookup_method') do (g) {
    g.test('Looking up a method from a required trait') {
      let to_string_trait = TraitType.new('ToString')
      let to_string = MethodType
        .new(name: 'to_string', layout: BlockLayout.new(AnyType.new))

      to_string_trait
        .default_methods
        .define(name: to_string.name, type: to_string)

      let required = Array.new(to_string_trait.new_instance)
      let param = TypeParameterType.new(name: 'T', required_traits: required)
      let rigid = RigidTypeParameterType.new(param)

      try assert_same_object(
        rigid.lookup_method(to_string.name).get.type,
        param.lookup_method(to_string.name).get.type
      )
    }
  }

  t.group('std::compiler::types::RigidTypeParameterType.type_compatible?') do (g) {
    g.test('Comparing a RigidTypeParameterType with another RigidTypeParameterType') {
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let rigid1 = RigidTypeParameterType.new(param1)
      let rigid2 = RigidTypeParameterType.new(param2)

      try assert_compatible(rigid1, rigid1)
      try assert_not_compatible(rigid1, rigid2)
    }

    g.test('Comparing a RigidTypeParameterType with a TypeParameterType') {
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let rigid = RigidTypeParameterType.new(param1)

      try assert_compatible(rigid, param2)
    }
  }

  t.group('std::compiler::types::RigidTypeParameterType.substitute') do (g) {
    g.test('Substituting a rigid type parameter with a type') {
      let obj_type = ClassType.new('Array')
      let param = TypeParameterType.new('T')
      let rigid = RigidTypeParameterType.new(param)

      obj_type.type_parameters.define(name: param.name, type: param)

      let assigned = NeverType.new
      let instance = obj_type.new_instance(Array.new(assigned))

      try assert_same_object(rigid.substitute(type_scope(instance)), rigid)
    }

    g.test('Substituting a rigid type parameter without a type') {
      let obj_type = ClassType.new('Array')
      let param = TypeParameterType.new('T')
      let rigid = RigidTypeParameterType.new(param)

      try assert_same_object(rigid.substitute(type_scope(obj_type)), rigid)
    }

    g.test('Substituting a rigid type parameter assigned to itself') {
      let obj_type = ClassType.new('Array')
      let param = TypeParameterType.new('T')
      let rigid = RigidTypeParameterType.new(param)

      obj_type.type_parameters.define(name: param.name, type: param)

      let instance = obj_type.new_instance(Array.new(param))

      try assert_same_object(rigid.substitute(type_scope(instance)), rigid)
    }
  }

  t.group('std::compiler::types::TypeParameterBounds.parameters') do (g) {
    g.test('Obtaining the type parameters') {
      let bounds = TypeParameterBounds.new
      let param = TypeParameterType.new('T')
      let requirement = TraitInstance.new(TraitType.new('ToString'))

      try assert_true(bounds.parameters.empty?)

      bounds.define(parameter: param, requirements: Array.new(requirement))

      try assert_equal(bounds.parameters[0], param)
    }
  }

  t.group('std::compiler::types::TypeParameterBounds.parameters') do (g) {
    g.test('Defining a new bound') {
      let bounds = TypeParameterBounds.new
      let param = TypeParameterType.new('T')
      let req = Array.new(TraitInstance.new(TraitType.new('ToString')))

      try assert_true(bounds.define(parameter: param, requirements: req))
      try assert_equal(bounds.parameters.length, 1)
    }

    g.test('Defining a bound for an already bound parameter') {
      let bounds = TypeParameterBounds.new
      let param = TypeParameterType.new('T')
      let req1 = Array.new(TraitInstance.new(TraitType.new('ToString')))
      let req2 = Array.new(TraitInstance.new(TraitType.new('ToInteger')))

      bounds.define(parameter: param, requirements: req1)

      try assert_false(bounds.define(parameter: param, requirements: req2))
      try assert_equal(bounds.parameters.length, 1)
      try assert_same_object(bounds[param], req1)
    }
  }

  t.group('std::compiler::types::TypeParameterBounds.merge') do (g) {
    g.test('Merging two collections of bounds together') {
      let bounds1 = TypeParameterBounds.new
      let bounds2 = TypeParameterBounds.new
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let req1 = Array.new(TraitInstance.new(TraitType.new('ToString')))
      let req2 = Array.new(TraitInstance.new(TraitType.new('ToInteger')))

      bounds1.define(parameter: param1, requirements: req1)
      bounds2.define(parameter: param2, requirements: req2)
      bounds1.merge(bounds2)

      try assert_same_object(bounds1[param1], req1)
      try assert_same_object(bounds1[param2], req2)

      try assert_true(bounds2.get(param1).none?)
      try assert_same_object(bounds2[param2], req2)
    }
  }

  t.group('std::compiler::types::TypeParameterBounds.[]') do (g) {
    g.test('Obtaining the additional requirements of a type parameter') {
      let bounds = TypeParameterBounds.new
      let param = TypeParameterType.new('T')
      let req = Array.new(TraitInstance.new(TraitType.new('ToString')))

      bounds.define(parameter: param, requirements: req)

      try assert_same_object(bounds[param], req)
    }

    g.test('Obtaining the additional requirements of an unbound type parameter') {
      let bounds = TypeParameterBounds.new
      let param = TypeParameterType.new('T')

      try assert_true(bounds.get(param).none?)
    }
  }

  t.group('std::compiler::types::TypeParameterBounds.length') do (g) {
    g.test('Obtaining the number of type parameter bounds') {
      let bounds = TypeParameterBounds.new
      let param = TypeParameterType.new('T')
      let req = Array.new(TraitInstance.new(TraitType.new('ToString')))

      try assert_equal(bounds.length, 0)

      bounds.define(parameter: param, requirements: req)

      try assert_equal(bounds.length, 1)
    }
  }

  t.group('std::compiler::types::BlockLayout.type_parameters') do (g) {
    g.test('Setting and getting the type parameters of a layout') {
      let layout = BlockLayout.new(NeverType.new)
      let param = TypeParameterType.new('T')

      try assert_true(layout.type_parameters.empty?)

      layout.type_parameters.define(name: param.name, type: param)

      try assert_same_object(layout.type_parameters[param.name].type, param)
    }
  }

  t.group('std::compiler::types::BlockLayout.arguments') do (g) {
    g.test('Obtaining the arguments of a layout') {
      let layout = BlockLayout.new(NeverType.new)

      try assert_true(layout.arguments.empty?)

      layout.arguments.define(name: 'a', type: NeverType.new)

      try assert_equal(layout.arguments.length, 1)
    }
  }

  t.group('std::compiler::types::BlockLayout.define_required_argument') do (g) {
    g.test('Defining a required argument') {
      let layout = BlockLayout.new(NeverType.new)
      let type = NeverType.new

      layout.define_required_argument(name: 'a', type: type)

      try assert_equal(layout.required_arguments, 1)
      try assert_same_object(layout.arguments['a'].type, type)
    }
  }

  t.group('std::compiler::types::BlockLayout.define_rest_argument') do (g) {
    g.test('Defining a rest argument') {
      let layout = BlockLayout.new(NeverType.new)
      let builtins = Builtins.new
      let rest_type = builtins.array_type.new_instance(Array.new(NeverType.new))

      layout.define_rest_argument(name: 'a', type: rest_type)

      try assert_equal(layout.required_arguments, 0)
      try assert_same_object(layout.arguments['a'].type, rest_type)
      try assert_true(layout.rest_argument?)
    }
  }

  t.group('std::compiler::types::BlockLayout.throw_type') do (g) {
    g.test('Setting and getting the throw type of a layout') {
      let layout = BlockLayout.new(NeverType.new)
      let type = NeverType.new

      try assert_true(layout.throw_type.none?)

      layout.throw_type = type

      try assert_same_object(layout.throw_type.get, type)
    }
  }

  t.group('std::compiler::types::BlockLayout.increment_throws') do (g) {
    g.test('Incrementing the number of throws') {
      let layout = BlockLayout.new(NeverType.new)

      try assert_false(layout.throws?)

      layout.throws

      try assert_true(layout.throws?)
    }
  }

  t.group('std::compiler::types::BlockLayout.return_type') do (g) {
    g.test('Setting and getting the return type of a layout') {
      let object_type = ClassType.new('A')
      let never = NeverType.new
      let layout = BlockLayout.new(never)

      try assert_same_object(layout.return_type, never)

      layout.return_type = object_type

      try assert_same_object(layout.return_type, object_type)
    }
  }

  t.group('std::compiler::types::BlockLayout.substitute') do (g) {
    g.test('Substituting a Self type used as a throw type') {
      let self_type = ClassType.new('Foo').new_instance
      let layout = BlockLayout
        .new(return_type: NeverType.new, throw_type: Option.some(SelfType.new))

      let new_layout = layout.substitute(type_scope(self_type))

      try assert_same_object(new_layout.throw_type.get, self_type)
    }

    g.test('Substituting a Self type used as a throw type') {
      let self_type = ClassType.new('Foo').new_instance
      let layout = BlockLayout.new(SelfType.new)
      let new_layout = layout.substitute(type_scope(self_type))

      try assert_same_object(new_layout.return_type, self_type)
    }

    g.test('Substituting a Self type used in an argument') {
      let foo_instance = ClassType.new('Foo').new_instance
      let layout = BlockLayout.new(NeverType.new)
      let self_type = SelfType.new

      layout.arguments.define(name: 'a', type: self_type, mutable: True)

      let new_layout = layout.substitute(type_scope(foo_instance))

      try assert_same_object(layout.arguments['a'].type, self_type)
      try assert_same_object(new_layout.arguments['a'].type, foo_instance)
    }

    g.test('The new layout inherits type parameters') {
      let self_type = ClassType.new('Foo').new_instance
      let layout = BlockLayout.new(NeverType.new)
      let param = TypeParameterType.new('T')

      layout.type_parameters.define(name: param.name, type: param)

      let new_layout = layout.substitute(type_scope(self_type))

      try assert_true(new_layout.type_parameters.same_object?(layout.type_parameters))
    }

    g.test('The new layout inherits the number of required arguments') {
      let self_type = ClassType.new('Foo').new_instance
      let layout = BlockLayout.new(NeverType.new)

      layout.define_required_argument(name: 'a', type: ClassType.new('Bar'))

      let new_layout = layout.substitute(type_scope(self_type))

      try assert_equal(new_layout.required_arguments, layout.required_arguments)
    }

    g.test('The new layout inherits the rest argument flag') {
      let self_type = ClassType.new('Foo').new_instance
      let layout = BlockLayout.new(NeverType.new)

      layout.define_rest_argument(name: 'a', type: ClassType.new('Bar'))

      let new_layout = layout.substitute(type_scope(self_type))

      try assert_true(new_layout.rest_argument?)
    }

    g.test('The new layout inherits the throws counter') {
      let self_type = ClassType.new('Foo').new_instance
      let layout = BlockLayout.new(NeverType.new)

      layout.throws

      let new_layout = layout.substitute(type_scope(self_type))

      try assert_equal(new_layout.throws?, layout.throws?)
    }
  }

  t.group('std::compiler::types::BlockType.define_required_argument') do (g) {
    g.test('Defining a required argument') {
      let block = DummyBlock.new
      let type = NeverType.new

      block.define_required_argument(name: 'a', type: type)

      try assert_equal(block.required_arguments, 1)
      try assert_same_object(block.arguments['a'].type, type)
    }
  }

  t.group('std::compiler::types::BlockType.define_rest_argument') do (g) {
    g.test('Defining a rest argument') {
      let block = DummyBlock.new
      let builtins = Builtins.new
      let rest_type = builtins.array_type.new_instance(Array.new(NeverType.new))

      block.define_rest_argument(name: 'a', type: rest_type)

      try assert_equal(block.required_arguments, 0)
      try assert_same_object(block.arguments['a'].type, rest_type)
      try assert_true(block.rest_argument?)
    }
  }

  t.group('std::compiler::types::BlockType.throw_type') do (g) {
    g.test('Setting and getting the throw type of a block') {
      let block = DummyBlock.new
      let type = NeverType.new

      try assert_true(block.throw_type.none?)

      block.throw_type = type

      try assert_same_object(block.throw_type.get, type)
    }
  }

  t.group('std::compiler::types::BlockType.increment_throws') do (g) {
    g.test('Incrementing the number of throws') {
      let block = DummyBlock.new

      try assert_false(block.throws?)

      block.throws

      try assert_true(block.throws?)
    }
  }

  t.group('std::compiler::types::BlockType.return_type') do (g) {
    g.test('Setting and getting the return type of a block') {
      let object_type = ClassType.new('A')
      let block = DummyBlock.new

      try assert_same_object(block.return_type, block.layout.return_type)

      block.return_type = object_type

      try assert_same_object(block.return_type, object_type)
    }
  }

  t.group('std::compiler::types::BlockType.type_parameters') do (g) {
    g.test('Setting and getting the type parameters of a block') {
      let block = DummyBlock.new
      let param = TypeParameterType.new('T')

      try assert_true(block.type_parameters.empty?)

      block.type_parameters.define(name: param.name, type: param)

      try assert_same_object(block.type_parameters[param.name].type, param)
    }
  }

  t.group('std::compiler::types::BlockType.instance_of?') do (g) {
    g.test('Checking if a BlockType is an instance of an ClassType') {
      let builtins = Builtins.new
      let obj_type = ClassType.new('List')
      let block = DummyBlock.new

      try assert_false(block.instance_of?(type: obj_type, builtins: builtins))
      try assert_true(
        block.instance_of?(type: builtins.block_type, builtins: builtins)
      )
    }
  }

  t.group('std::compiler::types::MethodType.static_method?') do (g) {
    g.test('Checking if a method is a static method') {
      let instance_method = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(NeverType.new),
        static_method: False
      )

      let static_method = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(NeverType.new),
        static_method: True
      )

      try assert_false(instance_method.static_method?)
      try assert_true(static_method.static_method?)
    }
  }

  t.group('std::compiler::types::MethodType.type_parameter_bounds') do (g) {
    g.test('Obtaining the type parameter bounds of a method') {
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      let param = TypeParameterType.new('T')
      let req = Array.new(TraitInstance.new(TraitType.new('ToString')))

      method.type_parameters.define(name: param.name, type: param)
      method.type_parameter_bounds.define(parameter: param, requirements: req)

      try assert_equal(method.type_parameter_bounds.length, 1)
    }
  }

  t.group('std::compiler::types::MethodType.name') do (g) {
    g.test('Obtaining the name of a method') {
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      try assert_equal(method.name, 'foo')
    }
  }

  t.group('std::compiler::types::MethodType.type_name') do (g) {
    g.test('Obtaining the type name of a MethodType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_equal(method.type_name, 'def to_string -> Never')
    }

    g.test('Obtaining the type name of a static MethodType') {
      let method = MethodType.new(
        name: 'to_string',
        static_method: True,
        layout: BlockLayout.new(NeverType.new)
      )

      try assert_equal(method.type_name, 'static def to_string -> Never')
    }

    g.test('Obtaining the type name of a MethodType with type parameters') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      method.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      method.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      try assert_equal(method.type_name, 'def to_string!(A, B) -> Never')
    }

    g.test('Obtaining the type name of a MethodType with arguments') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      method.define_required_argument(name: 'a', type: NeverType.new)
      method.define_required_argument(name: 'b', type: TypeParameterType.new('A'))

      try assert_equal(method.type_name, 'def to_string(Never, A) -> Never')
    }

    g.test('Obtaining the type name of a MethodType with a throw type') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      method.throw_type = TypeParameterType.new('A')

      try assert_equal(method.type_name, 'def to_string !! A -> Never')
    }

    g.test('Obtaining the type name of a MethodType with type parameter bounds') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let param = TypeParameterType.new('A')

      method.type_parameters.define(name: 'A', type: param)

      method.type_parameter_bounds.define(
        parameter: param,
        requirements: Array.new(TraitInstance.new(TraitType.new('ToString')))
      )

      try assert_equal(
        method.type_name,
        'def to_string!(A) -> Never when A: ToString'
      )
    }

    g.test('Obtaining the type name of a MethodType with a full type signature') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')

      # This simulates a type parameter defined on the surrounding type.
      let param3 = TypeParameterType.new('C')

      method.type_parameters.define(name: 'A', type: param1)
      method.type_parameters.define(name: 'B', type: param2)

      method.define_required_argument(name: 'a', type: ClassType.new('C'))
      method.define_required_argument(name: 'b', type: NeverType.new)

      method.throw_type = NeverType.new
      method.return_type = NeverType.new

      method.type_parameter_bounds.define(
        parameter: param1,
        requirements: Array.new(TraitInstance.new(TraitType.new('ToString')))
      )

      method.type_parameter_bounds.define(
        parameter: param2,
        requirements: Array.new(
          TraitInstance.new(TraitType.new('ToInteger')),
          TraitInstance.new(TraitType.new('ToFloat'))
        )
      )

      method.type_parameter_bounds.define(
        parameter: param3,
        requirements: Array.new(TraitInstance.new(TraitType.new('ToFoo')))
      )

      try assert_equal(
        method.type_name,
        'def to_string!(A, B)(C, Never) !! Never -> Never' +
          ' when A: ToString, B: ToInteger + ToFloat, C: ToFoo'
      )
    }

    g.test('Obtaining the type name of a MethodType that yields') {
      let builtins = Builtins.new
      let method = MethodType.new(
        name: 'foo',
        layout: BlockLayout.new(builtins.nil_type.new_instance)
      )

      method.yield_type = Option.some(builtins.integer_type.new_instance)

      try assert_equal(method.type_name, 'def foo => Integer')
    }
  }

  t.group('std::compiler::types::MethodType.type_compatible?') do (g) {
    g.test('Comparing a MethodType with an ErrorType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_compatible(method, ErrorType.new)
    }

    g.test('Comparing a MethodType with an AnyType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_compatible(method, AnyType.new)
    }

    g.test('Comparing a MethodType with a NeverType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_not_compatible(method, NeverType.new)
    }

    g.test('Comparing a MethodType with an ClassType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_not_compatible(method, ClassType.new('String'))
    }

    g.test('Comparing a MethodType with an ClassInstance') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let builtins = Builtins.new

      try assert_not_compatible(method, ClassType.new('String'))

      try assert_compatible(
        compare: method,
        with: ClassInstance.new(builtins.block_type),
        builtins: builtins
      )
    }

    g.test('Comparing a MethodType with a TraitType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_not_compatible(method, TraitType.new('ToString'))
    }

    g.test('Comparing a MethodType with a TraitInstance') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let builtins = Builtins.new
      let trait1 = TraitType.new('ToInteger')
      let trait2 = TraitType.new('ToFloat')

      builtins.block_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(
        compare: method,
        with: TraitInstance.new(trait1),
        builtins: builtins
      )

      try assert_not_compatible(
        compare: method,
        with: TraitInstance.new(trait2),
        builtins: builtins
      )
    }

    g.test('Comparing a MethodType with a TypeParameterType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let builtins = Builtins.new
      let trait1 = TraitType.new('ToString')
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType
        .new(name: 'B', required_traits: Array.new(TraitInstance.new(trait1)))

      try assert_compatible(method, param1)
      try assert_not_compatible(compare: method, with: param2, builtins: builtins)

      builtins.block_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(compare: method, with: param2, builtins: builtins)
    }

    g.test('Comparing a MethodType with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let method_type =
          MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

        try assert_compatible(compare: method_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, method_type)
      }
    }

    g.test('Comparing a MethodType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')
        let method_type =
          MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: method_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing a MethodType with a ModuleType') {
      let mod_type = new_module
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_not_compatible(method, mod_type)
    }

    g.test('Comparing a MethodType with a SelfType') {
      let method =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let obj_type = ClassType.new('String')

      # A MethodType can't be used as a type for `self`. When implementing methods
      # or traits for all blocks, `self` will be an instance of the object type
      # `Block`.
      try assert_not_compatible(
        compare: method,
        with: SelfType.new,
        builtins: Builtins.new,
        self_type: obj_type
      )
    }

    g.test('Comparing a simple MethodType with another simple MethodType') {
      let method1 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method2 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method3 =
        MethodType.new(name: 'to_integer', layout: BlockLayout.new(NeverType.new))

      try assert_compatible(method1, method2)
      try assert_not_compatible(method1, method3)
    }

    g.test('Comparing a MethodType with arguments with another MethodType') {
      let method1 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method2 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method3 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method4 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let object_type = ClassType.new('A')

      method1.define_required_argument(name: 'foo', type: object_type)
      method2.define_required_argument(name: 'foo', type: object_type)
      method3.define_required_argument(name: 'foo', type: SelfType.new)
      method4.define_required_argument(name: 'bar', type: object_type)

      try assert_compatible(method1, method2)
      try assert_not_compatible(method1, method3)
      try assert_not_compatible(method1, method4)
    }

    g.test('Comparing a MethodType with a throw type with another MethodType') {
      let method1 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method2 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method3 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let object_type = ClassType.new('A')

      method1.throw_type = object_type
      method2.throw_type = object_type

      try assert_compatible(method1, method2)
      try assert_compatible(method3, method1)
      try assert_not_compatible(method1, method3)
    }

    g.test('Comparing a MethodType with a return type with another MethodType') {
      let object_type = ClassType.new('A')
      let method1 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(object_type))

      let method2 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(object_type))

      let method3 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      try assert_compatible(method1, method2)
      try assert_not_compatible(method1, method3)
    }

    g.test('Comparing a MethodType with type parameters with another MethodType') {
      let method1 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method2 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method3 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let method4 =
        MethodType.new(name: 'to_string', layout: BlockLayout.new(NeverType.new))

      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')

      method1.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      method2.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      method3.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait2))
        )
      )

      method4.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      method4.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait2))
        )
      )

      try assert_compatible(method1, method2)
      try assert_not_compatible(method1, method3)
      try assert_not_compatible(method1, method4)
    }

    g.test('Comparing a MethodType with a ClosureType') {
      try assert_not_compatible(
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new)),
        ClosureType.new(BlockLayout.new(NeverType.new))
      )
    }

    g.test('Comparing a MethodType with a LambdaType') {
      try assert_not_compatible(
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new)),
        LambdaType.new(BlockLayout.new(NeverType.new))
      )
    }

    g.test("Comparing a MethodType that yields with a MethodType that doesn't yield") {
      let builtins = Builtins.new
      let nil_type = builtins.nil_type
      let foo1 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))
      let foo2 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))

      foo1.yield_type = Option.some(builtins.integer_type.new_instance)

      try assert_not_compatible(compare: foo1, with: foo2, builtins: builtins)
    }

    g.test('Comparing a MethodType with a MethodType that yields') {
      let builtins = Builtins.new
      let nil_type = builtins.nil_type
      let foo1 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))
      let foo2 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))

      foo2.yield_type = Option.some(builtins.integer_type.new_instance)

      try assert_not_compatible(compare: foo1, with: foo2, builtins: builtins)
    }

    g.test('Comparing two methods that yield an incompatible type') {
      let builtins = Builtins.new
      let nil_type = builtins.nil_type
      let foo1 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))
      let foo2 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))

      foo1.yield_type = Option.some(builtins.float_type.new_instance)
      foo2.yield_type = Option.some(builtins.integer_type.new_instance)

      try assert_not_compatible(compare: foo1, with: foo2, builtins: builtins)
    }

    g.test('Comparing two methods that yield compatible types') {
      let builtins = Builtins.new
      let nil_type = builtins.nil_type
      let foo1 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))
      let foo2 =
        MethodType.new(name: 'foo', layout: BlockLayout.new(nil_type.new_instance))

      foo1.yield_type = Option.some(builtins.integer_type.new_instance)
      foo2.yield_type = Option.some(builtins.integer_type.new_instance)

      try assert_compatible(compare: foo1, with: foo2, builtins: builtins)
    }
  }

  t.group('std::compiler:types::MethodType.lookup_type') do (g) {
    g.test('Looking up a type by its name') {
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      let param = TypeParameterType.new('T')
      let symbol = method.type_parameters.define(name: param.name, type: param)

      try assert_true(method.lookup_type('Foo').none?)
      try assert_true(method.lookup_type(param.name).get.same_object?(symbol))
    }
  }

  t.group('std::compiler:types::MethodType.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      let param = TypeParameterType.new('T')
      let symbol = method.type_parameters.define(name: param.name, type: param)

      try assert_true(method.lookup_type_parameter('A').none?)
      try assert_true(method.lookup_type_parameter(param.name).get.same_object?(symbol))
    }
  }

  t.group('std::compiler::types::ClosureType.type_name') do (g) {
    g.test('Obtaining the type name of a ClosureType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_equal(block.type_name, 'do -> Never')
    }

    g.test('Obtaining the type name of a ClosureType with type parameters') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      block.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      block.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      try assert_equal(block.type_name, 'do!(A, B) -> Never')
    }

    g.test('Obtaining the type name of a ClosureType with arguments') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      block.define_required_argument(name: 'a', type: NeverType.new)
      block.define_required_argument(name: 'b', type: TypeParameterType.new('A'))

      try assert_equal(block.type_name, 'do(Never, A) -> Never')
    }

    g.test('Obtaining the type name of a ClosureType with a throw type') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      block.throw_type = TypeParameterType.new('A')

      try assert_equal(block.type_name, 'do !! A -> Never')
    }

    g.test('Obtaining the type name of a ClosureType with a full type signature') {
      let block = ClosureType.new(BlockLayout.new(ClassType.new('D')))
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')

      block.type_parameters.define(name: 'A', type: param1)
      block.type_parameters.define(name: 'B', type: param2)

      block.define_required_argument(name: 'a', type: ClassType.new('C'))
      block.define_required_argument(name: 'b', type: NeverType.new)

      block.throw_type = NeverType.new

      try assert_equal(block.type_name, 'do!(A, B)(C, Never) !! Never -> D')
    }
  }

  t.group('std::compiler::types::ClosureType.type_compatible?') do (g) {
    g.test('Comparing a ClosureType with an ErrorType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block, ErrorType.new)
    }

    g.test('Comparing a ClosureType with an AnyType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block, AnyType.new)
    }

    g.test('Comparing a ClosureType with a NeverType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, NeverType.new)
    }

    g.test('Comparing a ClosureType with an ClassType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, ClassType.new('String'))
    }

    g.test('Comparing a ClosureType with an ClassInstance') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))
      let builtins = Builtins.new

      try assert_not_compatible(block, ClassType.new('String'))

      try assert_compatible(
        compare: block,
        with: ClassInstance.new(builtins.block_type),
        builtins: builtins
      )
    }

    g.test('Comparing a ClosureType with a TraitType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, TraitType.new('ToString'))
    }

    g.test('Comparing a ClosureType with a TraitInstance') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))
      let builtins = Builtins.new
      let trait1 = TraitType.new('ToInteger')
      let trait2 = TraitType.new('ToFloat')

      builtins.block_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(
        compare: block,
        with: TraitInstance.new(trait1),
        builtins: builtins
      )

      try assert_not_compatible(
        compare: block,
        with: TraitInstance.new(trait2),
        builtins: builtins
      )
    }

    g.test('Comparing a ClosureType with a TypeParameterType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))
      let builtins = Builtins.new
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType
        .new(name: 'B', required_traits: Array.new(TraitInstance.new(trait1)))

      let param3 = TypeParameterType
        .new(name: 'C', required_traits: Array.new(TraitInstance.new(trait2)))

      try assert_compatible(block, param1)
      try assert_not_compatible(compare: block, with: param2, builtins: builtins)
      try assert_not_compatible(compare: block, with: param3, builtins: builtins)

      builtins.block_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(compare: block, with: param2, builtins: builtins)
    }

    g.test('Comparing a ClosureType with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let block_type = ClosureType.new(BlockLayout.new(NeverType.new))

        try assert_compatible(compare: block_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, block_type)
      }
    }

    g.test('Comparing a ClosureType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let block_type = ClosureType.new(BlockLayout.new(NeverType.new))
        let assigned = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: block_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing a ClosureType with a ModuleType') {
      let mod_type = new_module
      let block = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, mod_type)
    }

    g.test('Comparing a ClosureType with a SelfType') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))
      let obj_type = ClassType.new('String')

      try assert_not_compatible(
        compare: block,
        with: SelfType.new,
        builtins: Builtins.new,
        self_type: obj_type
      )
    }

    g.test('Comparing a ClosureType that does not capture with a LambdaType') {
      try assert_compatible(
        ClosureType.new(BlockLayout.new(NeverType.new)),
        LambdaType.new(BlockLayout.new(NeverType.new))
      )
    }

    g.test('Comparing a ClosureType that captures with a LambdaType') {
      let closure = ClosureType.new(BlockLayout.new(NeverType.new))

      closure.captures

      try assert_not_compatible(
        closure,
        LambdaType.new(BlockLayout.new(NeverType.new))
      )
    }

    g.test('Comparing a simple ClosureType with another simple ClosureType') {
      let block1 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block2 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block3 = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block1, block2)
      try assert_compatible(block1, block3)
    }

    g.test('Comparing a ClosureType with arguments with another ClosureType') {
      let block1 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block2 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block3 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block4 = ClosureType.new(BlockLayout.new(NeverType.new))
      let object_type = ClassType.new('A')

      block1.define_required_argument(name: 'foo', type: object_type)
      block2.define_required_argument(name: 'foo', type: object_type)
      block3.define_required_argument(name: 'foo', type: SelfType.new)
      block4.define_required_argument(name: 'bar', type: object_type)

      try assert_compatible(block1, block2)
      try assert_not_compatible(block1, block3)
      try assert_not_compatible(block1, block4)
    }

    g.test('Comparing a ClosureType with a throw type with another ClosureType') {
      let block1 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block2 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block3 = ClosureType.new(BlockLayout.new(NeverType.new))
      let object_type = ClassType.new('A')

      block1.throw_type = object_type
      block2.throw_type = object_type

      try assert_compatible(block1, block2)
      try assert_compatible(block3, block1)
      try assert_not_compatible(block1, block3)
    }

    g.test('Comparing a ClosureType with a return type with another ClosureType') {
      let object_type = ClassType.new('A')
      let block1 = ClosureType.new(BlockLayout.new(object_type.new_instance))
      let block2 = ClosureType.new(BlockLayout.new(object_type.new_instance))
      let block3 = ClosureType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block1, block2)
      try assert_not_compatible(block1, block3)
    }

    g.test('Comparing a ClosureType with type parameters with another ClosureType') {
      let block1 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block2 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block3 = ClosureType.new(BlockLayout.new(NeverType.new))
      let block4 = ClosureType.new(BlockLayout.new(NeverType.new))

      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')

      block1.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      block2.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      block3.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait2))
        )
      )

      block4.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      block4.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait2))
        )
      )

      try assert_compatible(block1, block2)
      try assert_not_compatible(block1, block3)
      try assert_not_compatible(block1, block4)
    }

    g.test('Comparing two ClosureType objects that return a type parameter') {
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let block1 = ClosureType.new(BlockLayout.new(param1))
      let block2 = ClosureType.new(BlockLayout.new(param2))

      try assert_compatible(block1, block2)
    }
  }

  t.group('std::compiler:types::ClosureType.lookup_type') do (g) {
    g.test('Looking up a type by its name') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))
      let param = TypeParameterType.new('T')
      let symbol = block.type_parameters.define(name: param.name, type: param)

      try assert_true(block.lookup_type('Foo').none?)
      try assert_true(block.lookup_type(param.name).get.same_object?(symbol))
    }
  }

  t.group('std::compiler:types::ClosureType.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let block = ClosureType.new(BlockLayout.new(NeverType.new))
      let param = TypeParameterType.new('T')
      let symbol = block.type_parameters.define(name: param.name, type: param)

      try assert_true(block.lookup_type_parameter('A').none?)
      try assert_true(block.lookup_type_parameter(param.name).get.same_object?(symbol))
    }
  }

  t.group('std::compiler::types::ClosureType.substitute') do (g) {
    g.test('Substituting a closure') {
      let block =
        ClosureType.new(layout: BlockLayout.new(SelfType.new), captures: True)

      let self_type = ClassType.new('Foo').new_instance
      let new_block = block.substitute(type_scope(self_type))

      try assert_same_object(new_block.layout.return_type, self_type)
      try assert_true(new_block.captures?)
    }
  }

  t.group('std::compiler::types::LambdaType.type_name') do (g) {
    g.test('Obtaining the type name of a LambdaType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_equal(block.type_name, 'lambda -> Never')
    }

    g.test('Obtaining the type name of a LambdaType with type parameters') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      block.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      block.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      try assert_equal(block.type_name, 'lambda!(A, B) -> Never')
    }

    g.test('Obtaining the type name of a LambdaType with arguments') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      block.define_required_argument(name: 'a', type: NeverType.new)
      block.define_required_argument(name: 'b', type: TypeParameterType.new('A'))

      try assert_equal(block.type_name, 'lambda(Never, A) -> Never')
    }

    g.test('Obtaining the type name of a LambdaType with a throw type') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      block.throw_type = TypeParameterType.new('A')

      try assert_equal(block.type_name, 'lambda !! A -> Never')
    }

    g.test('Obtaining the type name of a LambdaType with a full type signature') {
      let block = LambdaType.new(BlockLayout.new(ClassType.new('D')))
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')

      block.type_parameters.define(name: 'A', type: param1)
      block.type_parameters.define(name: 'B', type: param2)

      block.define_required_argument(name: 'a', type: ClassType.new('C'))
      block.define_required_argument(name: 'b', type: NeverType.new)

      block.throw_type = NeverType.new

      try assert_equal(block.type_name, 'lambda!(A, B)(C, Never) !! Never -> D')
    }
  }

  t.group('std::compiler::types::LambdaType.type_compatible?') do (g) {
    g.test('Comparing a LambdaType with an ErrorType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block, ErrorType.new)
    }

    g.test('Comparing a LambdaType with an AnyType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block, AnyType.new)
    }

    g.test('Comparing a LambdaType with a NeverType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, NeverType.new)
    }

    g.test('Comparing a LambdaType with an ClassType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, ClassType.new('String'))
    }

    g.test('Comparing a LambdaType with an ClassInstance') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))
      let builtins = Builtins.new

      try assert_not_compatible(block, ClassType.new('String'))

      try assert_compatible(
        compare: block,
        with: ClassInstance.new(builtins.block_type),
        builtins: builtins
      )
    }

    g.test('Comparing a LambdaType with a TraitType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, TraitType.new('ToString'))
    }

    g.test('Comparing a LambdaType with a TraitInstance') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))
      let builtins = Builtins.new
      let trait1 = TraitType.new('ToInteger')
      let trait2 = TraitType.new('ToFloat')

      builtins.block_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(
        compare: block,
        with: TraitInstance.new(trait1),
        builtins: builtins
      )

      try assert_not_compatible(
        compare: block,
        with: TraitInstance.new(trait2),
        builtins: builtins
      )
    }

    g.test('Comparing a LambdaType with a TypeParameterType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))
      let builtins = Builtins.new
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType
        .new(name: 'B', required_traits: Array.new(TraitInstance.new(trait1)))

      let param3 = TypeParameterType
        .new(name: 'C', required_traits: Array.new(TraitInstance.new(trait2)))

      try assert_compatible(block, param1)
      try assert_not_compatible(compare: block, with: param2, builtins: builtins)
      try assert_not_compatible(compare: block, with: param3, builtins: builtins)

      builtins.block_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(compare: block, with: param2, builtins: builtins)
    }

    g.test('Comparing a LambdaType with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let block_type = LambdaType.new(BlockLayout.new(NeverType.new))

        try assert_compatible(compare: block_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, block_type)
      }
    }

    g.test('Comparing a LambdaType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let block_type = LambdaType.new(BlockLayout.new(NeverType.new))
        let assigned = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: block_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing a LambdaType with a ModuleType') {
      let mod_type = new_module
      let block = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_not_compatible(block, mod_type)
    }

    g.test('Comparing a LambdaType with a SelfType') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))
      let obj_type = ClassType.new('String')

      try assert_not_compatible(
        compare: block,
        with: SelfType.new,
        builtins: Builtins.new,
        self_type: obj_type
      )
    }

    g.test('Comparing a LambdaType with a ClosureType') {
      try assert_compatible(
        LambdaType.new(BlockLayout.new(NeverType.new)),
        ClosureType.new(BlockLayout.new(NeverType.new))
      )
    }

    g.test('Comparing a simple LambdaType with another simple LambdaType') {
      let block1 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block2 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block3 = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block1, block2)
      try assert_compatible(block1, block3)
    }

    g.test('Comparing a LambdaType with arguments with another LambdaType') {
      let block1 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block2 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block3 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block4 = LambdaType.new(BlockLayout.new(NeverType.new))
      let object_type = ClassType.new('A')

      block1.define_required_argument(name: 'foo', type: object_type)
      block2.define_required_argument(name: 'foo', type: object_type)
      block3.define_required_argument(name: 'foo', type: SelfType.new)
      block4.define_required_argument(name: 'bar', type: object_type)

      try assert_compatible(block1, block2)
      try assert_not_compatible(block1, block3)
      try assert_not_compatible(block1, block4)
    }

    g.test('Comparing a LambdaType with a throw type with another LambdaType') {
      let block1 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block2 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block3 = LambdaType.new(BlockLayout.new(NeverType.new))
      let object_type = ClassType.new('A')

      block1.throw_type = object_type
      block2.throw_type = object_type

      try assert_compatible(block1, block2)
      try assert_compatible(block3, block1)
      try assert_not_compatible(block1, block3)
    }

    g.test('Comparing a LambdaType with a return type with another LambdaType') {
      let object_type = ClassType.new('A')
      let block1 = LambdaType.new(BlockLayout.new(object_type.new_instance))
      let block2 = LambdaType.new(BlockLayout.new(object_type.new_instance))
      let block3 = LambdaType.new(BlockLayout.new(NeverType.new))

      try assert_compatible(block1, block2)
      try assert_not_compatible(block1, block3)
    }

    g.test('Comparing a LambdaType with type parameters with another LambdaType') {
      let block1 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block2 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block3 = LambdaType.new(BlockLayout.new(NeverType.new))
      let block4 = LambdaType.new(BlockLayout.new(NeverType.new))

      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')

      block1.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      block2.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      block3.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait2))
        )
      )

      block4.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait1))
        )
      )

      block4.type_parameters.define(
        name: 'T',
        type: TypeParameterType.new(
          name: 'T',
          required_traits: Array.new(TraitInstance.new(trait2))
        )
      )

      try assert_compatible(block1, block2)
      try assert_not_compatible(block1, block3)
      try assert_not_compatible(block1, block4)
    }

    g.test('Comparing two LambdaType objects that return a type parameter') {
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let block1 = LambdaType.new(BlockLayout.new(param1))
      let block2 = LambdaType.new(BlockLayout.new(param2))

      try assert_compatible(block1, block2)
    }
  }

  t.group('std::compiler:types::LambdaType.lookup_type') do (g) {
    g.test('Looking up a type by its name') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))
      let param = TypeParameterType.new('T')
      let symbol = block.type_parameters.define(name: param.name, type: param)

      try assert_true(block.lookup_type('Foo').none?)
      try assert_true(block.lookup_type(param.name).get.same_object?(symbol))
    }
  }

  t.group('std::compiler:types::LambdaType.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let block = LambdaType.new(BlockLayout.new(NeverType.new))
      let param = TypeParameterType.new('T')
      let symbol = block.type_parameters.define(name: param.name, type: param)

      try assert_true(block.lookup_type_parameter('A').none?)
      try assert_true(block.lookup_type_parameter(param.name).get.same_object?(symbol))
    }
  }

  t.group('std::compiler::types::LambdaType.substitute') do (g) {
    g.test('Substituting a lambda') {
      let block = LambdaType.new(BlockLayout.new(SelfType.new))

      let self_type = ClassType.new('Foo').new_instance
      let new_block = block.substitute(type_scope(self_type))

      try assert_same_object(new_block.layout.return_type, self_type)
    }
  }

  t.group('std::compiler::types::TraitType.name') do (g) {
    g.test('Obtaining the name of a trait') {
      try assert_equal(TraitType.new('Foo').name, 'Foo')
    }
  }

  t.group('std::compiler::types::TraitType.type_parameters') do (g) {
    g.test('Obtaining the type parameters of a trait') {
      let type = TraitType.new('Foo')
      let param = TypeParameterType.new('T')

      try assert_true(type.type_parameters.empty?)

      type.type_parameters.define(name: param.name, type: param)

      try assert_equal(type.type_parameters.length, 1)
    }
  }

  t.group('std::compiler::types::TraitType.default_methods') do (g) {
    g.test('Obtaining the default methods of a trait') {
      let type = TraitType.new('Foo')
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      try assert_true(type.default_methods.empty?)

      type.default_methods.define(name: method.name, type: method)

      try assert_equal(type.default_methods.length, 1)
    }
  }

  t.group('std::compiler::types::TraitType.required_methods') do (g) {
    g.test('Obtaining the required methods of a trait') {
      let type = TraitType.new('Foo')
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      try assert_true(type.required_methods.empty?)

      type.required_methods.define(name: method.name, type: method)

      try assert_equal(type.required_methods.length, 1)
    }
  }

  t.group('std::compiler::types::TraitType.required_traits') do (g) {
    g.test('Obtaining the required traits of a trait') {
      let type1 = TraitType.new('Foo')
      let type2 = TraitType.new('Bar')

      try assert_true(type1.required_traits.empty?)

      type1.required_traits.push(TraitInstance.new(type2))

      try assert_equal(type1.required_traits.length, 1)
    }
  }

  t.group('std::compiler::types::TraitType.type_name') do (g) {
    g.test('Obtaining the type name of a regular TraitType') {
      try assert_equal(TraitType.new('ToString').type_name, 'ToString')
    }

    g.test('Obtaining the type name of a TraitType with one type parameter') {
      let type = TraitType.new('Add')

      type.type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(type.type_name, 'Add!(T)')
    }

    g.test('Obtaining the type name of a TraitType with multiple type parameters') {
      let type = TraitType.new('Add')

      type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      type.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      try assert_equal(type.type_name, 'Add!(A, B)')
    }
  }

  t.group('std::compiler::types::TraitType.lookup_type') do (g) {
    g.test('Looking up a type by its name') {
      let type = TraitType.new('Add')
      let param = TypeParameterType.new('A')

      type.type_parameters.define(name: 'A', type: param)

      try assert_equal(type.lookup_type('A').get.type, param)
      try assert_true(type.lookup_type('B').none?)
    }
  }

  t.group('std::compiler::types::TraitType.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let type = TraitType.new('Add')
      let param = TypeParameterType.new('A')

      type.type_parameters.define(name: 'A', type: param)

      try assert_equal(type.lookup_type_parameter('A').get.type, param)
      try assert_true(type.lookup_type_parameter('B').none?)
    }
  }

  t.group('std::compiler::types::TraitType.initialise?') do (g) {
    g.test('Checking if a TraitType needs to be initialised') {
      let trait1 = TraitType.new('Foo')
      let trait2 = TraitType.new('Bar')

      trait2.type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_false(trait1.initialise?)
      try assert_true(trait2.initialise?)
    }
  }

  t.group('std::compiler::types::TraitType.number_of_type_parameters') do (g) {
    g.test('Obtaining the number of type parameters') {
      let trait1 = TraitType.new('Foo')
      let trait2 = TraitType.new('Bar')

      trait2.type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(trait1.number_of_type_parameters, 0)
      try assert_equal(trait2.number_of_type_parameters, 1)
    }
  }

  t.group('std::compiler::types::TraitType.new_instance') do (g) {
    g.test('Creating a new instance of a TraitType') {
      let trait_type = TraitType.new('Foo')
      let instance = trait_type.new_instance

      try assert_equal(instance.instance_of, trait_type)
      try assert_true(instance.type_parameter_types.empty?)
    }

    g.test('Creating a new instance of a generic TraitType') {
      let trait_type = TraitType.new('Foo')

      trait_type
        .type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      let instance = trait_type.new_instance(Array.new(NeverType.new))

      try assert_equal(instance.type_parameter_types.length, 1)
    }
  }

  t.group('std::compiler::types::TraitType.type_compatible?') do (g) {
    g.test('Comparing a TraitType with an ErrorType') {
      try assert_compatible(TraitType.new('ToString'), ErrorType.new)
    }

    g.test('Comparing a TraitType with an AnyType') {
      try assert_compatible(TraitType.new('ToString'), AnyType.new)
    }

    g.test('Comparing a TraitType with a NeverType') {
      try assert_not_compatible(TraitType.new('ToString'), NeverType.new)
    }

    g.test('Comparing a TraitType with an ClassType') {
      try assert_not_compatible(TraitType.new('ToString'), ClassType.new('String'))
    }

    g.test('Comparing a TraitType with an ClassInstance') {
      let trait_type = TraitType.new('ToString')

      try assert_not_compatible(
        trait_type,
        ClassInstance.new(ClassType.new('String'))
      )
    }

    g.test('Comparing a TraitType with a TraitType') {
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')

      try assert_compatible(trait1, trait1)
      try assert_not_compatible(trait1, trait2)
    }

    g.test('Comparing a TraitType with a TraitInstance') {
      let trait_type = TraitType.new('ToString')

      try assert_not_compatible(trait_type, TraitInstance.new(trait_type))
    }

    g.test('Comparing a TraitType with an empty TypeParameterType') {
      try assert_compatible(TraitType.new('ToString'), TypeParameterType.new('T'))
    }

    g.test('Comparing a TraitType with a TypeParameterType with required traits') {
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')
      let param = TypeParameterType
        .new(name: 'A', required_traits: Array.new(TraitInstance.new(trait2)))

      try assert_not_compatible(compare: trait1, with: param)
    }

    g.test('Comparing a TraitType with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let trait_type = TraitType.new('ToFoo')

        try assert_compatible(compare: trait_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, trait_type)
      }
    }

    g.test('Comparing a TraitType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')
        let trait_type = TraitType.new('ToFoo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: trait_type, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing an TraitType with a SelfType') {
      let trait_type = ClassType.new('ToString')
      let self_type = SelfType.new

      # A ToString can't be passed to an instance of ToString.
      try assert_not_compatible(trait_type, self_type)
    }
  }

  t.group('std::compiler::types::TraitInstance.instance_of') do (g) {
    g.test('Obtaining the type a TraitInstance is an instance of') {
      let trait_type = TraitType.new('Foo')
      let trait_instance = TraitInstance.new(trait_type)

      try assert_equal(trait_instance.instance_of, trait_type)
    }
  }

  t.group('std::compiler::types::TraitInstance.type_parameter_types') do (g) {
    g.test('Obtaining the type parameter types') {
      let trait_type = TraitType.new('Foo')

      trait_type
        .type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      let trait_instance = trait_type.new_instance(Array.new(NeverType.new))

      try assert_equal(trait_instance.type_parameter_types.length, 1)
    }
  }

  t.group('std::compiler::types::TraitInstance.type_name') do (g) {
    g.test('Obtaining the type name of a regular TraitInstance') {
      let instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_equal(instance.type_name, 'ToString')
    }

    g.test('Obtaining the type name of a TraitInstance with one type parameter') {
      let type = TraitType.new('Add')
      let instance = TraitInstance.new(type)

      type.type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(instance.type_name, 'Add!(T)')
    }

    g.test('Obtaining the type name of a TraitInstance with multiple type parameters') {
      let type = TraitType.new('Add')
      let instance = TraitInstance.new(type)

      type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      type.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      try assert_equal(instance.type_name, 'Add!(A, B)')
    }

    g.test('Obtaining the type name of a TraitInstance with type arguments') {
      let type = TraitType.new('Add')
      let instance = TraitInstance.new(type)
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')

      type.type_parameters.define(name: 'A', type: param1)
      type.type_parameters.define(name: 'B', type: param2)

      instance.type_parameter_types[param1] = NeverType.new
      instance.type_parameter_types[param2] = ClassType.new('A')

      try assert_equal(instance.type_name, 'Add!(Never, A)')
    }
  }

  t.group('std::compiler::types::TraitInstance.number_of_type_parameters') do (g) {
    g.test('Obtaining the number of type parameters') {
      let trait1 = TraitType.new('A')
      let trait2 = TraitType.new('B')

      trait2
        .type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(trait1.new_instance.number_of_type_parameters, 0)
      try assert_equal(trait2.new_instance.number_of_type_parameters, 1)
    }
  }

  t.group('std::compiler::types::TraitInstance.lookup_method') do (g) {
    g.test('Looking up a default method') {
      let trait_type = TraitType.new('A')
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      trait_type.default_methods.define(name: method.name, type: method)

      let instance = trait_type.new_instance

      try assert_same_object(instance.lookup_method(method.name).get.type, method)
    }

    g.test('Looking up a required method') {
      let trait_type = TraitType.new('A')
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      trait_type.required_methods.define(name: method.name, type: method)

      let instance = trait_type.new_instance

      try assert_same_object(instance.lookup_method(method.name).get.type, method)
    }

    g.test('Looking up an undefined method') {
      let trait_type = TraitType.new('A')
      let instance = trait_type.new_instance

      try assert_true(instance.lookup_method('foo').none?)
    }

    g.test('Looking up a default method from a required trait') {
      let trait1 = TraitType.new('A')
      let trait2 =
        TraitType.new(name: 'B', required_traits: Array.new(trait1.new_instance))
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      trait1.default_methods.define(name: method.name, type: method)

      let instance = trait2.new_instance

      try assert_same_object(instance.lookup_method(method.name).get.type, method)
    }

    g.test('Looking up a required method from a required trait') {
      let trait1 = TraitType.new('A')
      let trait2 =
        TraitType.new(name: 'B', required_traits: Array.new(trait1.new_instance))
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      trait1.required_methods.define(name: method.name, type: method)

      let instance = trait2.new_instance

      try assert_same_object(instance.lookup_method(method.name).get.type, method)
    }

    g.test('Looking up a default method from a default trait') {
      let trait1 = TraitType.new('A')
      let trait2 =
        TraitType.new(name: 'B', default_traits: Array.new(trait1.new_instance))
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      trait1.default_methods.define(name: method.name, type: method)

      let instance = trait2.new_instance

      try assert_same_object(instance.lookup_method(method.name).get.type, method)
    }

    g.test('Looking up a required method from a default trait') {
      let trait1 = TraitType.new('A')
      let trait2 =
        TraitType.new(name: 'B', default_traits: Array.new(trait1.new_instance))
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      trait1.required_methods.define(name: method.name, type: method)

      let instance = trait2.new_instance

      try assert_same_object(instance.lookup_method(method.name).get.type, method)
    }
  }

  t.group('std::compiler::types::TraitInstance.lookup_type') do (g) {
    g.test('Looking up a type by its name') {
      let trait_type = TraitType.new('B')

      trait_type
        .type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      let instance = trait_type.new_instance

      try assert_same_object(
        instance.lookup_type('T').get,
        trait_type.lookup_type('T').get
      )
    }
  }

  t.group('std::compiler::types::TraitInstance.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let trait_type = TraitType.new('B')

      trait_type
        .type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      let instance = trait_type.new_instance

      try assert_same_object(
        instance.lookup_type_parameter('T').get,
        trait_type.lookup_type_parameter('T').get
      )
    }
  }

  t.group('std::compiler::types::TraitInstance.lookup_type_parameter_type') do (g) {
    g.test('Looking up a type parameter type') {
      let trait_type = TraitType.new('B')
      let param = TypeParameterType.new('T')
      let object_type = ClassType.new('A')

      trait_type.type_parameters.define(name: param.name, type: param)

      let instance1 = trait_type.new_instance
      let instance2 = trait_type.new_instance(Array.new(object_type))

      try assert_true(instance1.lookup_type_parameter_type(param).none?)
      try assert_same_object(
        instance2.lookup_type_parameter_type(param).get,
        object_type
      )
    }
  }

  t.group('std::compiler::types::TraitInstance.type_compatible?') do (g) {
    g.test('Comparing a TraitInstance with an ErrorType') {
      let instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_compatible(instance, ErrorType.new)
    }

    g.test('Comparing a TraitInstance with an AnyType') {
      let instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_compatible(instance, AnyType.new)
    }

    g.test('Comparing a TraitInstance with a NeverType') {
      let instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_not_compatible(instance, NeverType.new)
    }

    g.test('Comparing a TraitInstance with an ClassType') {
      let instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_not_compatible(instance, ClassType.new('String'))
    }

    g.test('Comparing a TraitInstance with another TraitInstance') {
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType
        .new(name: 'Foo', required_traits: Array.new(TraitInstance.new(trait1)))

      let instance1 = TraitInstance.new(trait1)
      let instance2 = TraitInstance.new(trait1)
      let instance3 = TraitInstance.new(TraitType.new('ToInteger'))
      let instance4 = TraitInstance.new(trait2)

      try assert_compatible(instance1, instance2)
      try assert_compatible(instance4, instance1)
      try assert_not_compatible(instance1, instance3)
      try assert_not_compatible(instance1, instance4)
    }

    g.test('Comparing a generic TraitInstance with another TraitInstance') {
      let trait_type = TraitType.new('ToPair')
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let object_type = ClassType.new('A')

      trait_type.type_parameters.define(name: 'A', type: param1)
      trait_type.type_parameters.define(name: 'B', type: param2)

      let instance1 = TraitInstance.new(trait_type)
      let instance2 = TraitInstance.new(trait_type)
      let instance3 = TraitInstance.new(trait_type)
      let instance4 = TraitInstance.new(trait_type)

      instance1.type_parameter_types[param1] = object_type
      instance1.type_parameter_types[param2] = object_type

      instance2.type_parameter_types[param1] = object_type
      instance2.type_parameter_types[param2] = object_type

      instance3.type_parameter_types[param1] = NeverType.new
      instance3.type_parameter_types[param2] = NeverType.new

      try assert_compatible(instance1, instance2)
      try assert_not_compatible(instance2, instance3)
      try assert_not_compatible(instance2, instance4)
    }

    g.test('Comparing a TraitInstance with a TypeParameterType') {
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')

      let param1 = TypeParameterType.new('T')
      let param2 = TypeParameterType
        .new(name: 'A', required_traits: Array.new(TraitInstance.new(trait1)))

      let param3 = TypeParameterType
        .new(name: 'B', required_traits: Array.new(TraitInstance.new(trait2)))

      let param4 = TypeParameterType.new(
        name: 'C',
        required_traits: Array.new(
          TraitInstance.new(trait1), TraitInstance.new(trait2)
        )
      )

      try assert_compatible(TraitInstance.new(trait1), param1)
      try assert_compatible(TraitInstance.new(trait1), param2)

      try assert_not_compatible(TraitInstance.new(trait1), param3)

      # Param C requires both ToString and ToInteger, so ToString and ToInteger
      # individually are not compatible with C.
      try assert_not_compatible(TraitInstance.new(trait1), param4)
      try assert_not_compatible(TraitInstance.new(trait2), param4)
    }

    g.test('Comparing a TraitInstance with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let compare = TraitType.new('ToFoo').new_instance

        try assert_compatible(compare: compare, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, compare)
      }
    }

    g.test('Comparing a TraitInstance with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')
        let compare = TraitType.new('ToFoo').new_instance

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: compare, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing a TraitInstance with a ModuleType') {
      let mod_type = new_module
      let instance = TraitInstance.new(TraitType.new('ToString'))

      try assert_not_compatible(instance, mod_type)
    }

    g.test('Comparing a TraitInstance with a SelfType') {
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')
      let builtins = Builtins.new

      try assert_compatible(
        compare: TraitInstance.new(trait1),
        with: SelfType.new,
        builtins: builtins,
        self_type: TraitInstance.new(trait1)
      )

      try assert_not_compatible(
        compare: TraitInstance.new(trait1),
        with: SelfType.new,
        builtins: builtins,
        self_type: TraitInstance.new(trait2)
      )
    }

    g.test('Comparing a TraitInstance with an ClassInstance') {
      let trait_type = TraitType.new('ToString')
      let obj_type = ClassType.new('String')

      try assert_not_compatible(
        TraitInstance.new(trait_type),
        ClassInstance.new(obj_type)
      )
    }

    g.test('Comparing a TraitInstance with a default trait') {
      let trait1 = TraitType.new('Object')
      let trait2 = TraitType
        .new(name: 'ToString', default_traits: Array.new(trait1.new_instance))

      try assert_compatible(trait2.new_instance, trait1.new_instance)
    }
  }

  t.group('std::compiler::types::TraitImplementation.type') do (g) {
    g.test('Obtaining the type that is implemented') {
      let trait_type = TraitType.new('ToString')
      let trait_instance = trait_type.new_instance
      let implementation = TraitImplementation.new(trait_instance)

      try assert_same_object(implementation.type, trait_instance)
    }
  }

  t.group('std::compiler::type::TraitImplementation.bounds') do (g) {
    g.test('Obtaining the bounds of a trait implementation') {
      let trait_type = TraitType.new('ToString')
      let trait_instance = trait_type.new_instance
      let implementation = TraitImplementation.new(trait_instance)

      try assert_true(implementation.bounds.empty?)
    }
  }

  t.group('std::compiler::types::ClassType.name') do (g) {
    g.test('Obtaining the name of an object') {
      try assert_equal(ClassType.new('A').name, 'A')
    }
  }

  t.group('std::compiler::types::ClassType.attributes') do (g) {
    g.test('Obtaining the attributes of an object') {
      let object_type = ClassType.new('A')

      try assert_true(object_type.attributes.empty?)
    }
  }

  t.group('std::compiler::types::ClassType.static_methods') do (g) {
    g.test('Obtaining the static methods of an object') {
      let object_type = ClassType.new('A')

      try assert_true(object_type.static_methods.empty?)
    }
  }

  t.group('std::compiler::types::ClassType.instance_methods') do (g) {
    g.test('Obtaining the instance methods of an object') {
      let object_type = ClassType.new('A')

      try assert_true(object_type.instance_methods.empty?)
    }
  }

  t.group('std::compiler::types::ClassType.type_parameters') do (g) {
    g.test('Obtaining the type parameters of an object') {
      let object_type = ClassType.new('A')

      try assert_true(object_type.type_parameters.empty?)
    }
  }

  t.group('std::compiler::types::ClassType.implemented_traits') do (g) {
    g.test('Obtaining the implemented traits of an object') {
      let object_type = ClassType.new('A')

      try assert_true(object_type.implemented_traits.empty?)
    }
  }

  t.group('std::compiler::types::ClassType.add_trait_implementation') do (g) {
    g.test('Adding a trait implementation to an object') {
      let object_type = ClassType.new('A')
      let trait_type = TraitType.new('A')
      let implementation = TraitImplementation.new(trait_type.new_instance)

      object_type.add_trait_implementation(implementation)

      try assert_equal(object_type.implemented_traits.length, 1)
    }
  }

  t.group('std::compiler::types::ClassType.remove_trait_implementation') do (g) {
    g.test('Removing a trait implementation from an object') {
      let object_type = ClassType.new('A')
      let trait_type = TraitType.new('A')
      let implementation = TraitImplementation.new(trait_type.new_instance)

      object_type.add_trait_implementation(implementation)
      object_type.remove_trait_implementation(implementation)

      try assert_true(object_type.implemented_traits.empty?)
    }
  }

  t.group('std::compiler::types::ClassType.define_attribute') do (g) {
    g.test('Defining an attribute') {
      let object_type = ClassType.new('A')
      let type = NeverType.new

      object_type.define_attribute(name: '@a', type: type)

      let attr = object_type.attributes['@a'].type

      try assert_same_object(attr.public_type, type)
      try assert_same_object(attr.internal_type, type)
    }
  }

  t.group('std::compiler::types::ClassType.implements_trait?') do (g) {
    g.test('Checking if an object implements a trait') {
      let object_type = ClassType.new('A')
      let trait_type = TraitType.new('A')
      let trait_instance = trait_type.new_instance
      let builtins = Builtins.new
      let scope = TypeScope.new(module: new_module, self_type: object_type)

      try assert_false(
        object_type
          .implements_trait?(type: trait_instance, builtins: builtins, scope: scope)
      )

      object_type
        .add_trait_implementation(TraitImplementation.new(trait_instance))

      try assert_true(
        object_type
          .implements_trait?(type: trait_instance, builtins: builtins, scope: scope)
      )
    }
  }

  t.group('std::compiler::types::ClassType.type_name') do (g) {
    g.test('Obtaining the type name of a regular ClassType') {
      try assert_equal(ClassType.new('String').type_name, 'String')
    }

    g.test('Obtaining the type name of an ClassType with one type parameter') {
      let type = ClassType.new('Array')

      type.type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(type.type_name, 'Array!(T)')
    }

    g.test('Obtaining the type name of an ClassType with multiple type parameters') {
      let type = ClassType.new('Array')

      type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      type.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      try assert_equal(type.type_name, 'Array!(A, B)')
    }
  }

  t.group('std::compiler::types::ClassType.lookup_type') do (g) {
    g.test('Looking up a type by its name') {
      let object_type = ClassType.new('A')
      let param = TypeParameterType.new('T')

      object_type.type_parameters.define(name: param.name, type: param)

      try assert_equal(object_type.lookup_type(param.name).get.type, param)
      try assert_true(object_type.lookup_type('B').none?)
    }
  }

  t.group('std::compiler::types::ClassType.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let object_type = ClassType.new('A')
      let param = TypeParameterType.new('T')

      object_type.type_parameters.define(name: param.name, type: param)

      try assert_equal(object_type.lookup_type_parameter(param.name).get.type, param)
      try assert_true(object_type.lookup_type_parameter('B').none?)
    }
  }

  t.group('std::compiler::types::ClassType.lookup_method') do (g) {
    g.test('Looking up a static method by its name') {
      let object_type = ClassType.new('A')
      let a_method =
        MethodType.new(name: 'a', layout: BlockLayout.new(NeverType.new))

      let b_method =
        MethodType.new(name: 'b', layout: BlockLayout.new(NeverType.new))

      object_type.static_methods.define(name: 'a', type: a_method)
      object_type.instance_methods.define(name: 'b', type: b_method)

      try assert_same_object(object_type.lookup_method('a').get.type, a_method)
      try assert_true(object_type.lookup_method('b').none?)
    }
  }

  t.group('std::compiler::types::ClassType.initialise?') do (g) {
    g.test('Checking if an object needs to be initialised with type arguments') {
      let object_type = ClassType.new('A')

      try assert_false(object_type.initialise?)

      object_type
        .type_parameters
        .define(name: 'T', type: TypeParameterType.new('T'))

      try assert_true(object_type.initialise?)
    }
  }

  t.group('std::compiler::types::ClassType.number_of_type_parameters') do (g) {
    g.test('Obtaining the number of type parameters') {
      let object_type = ClassType.new('A')

      try assert_equal(object_type.number_of_type_parameters, 0)

      object_type
        .type_parameters
        .define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(object_type.number_of_type_parameters, 1)
    }
  }

  t.group('std::compiler::types::ClassType.new_instance') do (g) {
    g.test('Creating a new instance of an object') {
      let object_type = ClassType.new('A')
      let param = TypeParameterType.new('T')
      let type = NeverType.new

      object_type.type_parameters.define(name: param.name, type: param)

      let instance1 = object_type.new_instance
      let instance2 = object_type.new_instance(Array.new(type))

      try assert_true(instance1.type_parameter_types.empty?)
      try assert_same_object(instance2.type_parameter_types[param], type)
    }
  }

  t.group('std::compiler::types::ClassType.type_compatible?') do (g) {
    g.test('Comparing an ClassType with an ErrorType') {
      let obj_type = ClassType.new('String')

      try assert_compatible(obj_type, ErrorType.new)
    }

    g.test('Comparing an ClassType with an AnyType') {
      let obj_type = ClassType.new('String')

      try assert_compatible(obj_type, AnyType.new)
    }

    g.test('Comparing an ClassType with a NeverType') {
      let obj_type = ClassType.new('String')

      try assert_not_compatible(obj_type, NeverType.new)
    }

    g.test('Comparing an ClassType with another ClassType') {
      let obj1 = ClassType.new('String')
      let obj2 = ClassType.new('Integer')

      try assert_not_compatible(obj1, obj2)
      try assert_compatible(obj1, obj1)
    }

    g.test('Comparing an ClassType with an ClassInstance') {
      let obj_type = ClassType.new('String')
      let instance = ClassInstance.new(obj_type)

      try assert_not_compatible(obj_type, instance)
    }

    g.test('Comparing an ClassType with a TraitType') {
      let obj_type = ClassType.new('String')
      let trait_type = TraitType.new('ToString')

      try assert_not_compatible(obj_type, trait_type)
    }

    g.test('Comparing an ClassType with a TraitInstance') {
      let builtins = Builtins.new
      let obj_type = ClassType.new('String')
      let trait_type = TraitType.new('ToString')
      let with = TraitInstance.new(trait_type)

      try assert_not_compatible(compare: obj_type, with: with, builtins: builtins)

      obj_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait_type))
      )

      # Trait implementations apply to instances of a type, so the String type
      # itself here is not compatible with ToString, as only _instances of_
      # String are compatible with ToString.
      try assert_not_compatible(compare: obj_type, with: with, builtins: builtins)
    }

    g.test('Comparing an ClassType with a SelfType') {
      let obj_type = ClassType.new('String')
      let self_type = SelfType.new

      # The String type itself can't be passed to an instance of String.
      try assert_not_compatible(obj_type, self_type)
    }

    g.test('Comparing an ClassType with an empty TypeParameterType') {
      let obj_type = ClassType.new('String')
      let param = TypeParameterType.new('T')

      try assert_compatible(obj_type, param)
    }

    g.test('Comparing an ClassType with a TypeParameterType with one required trait') {
      let obj_type = ClassType.new('String')
      let trait_type = TraitType.new('A')
      let param = TypeParameterType
        .new(name: 'T', required_traits: Array.new(TraitInstance.new(trait_type)))

      try assert_not_compatible(obj_type, param)

      obj_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait_type))
      )

      try assert_not_compatible(obj_type, param)
    }

    g.test('Comparing an ClassType with a TypeParameterType with multiple required traits') {
      let obj_type = ClassType.new('String')
      let trait1 = TraitType.new('A')
      let trait2 = TraitType.new('B')
      let param = TypeParameterType.new(
        name: 'T',
        required_traits: Array.new(
          TraitInstance.new(trait1),
          TraitInstance.new(trait2)
        )
      )

      try assert_not_compatible(obj_type, param)

      obj_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      obj_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait2))
      )

      try assert_not_compatible(obj_type, param)
    }

    g.test('Comparing a ClassType with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let compare = ClassType.new('Foo')

        try assert_compatible(compare: compare, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, compare)
      }
    }

    g.test('Comparing a ClassType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')
        let compare = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: compare, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing an ClassType with a ModuleType') {
      let obj_type = ClassType.new('String')
      let mod_type = new_module

      try assert_not_compatible(obj_type, mod_type)
    }
  }

  t.group('std::compiler::types::ClassInstance.instance_of') do (g) {
    g.test('Obtaining the type an object is an instance of') {
      let object_type = ClassType.new('String')

      try assert_same_object(object_type.new_instance.instance_of, object_type)
    }
  }

  t.group('std::compiler::types::ClassInstance.type_parameter_types') do (g) {
    g.test('Obtaining the type parameter types') {
      let object_type = ClassType.new('Array')
      let instance = object_type.new_instance

      try assert_true(instance.type_parameter_types.empty?)
    }
  }

  t.group('std::compiler::types::ClassInstance.type_name') do (g) {
    g.test('Obtaining the type name of a regular ClassInstance') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_equal(instance.type_name, 'String')
    }

    g.test('Obtaining the type name of an ClassInstance with one type parameter') {
      let type = ClassType.new('Array')
      let instance = ClassInstance.new(type)

      type.type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(instance.type_name, 'Array!(T)')
    }

    g.test('Obtaining the type name of an ClassInstance with multiple type parameters') {
      let type = ClassType.new('Array')
      let instance = ClassInstance.new(type)

      type.type_parameters.define(name: 'A', type: TypeParameterType.new('A'))
      type.type_parameters.define(name: 'B', type: TypeParameterType.new('B'))

      try assert_equal(instance.type_name, 'Array!(A, B)')
    }

    g.test('Obtaining the type name of a ClassInstance with type arguments') {
      let type = ClassType.new('Array')
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let instance = ClassInstance.new(type)

    instance.type_parameter_types[param1] = NeverType.new
    instance.type_parameter_types[param2] = ClassType.new('A')

      type.type_parameters.define(name: 'A', type: param1)
      type.type_parameters.define(name: 'B', type: param2)

      try assert_equal(instance.type_name, 'Array!(Never, A)')
    }
  }

  t.group('std::compiler::types::ClassInstance.number_of_type_parameters') do (g) {
    g.test('Obtaining the number of type parameters') {
      let object1 = ClassType.new('A')
      let object2 = ClassType.new('B')

      object2.type_parameters.define(name: 'T', type: TypeParameterType.new('T'))

      try assert_equal(object1.new_instance.number_of_type_parameters, 0)
      try assert_equal(object2.new_instance.number_of_type_parameters, 1)
    }
  }

  t.group('std::compiler::types::ClassInstance.lookup_attribute') do (g) {
    g.test('Looking up an attribute of an object') {
      let object_type = ClassType.new('A')
      let type = NeverType.new

      object_type.define_attribute(name: '@a', type: type)

      let attr = object_type.new_instance.lookup_attribute('@a').get.type

      try assert_same_object(attr.public_type, type)
      try assert_same_object(attr.internal_type, type)
      try assert_true(object_type.new_instance.lookup_attribute('@b').none?)
    }
  }

  t.group('std::compiler::types::ClassInstance.lookup_method') do (g) {
    g.test('Looking up an instance method') {
      let object_type = ClassType.new('A')
      let instance = object_type.new_instance
      let a_method =
        MethodType.new(name: 'a', layout: BlockLayout.new(NeverType.new))

      let b_method =
        MethodType.new(name: 'b', layout: BlockLayout.new(NeverType.new))

      object_type.instance_methods.define(name: 'a', type: a_method)
      object_type.static_methods.define(name: 'b', type: b_method)

      try assert_same_object(instance.lookup_method('a').get.type, a_method)
      try assert_true(instance.lookup_method('b').none?)
    }
  }

  t.group('std::compiler::types::ClassInstance.lookup_type') do (g) {
    g.test('Looking up a type by its name') {
      let object_type = ClassType.new('A')
      let param = TypeParameterType.new('T')
      let instance = object_type.new_instance

      object_type.type_parameters.define(name: param.name, type: param)

      try assert_equal(instance.lookup_type(param.name).get.type, param)
      try assert_true(instance.lookup_type('B').none?)
    }
  }

  t.group('std::compiler::types::ClassInstance.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let object_type = ClassType.new('A')
      let param = TypeParameterType.new('T')
      let instance = object_type.new_instance

      object_type.type_parameters.define(name: param.name, type: param)

      try assert_equal(instance.lookup_type_parameter(param.name).get.type, param)
      try assert_true(instance.lookup_type_parameter('B').none?)
    }
  }

  t.group('std::compiler::types::ClassInstance.lookup_type_parameter') do (g) {
    g.test('Looking up a type parameter by its name') {
      let object_type = ClassType.new('A')
      let param = TypeParameterType.new('T')
      let instance = object_type.new_instance

      object_type.type_parameters.define(name: param.name, type: param)

      try assert_equal(instance.lookup_type_parameter(param.name).get.type, param)
      try assert_true(instance.lookup_type_parameter('B').none?)
    }
  }

  t.group('std::compiler::types::ClassInstance.object_instance_of?') do (g) {
    g.test('Checking if an ClassInstance is an instance of an ClassType') {
      let obj1 = ClassType.new('A')
      let obj2 = ClassType.new('B')
      let instance = obj1.new_instance

      try assert_true(instance.object_instance_of?(obj1))
      try assert_false(instance.object_instance_of?(obj2))
    }
  }

  t.group('std::compiler::types::ClassInstance.implements_trait?') do (g) {
    g.test('Checking if an object instance implements a trait') {
      let object_type = ClassType.new('A')
      let object_instance = object_type.new_instance
      let trait_type = TraitType.new('A')
      let trait_instance = trait_type.new_instance
      let builtins = Builtins.new
      let scope = TypeScope.new(module: new_module, self_type: object_type)

      try assert_false(
        object_instance
          .implements_trait?(type: trait_instance, builtins: builtins, scope: scope)
      )

      object_type
        .add_trait_implementation(TraitImplementation.new(trait_instance))

      try assert_true(
        object_instance
          .implements_trait?(type: trait_instance, builtins: builtins, scope: scope)
      )
    }

    g.test('Checking if an object instance implements a trait with additional bounds') {
      let module = new_module
      let to_string = TraitType.new('ToString')
      let builtins = Builtins.new
      let list_type = ClassType.new('List')
      let param = TypeParameterType.new('T')
      let to_string_impl = TraitImplementation.new(to_string.new_instance)

      to_string_impl
        .bounds
        .define(parameter: param, requirements: Array.new(to_string.new_instance))

      list_type.type_parameters.define(name: param.name, type: param)

      # This is the equivalent of `impl ToString for List when T: ToString {}`
      list_type.add_trait_implementation(to_string_impl)

      builtins
        .integer_type
        .add_trait_implementation(TraitImplementation.new(to_string.new_instance))

      let list1 = list_type.new_instance
      let list2 =
        list_type.new_instance(Array.new(builtins.float_type.new_instance))

      let list3 =
        list_type.new_instance(Array.new(builtins.integer_type.new_instance))

      try assert_false(
        list1.implements_trait?(
          type: to_string.new_instance,
          builtins: builtins,
          scope: TypeScope.new(module: module, self_type: list1)
        )
      )

      try assert_false(
        list2.implements_trait?(
          type: to_string.new_instance,
          builtins: builtins,
          scope: TypeScope.new(module: module, self_type: list2)
        )
      )

      try assert_true(
        list3.implements_trait?(
          type: to_string.new_instance,
          builtins: builtins,
          scope: TypeScope.new(module: module, self_type: list3)
        )
      )
    }
  }

  t.group('std::compiler::types::ClassInstance.type_compatible?') do (g) {
    g.test('Comparing an ClassInstance with an ErrorType') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_compatible(instance, ErrorType.new)
    }

    g.test('Comparing an ClassInstance with an AnyType') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_compatible(instance, AnyType.new)
    }

    g.test('Comparing an ClassInstance with a NeverType') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_not_compatible(instance, NeverType.new)
    }

    g.test('Comparing an ClassInstance with an ClassType') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_not_compatible(instance, ClassType.new('String'))
    }

    g.test('Comparing an ClassInstance with a TraitType') {
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_not_compatible(instance, TraitType.new('ToString'))
    }

    g.test('Comparing an ClassInstance with another ClassInstance') {
      let obj1 = ClassType.new('String')
      let obj2 = ClassType.new('Foo')

      try assert_not_compatible(ClassInstance.new(obj1), ClassInstance.new(obj2))
      try assert_compatible(ClassInstance.new(obj1), ClassInstance.new(obj1))
    }

    g.test('Comparing a generic ClassInstance with another ClassInstance') {
      let obj_type = ClassType.new('Pair')
      let param1 = TypeParameterType.new('A')
      let param2 = TypeParameterType.new('B')
      let object_type = ClassType.new('A')

      obj_type.type_parameters.define(name: 'A', type: param1)
      obj_type.type_parameters.define(name: 'B', type: param2)

      let instance1 = ClassInstance.new(obj_type)
      let instance2 = ClassInstance.new(obj_type)
      let instance3 = ClassInstance.new(obj_type)
      let instance4 = ClassInstance.new(obj_type)

      instance1.type_parameter_types[param1] = object_type
      instance1.type_parameter_types[param2] = object_type

      instance2.type_parameter_types[param1] = object_type
      instance2.type_parameter_types[param2] = object_type

      instance3.type_parameter_types[param1] = NeverType.new
      instance3.type_parameter_types[param2] = NeverType.new

      try assert_compatible(instance1, instance2)
      try assert_not_compatible(instance2, instance3)
      try assert_not_compatible(instance2, instance4)
    }

    g.test('Comparing an ClassInstance with a TraitInstance') {
      let obj_type = ClassType.new('String')
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')

      try assert_not_compatible(
        ClassInstance.new(obj_type),
        TraitInstance.new(trait1)
      )

      try assert_not_compatible(
        ClassInstance.new(obj_type),
        TraitInstance.new(trait2)
      )

      obj_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(
        ClassInstance.new(obj_type),
        TraitInstance.new(trait1)
      )
    }

    g.test('Comparing an ClassInstance with a TypeParameterType') {
      let obj_type = ClassType.new('String')
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')
      let param1 = TypeParameterType.new('T')
      let param2 = TypeParameterType.new(
        name: 'B',
        required_traits: Array.new(
          TraitInstance.new(trait1), TraitInstance.new(trait2)
        )
      )

      try assert_compatible(ClassInstance.new(obj_type), param1)
      try assert_not_compatible(ClassInstance.new(obj_type), param2)

      obj_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_not_compatible(ClassInstance.new(obj_type), param2)
    }

    g.test('Comparing a ClassInstance with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let compare = ClassType.new('Foo').new_instance

        try assert_compatible(compare: compare, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, compare)
      }
    }

    g.test('Comparing a ClassInstance with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Bar')
        let compare = ClassType.new('Foo').new_instance

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: compare, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing an ClassInstance with a ModuleType') {
      let mod_type = new_module
      let instance = ClassInstance.new(ClassType.new('String'))

      try assert_not_compatible(instance, mod_type)
    }

    g.test('Comparing an ClassInstance with a SelfType') {
      let obj1 = ClassType.new('String')
      let obj2 = ClassType.new('Integer')
      let builtins = Builtins.new

      try assert_compatible(
        compare: ClassInstance.new(obj1),
        with: SelfType.new,
        builtins: builtins,
        self_type: ClassInstance.new(obj1)
      )

      try assert_not_compatible(
        compare: ClassInstance.new(obj1),
        with: SelfType.new,
        builtins: builtins,
        self_type: ClassInstance.new(obj2)
      )
    }
  }

  t.group('std::compiler::types::ClassInstance.substitute') do (g) {
    g.test('Substituting a regular object') {
      let object_type = ClassType.new('A')
      let instance = object_type.new_instance

      try assert_same_object(instance.substitute(type_scope(instance)), instance)
    }

    g.test('Substituting a generic object') {
      let object1 = ClassType.new('A')
      let object2 = ClassType.new('B')
      let param = TypeParameterType.new('T')

      object2.type_parameters.define(name: param.name, type: param)

      let instance1 = object1.new_instance
      let instance2 = object2.new_instance(Array.new(SelfType.new))
      let instance3 = instance2.substitute(type_scope(instance1))

      try assert_same_object(instance3.type_parameter_types[param], instance1)
    }

    g.test('Substituting a generic object with custom type arguments') {
      let list_type = ClassType.new('List')
      let param = TypeParameterType.new('T')
      let assigned = ClassType.new('Integer').new_instance

      list_type.type_parameters.define(name: param.name, type: param)

      let list1 = list_type.new_instance(Array.new(param))
      let list2 = list_type.new_instance(Array.new(assigned))
      let list3 = list1.substitute(type_scope(list2))

      try assert_same_object(list3.lookup_type_parameter_type(param).get, assigned)
    }
  }

  t.group('std::compiler::types::ModuleType.name') do (g) {
    g.test('Obtaining the name of a module') {
      try assert_equal(new_module.name.to_string, 'foo')
    }
  }

  t.group('std::compiler::types::ModuleType.constants') do (g) {
    g.test('Obtaining the constants defined in a module') {
      try assert_true(new_module.constants.empty?)
    }
  }

  t.group('std::compiler::types::ModuleType.methods') do (g) {
    g.test('Obtaining the methods defined in a module') {
      try assert_true(new_module.methods.empty?)
    }
  }

  t.group('std::compiler::types::ModuleType.globals') do (g) {
    g.test('Obtaining the imported global variables of a module') {
      try assert_true(new_module.globals.empty?)
    }
  }

  t.group('std::compiler::types::ModuleType.defines?') do (g) {
    g.test('Checking if a symbol is defined in a module') {
      let mod = new_module
      let method =
        MethodType.new(name: 'a', layout: BlockLayout.new(NeverType.new))

      mod.define_method(name: 'a', type: method)
      mod.define_constant(name: 'b', type: ClassType.new('A'))

      try assert_true(mod.defines?('a'))
      try assert_true(mod.defines?('b'))
      try assert_false(mod.defines?('c'))
    }
  }

  t.group('std::compiler::types::ModuleType.type_name') do (g) {
    g.test('Obtaining the type name of a module') {
      let mod1 = new_module
      let mod2 = ModuleType.new(ModuleName.new(Array.new('foo', 'bar')))

      try assert_equal(mod1.type_name, 'foo')
      try assert_equal(mod2.type_name, 'foo::bar')
    }
  }

  t.group('std::compiler::types::ModuleType.lookup_type') do (g) {
    g.test('Looking up a type') {
      let mod = new_module
      let type = ClassType.new('A')

      mod.define_constant(name: 'A', type: type)

      try assert_same_object(mod.lookup_type('A').get.type, type)
      try assert_true(mod.lookup_type('B').none?)
    }
  }

  t.group('std::compiler::types::ModuleType.lookup_method') do (g) {
    g.test('Looking up a method') {
      let mod = new_module
      let method =
        MethodType.new(name: 'foo', layout: BlockLayout.new(NeverType.new))

      mod.define_method(name: method.name, type: method)

      try assert_same_object(mod.lookup_method(method.name).get.type, method)
      try assert_true(mod.lookup_method('baz').none?)
    }

    g.test('Looking up an external function') {
      let mod = new_module
      let method = MethodType
        .new(name: 'foo', layout: BlockLayout.new(NeverType.new), external: True)

      mod.define_method(name: method.name, type: method)

      try assert_same_object(mod.lookup_method(method.name).get.type, method)
      try assert_true(mod.methods.get(method.name).none?)
    }
  }

  t.group('std::compiler::types::ModuleType.type_compatible?') do (g) {
    g.test('Comparing a ModuleType with an ErrorType') {
      try assert_compatible(new_module, ErrorType.new)
    }

    g.test('Comparing a ModuleType with an AnyType') {
      try assert_compatible(new_module, AnyType.new)
    }

    g.test('Comparing a ModuleType with a NeverType') {
      try assert_not_compatible(new_module, NeverType.new)
    }

    g.test('Comparing a ModuleType with an ClassType') {
      try assert_not_compatible(new_module, ClassType.new('String'))
    }

    g.test('Comparing a ModuleType with a ClassType') {
      try assert_not_compatible(new_module, TraitType.new('ToString'))
    }

    g.test('Comparing a ModuleType with another ModuleType') {
      let mod1 = new_module
      let mod2 = ModuleType.new(ModuleName.new(Array.new('bar')))

      try assert_compatible(mod1, mod1)
      try assert_not_compatible(mod1, mod2)
    }

    g.test('Comparing a ModuleType with an ClassInstance') {
      let builtins = Builtins.new
      let mod_type = new_module
      let obj_type = ClassType.new('Thing')

      try assert_compatible(
        compare: mod_type,
        with: ClassInstance.new(builtins.module_type),
        builtins: builtins
      )

      try assert_not_compatible(
        compare: mod_type,
        with: ClassInstance.new(obj_type),
        builtins: builtins
      )
    }

    g.test('Comparing a ModuleType with a TraitInstance') {
      let builtins = Builtins.new
      let mod_type = new_module
      let trait1 = TraitType.new('ToString')

      try assert_not_compatible(
        compare: mod_type,
        with: TraitInstance.new(trait1),
        builtins: builtins
      )

      builtins.module_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      try assert_compatible(
        compare: mod_type,
        with: TraitInstance.new(trait1),
        builtins: builtins
      )
    }

    g.test('Comparing a ModuleType with a TypeParameterType') {
      let builtins = Builtins.new
      let mod_type = new_module
      let trait1 = TraitType.new('ToString')
      let trait2 = TraitType.new('ToInteger')
      let param1 = TypeParameterType.new('T')
      let param2 = TypeParameterType.new(
        name: 'B',
        required_traits: Array.new(
          TraitInstance.new(trait1), TraitInstance.new(trait2)
        )
      )

      try assert_compatible(compare: mod_type, with: param1, builtins: builtins)
      try assert_not_compatible(compare: mod_type, with: param2, builtins: builtins)

      builtins.module_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait1))
      )

      builtins.module_type.add_trait_implementation(
        TraitImplementation.new(TraitInstance.new(trait2))
      )

      try assert_compatible(compare: mod_type, with: param2, builtins: builtins)
    }

    g.test('Comparing a ModuleType with an unassigned TypeParameterType') {
      with_generic_type do (type, param) {
        let compare = new_module

        try assert_compatible(compare: compare, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, compare)
      }
    }

    g.test('Comparing a ModuleType with an assigned TypeParameterType') {
      with_generic_type do (type, param) {
        let assigned = ClassType.new('Foo')

        type.assign_type_parameter(parameter: param, type: assigned)

        try assert_not_compatible(compare: new_module, with: param, self_type: type)
        try assert_same_object(type.lookup_type_parameter_type(param).get, assigned)
      }
    }

    g.test('Comparing a ModuleType with a SelfType') {
      let mod1 = new_module
      let mod2 = ModuleType.new(ModuleName.new(Array.new('bar')))
      let builtins = Builtins.new

      try assert_compatible(
        compare: mod1,
        with: SelfType.new,
        builtins: builtins,
        self_type: mod1
      )

      try assert_not_compatible(
        compare: mod1,
        with: SelfType.new,
        builtins: builtins,
        self_type: mod2
      )
    }
  }
}
