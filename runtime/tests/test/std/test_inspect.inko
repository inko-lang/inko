import std::float::(INFINITY, NAN, NEGATIVE_INFINITY)
import std::test
import std::test::assert

object OneAttribute {
  @number: Integer

  def init {
    @number = 10
  }
}

object TwoAttributes {
  @first: String
  @second: Integer

  def init {
    @first = 'first'
    @second = 10
  }
}

object NestedObject {
  @child: OneAttribute

  def init {
    @child = OneAttribute.new
  }
}

test.group('std::object::Object.inspect') do (g) {
  g.test('Inspecting an empty Object') {
    assert.equal(Object.new.inspect, 'Object')
  }

  g.test('Inspecting an Object with one attribute') {
    let obj = OneAttribute.new

    assert.equal(obj.inspect, 'OneAttribute { @number = 10 }')
  }

  g.test('Inspecting an Object with multiple attributes') {
    let obj = TwoAttributes.new

    let possible = Array.new(
      'TwoAttributes { @first = "first", @second = 10 }',
      'TwoAttributes { @second = 10, @first = "first" }'
    )

    # The order of attributes is not guaranteed, so we can't perform an equality
    # comparison as such a test would randomly fail.
    assert.true(possible.contains?(obj.inspect))
  }

  g.test('Inspecting an Object containing another Object') {
    let obj = NestedObject.new

    assert.equal(
      obj.inspect,
      'NestedObject { @child = OneAttribute { @number = 10 } }'
    )
  }
}

test.group('std::float::Float.inspect') do (g) {
  g.test('Inspecting a Float') {
    assert.equal(1.0.inspect, '1.0')
    assert.equal(1.123.inspect, '1.123')
  }

  g.test('Inspecting a NaN') {
    assert.equal(NAN.inspect, 'NaN')
  }

  g.test('Inspecting Infinity') {
    assert.equal(INFINITY.inspect, 'Infinity')
  }

  g.test('Inspecting negative Infinity') {
    assert.equal(NEGATIVE_INFINITY.inspect, '-Infinity')
  }
}

test.group('std::integer::Integer.inspect') do (g) {
  g.test('Inspecting an Integer') {
    assert.equal(10.inspect, '10')
    assert.equal(-10.inspect, '-10')
  }
}

test.group('std::nil::Nil.inspect') do (g) {
  g.test('Inspecting Nil') {
    assert.equal(Nil.inspect, 'Nil')
  }
}

test.group('std::boolean::Boolean.inspect') do (g) {
  g.test('Inspecting Boolean') {
    assert.equal(Boolean.inspect, 'Boolean')
  }

  g.test('Inspecting boolean True') {
    assert.equal(True.inspect, 'True')
  }

  g.test('Inspecting boolean False') {
    assert.equal(False.inspect, 'False')
  }
}

test.group('std::string::String.inspect') do (g) {
  g.test('Inspecting an empty String') {
    assert.equal(''.inspect, '""')
  }

  g.test('Inspecting a non-empty String') {
    assert.equal('foo'.inspect, '"foo"')
  }
}

test.group('std::array::Array.inspect') do (g) {
  g.test('Inspecting an empty Array') {
    assert.equal(Array.new.inspect, 'Array')
  }

  g.test('Inspecting a non-empty Array') {
    assert.equal(Array.new(10).inspect, 'Array { 10 }')
    assert.equal(Array.new(10, 20).inspect, 'Array { 10, 20 }')
  }
}

test.group('std::map::Map.inspect') do (g) {
  g.test('Inspecting an empty Map') {
    assert.equal(Map.new.inspect, 'Map')
  }

  g.test('Inspecting a non-empty Map') {
    let map = Map.new

    map['foo'] = 10
    map['bar'] = 20

    let ins = map.inspect
    let valid =
      (ins == 'Map { "foo": 10, "bar": 20 }')
        .or { ins == 'Map { "bar": 20, "foo": 10 }' }

    assert.true(valid)
  }
}
