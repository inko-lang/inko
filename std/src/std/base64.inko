# Base64 encoding and decoding.
#
# This module provides types and methods for encoding and decoding base64 data.
# Data is encoded using the `Encoder` type, while decoding is done using the
# `Decoder` type.
#
# The encoder and decoder implementations are based on the base64
# encoder/decoder as found in Google Chrome, which is based on the code found in
# <https://github.com/client9/stringencoders>.
#
# # Examples
#
# Encoding using the `Encoder` type, and decoding using the `Decoder` type:
#
# ```inko
# import std.base64 (Decoder, Encoder)
#
# let base64 = ByteArray.new
# let plain = ByteArray.new
#
# Encoder.new.encode('hello world'.to_byte_array, into: base64)
# base64.to_string # => 'aGVsbG8gd29ybGQ='
#
# Decoder.new.decode(base64, into: plain) # => Result.Ok(nil)
# plain.into_string # => 'hello world'
# ```
#
# For simple cases you can also use the `encode` and `decode` methods:
#
# ```inko
# import std.base64 (decode, encode)
#
# decode(encode('hello world'.to_byte_array))
#   .or_panic('failed to decode the input')
#   .to_string # => 'hello world'
# ```
import std.cmp (Equal)
import std.fmt (Format, Formatter)
import std.string (ToString)

# The character ('=') to use for padding.
let PAD = 0x3D
let HI_MASK = 0x00FF0000
let MI_MASK = 0x0000FF00
let LO_MASK = 0x000000FF

# The sentinel value that signals an invalid byte is encountered when decoding
# base64 data.
let ERR_CHAR = 0x01FFFFFF

# The table to use for encoding data using the standard alphabet.
let ENCODE_STD = [
  [
    0x41, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43, 0x43,
    0x44, 0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x45, 0x46, 0x46, 0x46, 0x46,
    0x47, 0x47, 0x47, 0x47, 0x48, 0x48, 0x48, 0x48, 0x49, 0x49, 0x49, 0x49,
    0x4A, 0x4A, 0x4A, 0x4A, 0x4B, 0x4B, 0x4B, 0x4B, 0x4C, 0x4C, 0x4C, 0x4C,
    0x4D, 0x4D, 0x4D, 0x4D, 0x4E, 0x4E, 0x4E, 0x4E, 0x4F, 0x4F, 0x4F, 0x4F,
    0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x52,
    0x53, 0x53, 0x53, 0x53, 0x54, 0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 0x55,
    0x56, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57, 0x57, 0x58, 0x58, 0x58, 0x58,
    0x59, 0x59, 0x59, 0x59, 0x5A, 0x5A, 0x5A, 0x5A, 0x61, 0x61, 0x61, 0x61,
    0x62, 0x62, 0x62, 0x62, 0x63, 0x63, 0x63, 0x63, 0x64, 0x64, 0x64, 0x64,
    0x65, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67, 0x67,
    0x68, 0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x69, 0x6A, 0x6A, 0x6A, 0x6A,
    0x6B, 0x6B, 0x6B, 0x6B, 0x6C, 0x6C, 0x6C, 0x6C, 0x6D, 0x6D, 0x6D, 0x6D,
    0x6E, 0x6E, 0x6E, 0x6E, 0x6F, 0x6F, 0x6F, 0x6F, 0x70, 0x70, 0x70, 0x70,
    0x71, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72, 0x72, 0x73, 0x73, 0x73, 0x73,
    0x74, 0x74, 0x74, 0x74, 0x75, 0x75, 0x75, 0x75, 0x76, 0x76, 0x76, 0x76,
    0x77, 0x77, 0x77, 0x77, 0x78, 0x78, 0x78, 0x78, 0x79, 0x79, 0x79, 0x79,
    0x7A, 0x7A, 0x7A, 0x7A, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
    0x32, 0x32, 0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34, 0x34, 0x34,
    0x35, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37, 0x37,
    0x38, 0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x2B, 0x2B, 0x2B, 0x2B,
    0x2F, 0x2F, 0x2F, 0x2F,
  ],
  [
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2B, 0x2F, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F, 0x41, 0x42, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F,
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2B, 0x2F,
  ],
  [
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2B, 0x2F, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F, 0x41, 0x42, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2B, 0x2F,
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2B, 0x2F,
  ],
]

# The table to use for encoding data using the URL safe alphabet.
let ENCODE_URL = [
  [
    0x41, 0x41, 0x41, 0x41, 0x42, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43, 0x43,
    0x44, 0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x45, 0x46, 0x46, 0x46, 0x46,
    0x47, 0x47, 0x47, 0x47, 0x48, 0x48, 0x48, 0x48, 0x49, 0x49, 0x49, 0x49,
    0x4A, 0x4A, 0x4A, 0x4A, 0x4B, 0x4B, 0x4B, 0x4B, 0x4C, 0x4C, 0x4C, 0x4C,
    0x4D, 0x4D, 0x4D, 0x4D, 0x4E, 0x4E, 0x4E, 0x4E, 0x4F, 0x4F, 0x4F, 0x4F,
    0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x52,
    0x53, 0x53, 0x53, 0x53, 0x54, 0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 0x55,
    0x56, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57, 0x57, 0x58, 0x58, 0x58, 0x58,
    0x59, 0x59, 0x59, 0x59, 0x5A, 0x5A, 0x5A, 0x5A, 0x61, 0x61, 0x61, 0x61,
    0x62, 0x62, 0x62, 0x62, 0x63, 0x63, 0x63, 0x63, 0x64, 0x64, 0x64, 0x64,
    0x65, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67, 0x67,
    0x68, 0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x69, 0x6A, 0x6A, 0x6A, 0x6A,
    0x6B, 0x6B, 0x6B, 0x6B, 0x6C, 0x6C, 0x6C, 0x6C, 0x6D, 0x6D, 0x6D, 0x6D,
    0x6E, 0x6E, 0x6E, 0x6E, 0x6F, 0x6F, 0x6F, 0x6F, 0x70, 0x70, 0x70, 0x70,
    0x71, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72, 0x72, 0x73, 0x73, 0x73, 0x73,
    0x74, 0x74, 0x74, 0x74, 0x75, 0x75, 0x75, 0x75, 0x76, 0x76, 0x76, 0x76,
    0x77, 0x77, 0x77, 0x77, 0x78, 0x78, 0x78, 0x78, 0x79, 0x79, 0x79, 0x79,
    0x7A, 0x7A, 0x7A, 0x7A, 0x30, 0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31,
    0x32, 0x32, 0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34, 0x34, 0x34,
    0x35, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x36, 0x37, 0x37, 0x37, 0x37,
    0x38, 0x38, 0x38, 0x38, 0x39, 0x39, 0x39, 0x39, 0x2D, 0x2D, 0x2D, 0x2D,
    0x5F, 0x5F, 0x5F, 0x5F,
  ],
  [
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2D, 0x5F, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2D, 0x5F, 0x41, 0x42, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2D, 0x5F,
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2D, 0x5F,
  ],
  [
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2D, 0x5F, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
    0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54,
    0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
    0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72,
    0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33,
    0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2D, 0x5F, 0x41, 0x42, 0x43, 0x44,
    0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
    0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x61, 0x62,
    0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E,
    0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x2D, 0x5F,
    0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C,
    0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
    0x59, 0x5A, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A,
    0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
    0x77, 0x78, 0x79, 0x7A, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
    0x38, 0x39, 0x2D, 0x5F,
  ],
]

# The table to use for decoding data using the standard alphabet.
let DECODE_STD = [
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, 0x0000F8, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x0000FC, 0x0000D0,
    0x0000D4, 0x0000D8, 0x0000DC, 0x0000E0, 0x0000E4, 0x0000E8, 0x0000EC,
    0x0000F0, 0x0000F4, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x000004, 0x000008, 0x00000C, 0x000010,
    0x000014, 0x000018, 0x00001C, 0x000020, 0x000024, 0x000028, 0x00002C,
    0x000030, 0x000034, 0x000038, 0x00003C, 0x000040, 0x000044, 0x000048,
    0x00004C, 0x000050, 0x000054, 0x000058, 0x00005C, 0x000060, 0x000064,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x000068,
    0x00006C, 0x000070, 0x000074, 0x000078, 0x00007C, 0x000080, 0x000084,
    0x000088, 0x00008C, 0x000090, 0x000094, 0x000098, 0x00009C, 0x0000A0,
    0x0000A4, 0x0000A8, 0x0000AC, 0x0000B0, 0x0000B4, 0x0000B8, 0x0000BC,
    0x0000C0, 0x0000C4, 0x0000C8, 0x0000CC, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, 0x00E003, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x00F003, 0x004003,
    0x005003, 0x006003, 0x007003, 0x008003, 0x009003, 0x00A003, 0x00B003,
    0x00C003, 0x00D003, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x001000, 0x002000, 0x003000, 0x004000,
    0x005000, 0x006000, 0x007000, 0x008000, 0x009000, 0x00A000, 0x00B000,
    0x00C000, 0x00D000, 0x00E000, 0x00F000, 0x000001, 0x001001, 0x002001,
    0x003001, 0x004001, 0x005001, 0x006001, 0x007001, 0x008001, 0x009001,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x00A001,
    0x00B001, 0x00C001, 0x00D001, 0x00E001, 0x00F001, 0x000002, 0x001002,
    0x002002, 0x003002, 0x004002, 0x005002, 0x006002, 0x007002, 0x008002,
    0x009002, 0x00A002, 0x00B002, 0x00C002, 0x00D002, 0x00E002, 0x00F002,
    0x000003, 0x001003, 0x002003, 0x003003, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, 0x800F00, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0xC00F00, 0x000D00,
    0x400D00, 0x800D00, 0xC00D00, 0x000E00, 0x400E00, 0x800E00, 0xC00E00,
    0x000F00, 0x400F00, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x400000, 0x800000, 0xC00000, 0x000100,
    0x400100, 0x800100, 0xC00100, 0x000200, 0x400200, 0x800200, 0xC00200,
    0x000300, 0x400300, 0x800300, 0xC00300, 0x000400, 0x400400, 0x800400,
    0xC00400, 0x000500, 0x400500, 0x800500, 0xC00500, 0x000600, 0x400600,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x800600,
    0xC00600, 0x000700, 0x400700, 0x800700, 0xC00700, 0x000800, 0x400800,
    0x800800, 0xC00800, 0x000900, 0x400900, 0x800900, 0xC00900, 0x000A00,
    0x400A00, 0x800A00, 0xC00A00, 0x000B00, 0x400B00, 0x800B00, 0xC00B00,
    0x000C00, 0x400C00, 0x800C00, 0xC00C00, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, 0x3E0000, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x3F0000, 0x340000,
    0x350000, 0x360000, 0x370000, 0x380000, 0x390000, 0x3A0000, 0x3B0000,
    0x3C0000, 0x3D0000, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x010000, 0x020000, 0x030000, 0x040000,
    0x050000, 0x060000, 0x070000, 0x080000, 0x090000, 0x0A0000, 0x0B0000,
    0x0C0000, 0x0D0000, 0x0E0000, 0x0F0000, 0x100000, 0x110000, 0x120000,
    0x130000, 0x140000, 0x150000, 0x160000, 0x170000, 0x180000, 0x190000,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x1A0000,
    0x1B0000, 0x1C0000, 0x1D0000, 0x1E0000, 0x1F0000, 0x200000, 0x210000,
    0x220000, 0x230000, 0x240000, 0x250000, 0x260000, 0x270000, 0x280000,
    0x290000, 0x2A0000, 0x2B0000, 0x2C0000, 0x2D0000, 0x2E0000, 0x2F0000,
    0x300000, 0x310000, 0x320000, 0x330000, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
]

# The table to use for decoding data using the URL safe alphabet.
let DECODE_URL = [
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x0000F8, ERR_CHAR, ERR_CHAR, 0x0000D0,
    0x0000D4, 0x0000D8, 0x0000DC, 0x0000E0, 0x0000E4, 0x0000E8, 0x0000EC,
    0x0000F0, 0x0000F4, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x000004, 0x000008, 0x00000C, 0x000010,
    0x000014, 0x000018, 0x00001C, 0x000020, 0x000024, 0x000028, 0x00002C,
    0x000030, 0x000034, 0x000038, 0x00003C, 0x000040, 0x000044, 0x000048,
    0x00004C, 0x000050, 0x000054, 0x000058, 0x00005C, 0x000060, 0x000064,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x0000FC, ERR_CHAR, 0x000068,
    0x00006C, 0x000070, 0x000074, 0x000078, 0x00007C, 0x000080, 0x000084,
    0x000088, 0x00008C, 0x000090, 0x000094, 0x000098, 0x00009C, 0x0000A0,
    0x0000A4, 0x0000A8, 0x0000AC, 0x0000B0, 0x0000B4, 0x0000B8, 0x0000BC,
    0x0000C0, 0x0000C4, 0x0000C8, 0x0000CC, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x00E003, ERR_CHAR, ERR_CHAR, 0x004003,
    0x005003, 0x006003, 0x007003, 0x008003, 0x009003, 0x00A003, 0x00B003,
    0x00C003, 0x00D003, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x001000, 0x002000, 0x003000, 0x004000,
    0x005000, 0x006000, 0x007000, 0x008000, 0x009000, 0x00A000, 0x00B000,
    0x00C000, 0x00D000, 0x00E000, 0x00F000, 0x000001, 0x001001, 0x002001,
    0x003001, 0x004001, 0x005001, 0x006001, 0x007001, 0x008001, 0x009001,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x00F003, ERR_CHAR, 0x00A001,
    0x00B001, 0x00C001, 0x00D001, 0x00E001, 0x00F001, 0x000002, 0x001002,
    0x002002, 0x003002, 0x004002, 0x005002, 0x006002, 0x007002, 0x008002,
    0x009002, 0x00A002, 0x00B002, 0x00C002, 0x00D002, 0x00E002, 0x00F002,
    0x000003, 0x001003, 0x002003, 0x003003, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x800F00, ERR_CHAR, ERR_CHAR, 0x000D00,
    0x400D00, 0x800D00, 0xC00D00, 0x000E00, 0x400E00, 0x800E00, 0xC00E00,
    0x000F00, 0x400F00, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x400000, 0x800000, 0xC00000, 0x000100,
    0x400100, 0x800100, 0xC00100, 0x000200, 0x400200, 0x800200, 0xC00200,
    0x000300, 0x400300, 0x800300, 0xC00300, 0x000400, 0x400400, 0x800400,
    0xC00400, 0x000500, 0x400500, 0x800500, 0xC00500, 0x000600, 0x400600,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0xC00F00, ERR_CHAR, 0x800600,
    0xC00600, 0x000700, 0x400700, 0x800700, 0xC00700, 0x000800, 0x400800,
    0x800800, 0xC00800, 0x000900, 0x400900, 0x800900, 0xC00900, 0x000A00,
    0x400A00, 0x800A00, 0xC00A00, 0x000B00, 0x400B00, 0x800B00, 0xC00B00,
    0x000C00, 0x400C00, 0x800C00, 0xC00C00, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
  [
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x3E0000, ERR_CHAR, ERR_CHAR, 0x340000,
    0x350000, 0x360000, 0x370000, 0x380000, 0x390000, 0x3A0000, 0x3B0000,
    0x3C0000, 0x3D0000, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, 0x000000, 0x010000, 0x020000, 0x030000, 0x040000,
    0x050000, 0x060000, 0x070000, 0x080000, 0x090000, 0x0A0000, 0x0B0000,
    0x0C0000, 0x0D0000, 0x0E0000, 0x0F0000, 0x100000, 0x110000, 0x120000,
    0x130000, 0x140000, 0x150000, 0x160000, 0x170000, 0x180000, 0x190000,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, 0x3F0000, ERR_CHAR, 0x1A0000,
    0x1B0000, 0x1C0000, 0x1D0000, 0x1E0000, 0x1F0000, 0x200000, 0x210000,
    0x220000, 0x230000, 0x240000, 0x250000, 0x260000, 0x270000, 0x280000,
    0x290000, 0x2A0000, 0x2B0000, 0x2C0000, 0x2D0000, 0x2E0000, 0x2F0000,
    0x300000, 0x310000, 0x320000, 0x330000, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
    ERR_CHAR, ERR_CHAR, ERR_CHAR, ERR_CHAR,
  ],
]

fn first_invalid(index: Int, a: Int, b: Int, c: Int, d: Int) -> Int {
  let add = if a >= ERR_CHAR {
    0
  } else if b >= ERR_CHAR {
    1
  } else if c >= ERR_CHAR {
    2
  } else if d >= ERR_CHAR {
    3
  } else {
    0
  }

  index + add
}

# Encodes a `ByteArray` as a base64 encoded `String`.
#
# This method uses the standard base64 alphabet and applies padding. For more
# control over the encoding process, use the `Encoder` type directly.
#
# # Examples
#
# ```inko
# import std.base64 (encode)
#
# encode('hello world'.to_byte_array) # => 'aGVsbG8gd29ybGQ='
# ```
fn pub encode(input: ref ByteArray) -> String {
  let base64 = ByteArray.new

  Encoder.new.encode(input, base64)
  base64.into_string
}

# Decodes a base64 encoded `ByteArray` into a raw `ByteArray`.
#
# This method uses the standard base64 alphabet and expects padding to be
# applied if necessary. For more control over the decoding process, use the
# `Decoder` type directly.
#
# # Examples
#
# ```inko
# import std.base64 (decode)
#
# decode('aGVsbG8gd29ybGQ='.to_byte_array)
#   .or_panic('failed to decode the input')
#   .to_string # => 'hello world'
# ```
fn pub decode(input: ref ByteArray) -> Result[ByteArray, DecodeError] {
  let plain = ByteArray.new

  try Decoder.new.decode(input, plain)
  Result.Ok(plain)
}

# A type for encoding raw input as a base64 sequence of bytes.
#
# Line wrapping isn't performed by this type, so if line sizes must be limited
# this must be done manually after encoding the data as base64.
#
# Padding is applied by default. This can be disabled by setting
# `Encoder.padding` to `false`:
#
# ```inko
# import std.base64 (Encoder)
#
# let enc = Encoder.new
#
# enc.padding = false
# ```
#
# # Examples
#
# Encoding input using the standard alphabet:
#
# ```inko
# import std.base64 (Encoder)
#
# let in = 'abcdefghijklmnopqrstuvwxyz0123456789|@{}/&#[]\\!?()<>=+*;\'"`:^%$~'.to_byte_array
# let out = ByteArray.new
#
# Encoder.new.encode(in, out)
# out.into_string #=> 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5fEB7fS8mI1tdXCE/KCk8Pj0rKjsnImA6XiUkfg=='
# ```
#
# Encoding input using the URL safe alphabet:
#
# ```inko
# import std.base64 (Encoder)
#
# let in = 'abcdefghijklmnopqrstuvwxyz0123456789|@{}/&#[]\\!?()<>=+*;\'"`:^%$~'.to_byte_array
# let out = ByteArray.new
#
# Encoder.url_safe.encode(in, out)
# out.into_string #=> 'YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5fEB7fS8mI1tdXCE_KCk8Pj0rKjsnImA6XiUkfg=='
# ```
class pub Encoder {
  let @table0: ref Array[Int]
  let @table1: ref Array[Int]
  let @table2: ref Array[Int]

  # If padding should be applied.
  let pub @padding: Bool

  # Returns an `Encoder` that uses the standard base64 alphabet.
  fn pub static new -> Encoder {
    Encoder(
      table0: ENCODE_STD.get(0),
      table1: ENCODE_STD.get(1),
      table2: ENCODE_STD.get(2),
      padding: true,
    )
  }

  # Returns an `Encoder` that uses the URL safe base64 alphabet.
  fn pub static url_safe -> Encoder {
    Encoder(
      table0: ENCODE_URL.get(0),
      table1: ENCODE_URL.get(1),
      table2: ENCODE_URL.get(2),
      padding: true,
    )
  }

  # Encodes the `input` `ByteArray` into a sequence of base64 encoded bytes,
  # appending the sequence to `into.`
  #
  # # Examples
  #
  # ```inko
  # import std.base64 (Encoder)
  #
  # let out = ByteArray.new
  #
  # Encoder.new.encode('hello world'.to_byte_array, out)
  # out.into_string #=> 'aGVsbG8gd29ybGQ='
  # ```
  fn pub encode(input: ref ByteArray, into: mut ByteArray) {
    # The implementation here is based on the base64 encoder found in Google
    # Chrome (https://github.com/chromium/chromium/blob/fd8a8914ca0183f0add65ae55f04e287543c7d4a/third_party/modp_b64/modp_b64.cc).
    let t0 = @table0
    let t1 = @table1
    let t2 = @table2
    let size = input.size
    let mut i = 0

    if size > 2 {
      let max = size - 2

      while i < max {
        let b0 = input.get(i)
        let b1 = input.get(i + 1)
        let b2 = input.get(i + 2)

        into.push(t0.get(b0))
        into.push(t1.get((b0 & 0x03 << 4) | (b1 >> 4 & 0x0F)))
        into.push(t1.get((b1 & 0x0F << 2) | (b2 >> 6 & 0x03)))
        into.push(t2.get(b2))

        i += 3
      }
    }

    match size - i {
      case 0 -> {}
      case 1 -> {
        let b0 = input.get(i)

        into.push(t0.get(b0))
        into.push(t1.get(b0 & 0x03 << 4))

        if @padding {
          into.push(PAD)
          into.push(PAD)
        }
      }
      case _ -> {
        let b0 = input.get(i)
        let b1 = input.get(i + 1)

        into.push(t0.get(b0))
        into.push(t1.get((b0 & 0x03 << 4) | (b1 >> 4 & 0x0F)))
        into.push(t2.get(b1 & 0x0F << 2))

        if @padding { into.push(PAD) }
      }
    }
  }
}

# An error produced when decoding a base64 encoded sequence of bytes.
class pub enum DecodeError {
  # The input size isn't a multiple of 4 bytes.
  case InvalidSize

  # The character at the given byte offset is invalid.
  case InvalidCharacter(Int)
}

impl ToString for DecodeError {
  fn pub to_string -> String {
    match self {
      case InvalidSize -> 'the input size is not a multiple of 4 bytes'
      case InvalidCharacter(n) -> 'the character at byte offset ${n} is invalid'
    }
  }
}

impl Format for DecodeError {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case InvalidSize -> formatter.tuple('InvalidSize').finish
      case InvalidCharacter(n) -> {
        formatter.tuple('InvalidCharacter').field(n).finish
      }
    }
  }
}

impl Equal[ref DecodeError] for DecodeError {
  fn pub ==(other: ref DecodeError) -> Bool {
    match (self, other) {
      case (InvalidSize, InvalidSize) -> true
      case (InvalidCharacter(a), InvalidCharacter(b)) -> a == b
      case _ -> false
    }
  }
}

# A type for decoding a base64 encoded sequence of bytes into a raw sequence of
# bytes.
#
# By default, padding is expected and input of which the size isn't a multiple
# of 4 is rejected. You can disable this by setting `Decoder.padding` to
# `false`:
#
# ```inko
# import std.base64 (Decoder)
#
# let dec = Decoder.new
#
# dec.padding = false
# ```
#
# # Examples
#
# Using the standard alphabet:
#
# ```inko
# import std.base64 (Decoder)
#
# let plain = ByteArray.new
#
# Decoder.new.decode('8J+Ygw=='.to_byte_array, into: plain)
# plain.into_string # => 'ðŸ˜ƒ'
# ```
#
# Using the URL safe alphabet:
#
# ```inko
# import std.base64 (Decoder)
#
# let plain = ByteArray.new
#
# Decoder.url_safe.decode('8J-Ygw=='.to_byte_array, into: plain)
# plain.into_string # => 'ðŸ˜ƒ'
# ```
class pub Decoder {
  let @table0: ref Array[Int]
  let @table1: ref Array[Int]
  let @table2: ref Array[Int]
  let @table3: ref Array[Int]

  # If padding is required or not.
  let pub @padding: Bool

  fn pub static new -> Decoder {
    Decoder(
      table0: DECODE_STD.get(0),
      table1: DECODE_STD.get(1),
      table2: DECODE_STD.get(2),
      table3: DECODE_STD.get(3),
      padding: true,
    )
  }

  fn pub static url_safe -> Decoder {
    Decoder(
      table0: DECODE_URL.get(0),
      table1: DECODE_URL.get(1),
      table2: DECODE_URL.get(2),
      table3: DECODE_URL.get(3),
      padding: true,
    )
  }

  # Decodes a sequence of base64 encoded bytes.
  #
  # # Errors
  #
  # A `DecodeError` is returned if:
  #
  # - Padding is required, but the input size isn't a multiple of 4
  # - The input contains invalid characters (e.g. whitespace)
  #
  # # Examples
  #
  # ```inko
  # import std.base64 (Decoder, Encoder)
  #
  # let base64 = ByteArray.new
  # let plain = ByteArray.new
  #
  # Encoder.new.encode('hello world'.to_byte_array, into: base64)
  # base64.to_string # => 'aGVsbG8gd29ybGQ='
  #
  # Decoder.new.decode(base64, into: plain) # => Result.Ok(nil)
  # plain.into_string # => 'hello world'
  # ```
  fn pub decode(
    input: ref ByteArray,
    into: mut ByteArray,
  ) -> Result[Nil, DecodeError] {
    if input.empty? { return Result.Ok(nil) }

    let mut size = input.size

    if @padding {
      if size < 4 or (size % 4 != 0) { throw DecodeError.InvalidSize }

      if input.get(size - 1) == PAD {
        size -= 1

        if input.get(size - 1) == PAD { size -= 1 }
      }
    }

    let t0 = @table0
    let t1 = @table1
    let t2 = @table2
    let t3 = @table3
    let leftover = size % 4
    let chunks = if leftover == 0 { size / 4 - 1 } else { size / 4 }
    let mut i = 0
    let mut y = 0

    while i < chunks {
      let a = t0.get(input.get(y))
      let b = t1.get(input.get(y + 1))
      let c = t2.get(input.get(y + 2))
      let d = t3.get(input.get(y + 3))
      let x = a | b | c | d

      if x >= ERR_CHAR {
        throw DecodeError.InvalidCharacter(first_invalid(y, a, b, c, d))
      }

      into.push(x & LO_MASK)
      into.push(x & MI_MASK >> 8)
      into.push(x & HI_MASK >> 16)
      i += 1
      y += 4
    }

    match leftover {
      case 0 -> {
        let a = t0.get(input.get(y))
        let b = t1.get(input.get(y + 1))
        let c = t2.get(input.get(y + 2))
        let d = t3.get(input.get(y + 3))
        let x = a | b | c | d

        if x >= ERR_CHAR {
          throw DecodeError.InvalidCharacter(first_invalid(y, a, b, c, d))
        }

        into.push(x & LO_MASK)
        into.push(x & MI_MASK >> 8)
        into.push(x & HI_MASK >> 16)
      }
      case 1 -> {
        let x = t0.get(input.get(y))

        if x >= ERR_CHAR { throw DecodeError.InvalidCharacter(y) }

        into.push(x & LO_MASK)
      }
      case 2 -> {
        let a = t0.get(input.get(y))
        let b = t1.get(input.get(y + 1))
        let x = a | b

        if x >= ERR_CHAR {
          throw DecodeError.InvalidCharacter(first_invalid(y, a, b, 0, 0))
        }

        into.push(x & LO_MASK)
      }
      case _ -> {
        let a = t0.get(input.get(y))
        let b = t1.get(input.get(y + 1))
        let c = t2.get(input.get(y + 2))
        let x = a | b | c

        if x >= ERR_CHAR {
          throw DecodeError.InvalidCharacter(first_invalid(y, a, b, c, 0))
        }

        into.push(x & LO_MASK)
        into.push(x & MI_MASK >> 8)
      }
    }

    Result.Ok(nil)
  }
}
