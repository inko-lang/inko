# MIME type detection.
import std.bytes (Bytes, Slice, ToSlice)
import std.cmp (Equal)
import std.fmt (Format, Formatter)
import std.iter (Stream)
import std.map (MissingKey)
import std.mime.data
import std.mime.phf
import std.net.http.header.values (
  Items, Parameter, ParameterValue, Parameters, split_item,
)
import std.string (ToString)

# A MIME type.
#
# A `Mime` value consists of two `std.bytes.Slice[String]` values: one for the
# primary type and one for the subtype. A `Mime` stores slices internally such
# that it doesn't need to allocate new `String` values for these components.
#
# This does mean that if you parse a very large `String` into a `Mime` value,
# the entire `String` is kept around until the `Mime` value is dropped.
type pub Mime {
  # The primary type (i.e. `text` in `text/plain`) of the MIME type.
  let pub @type: Slice[String]

  # The subtype (i.e. `plain` in `text/plain`) of the MIME type.
  let pub @subtype: Slice[String]

  # Any additional parameters, such as a `charset` parameter.
  let pub @parameters: Map[Parameter[String], ParameterValue[String]]

  # Returns a new `Mime` type from the given `String`.
  #
  # This method is meant to be used with statically known strings and not
  # user-provided input.
  #
  # # Panics
  #
  # This method panics if `value` doesn't use the format `type/subtype`.
  #
  # # Examples
  #
  # ```inko
  # Mime.new('text/plain') # => Mime('text/plain')
  # ```
  fn pub inline static new(value: String) -> Self {
    parse(value).or_panic_with('the MIME type is invalid')
  }

  # Parses a `Mime` from a `String` or `Slice[String]`.
  #
  # # Errors
  #
  # If the input is invalid, an `Option.None` is returned.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # Mime.parse('text/plain') # => Option.Some(Mime('text/plain'))
  # Mime.parse('foo')        # => Option.None
  # ```
  fn pub static parse[S: ToSlice[String]](value: ref S) -> Option[Mime] {
    match value.to_slice.split_once('/') {
      case Some((typ, sub)) -> {
        let parameters = Map.new
        let sub = match split_item(sub) {
          case (sub, Some(pars)) -> {
            for res in Parameters.new(pars) {
              match res {
                case Ok((key, val)) -> parameters.set(key, val)
                case _ -> break
              }
            }

            sub
          }
          case (sub, _) -> sub
        }

        Option.Some(Self(type: typ, subtype: sub, parameters: parameters))
      }
      case _ -> Option.None
    }
  }

  # Parses a list of MIME types (e.g. as stored in an HTTP `Accept` header).
  #
  # The iterator stops when encountering an invalid MIME type.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # Mime
  #   .parse_list('text/plain, text/html')
  #   .to_array # => [Mime('text/plain'), Mime('text/html')]
  # ```
  fn pub static parse_list[S: ToSlice[String]](value: ref S) -> Stream[Mime] {
    let items = Items.new(value)

    Stream.new(fn move {
      let (name, pars) = match items.next {
        case Some((name, Some(map))) -> (name, map)
        case Some((name, _)) -> (name, Map.new)
        case _ -> return Option.None
      }

      match name.split_once('/') {
        case Some((typ, sub)) -> {
          Option.Some(Self(type: typ, subtype: sub, parameters: pars))
        }
        case _ -> Option.None
      }
    })
  }

  # Returns the value of the given parameter.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # let mime = Mime.parse('text/plain; charset=utf-8; q=0.5').get
  #
  # mime.get('charset').map(fn (v) { v.to_string }) # => Result.Ok('utf-8')
  # ```
  fn pub get(key: String) -> Result[String, MissingKey[String]] {
    match @parameters.get(Parameter(key.to_slice)) {
      case Ok(v) -> Result.Ok(v.to_string)
      case _ -> Result.Error(MissingKey.new(key))
    }
  }

  # Returns the value of the `charset` parameter, if given.
  #
  # This method returns an `Option` given that in most cases the parameter is
  # expected to be absent, instead of this being unexpected.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # let mime = Mime.parse('text/plain; charset=utf-8; q=0.5').get
  #
  # mime.charset.get.to_string # => 'utf-8'
  # ```
  fn pub charset -> Option[String] {
    match get('charset') {
      case Ok(v) -> Option.Some(v.to_string)
      case _ -> Option.None
    }
  }

  # Returns the primary (= first) MIME type for the given file extension.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # Mime.from_extension('jpg')     # => Option.Some(Mime('image/jpeg'))
  # Mime.from_extension('txt')     # => Option.Some(Mime('text/plain'))
  # Mime.from_extension('kittens') # => Option.None
  # ```
  fn pub static from_extension[B: Bytes](extension: ref B) -> Option[Mime] {
    match phf.index_of(extension) {
      case -1 -> Option.None
      case i -> Option.Some(Mime.new(data.TYPES.get(i).or_panic.first.get))
    }
  }
}

impl Format for Mime {
  fn pub fmt(formatter: mut Formatter) {
    formatter.tuple('Mime').field(to_string).finish
  }
}

impl Equal for Mime {
  fn pub ==(other: ref Self) -> Bool {
    @type == other.type
      and @subtype == other.subtype
      and @parameters == other.parameters
  }
}

impl ToString for Mime {
  fn pub to_string -> String {
    let buf = ByteArray.new

    buf.append(@type)
    buf.append('/')
    buf.append(@subtype)

    for (key, val) in @parameters.iter {
      buf.append('; ')
      buf.append(key.to_string)
      buf.append('=')
      val.encode(buf)
    }

    buf.into_string
  }
}
