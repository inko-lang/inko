# MIME type detection.
import std.bytes (Bytes, Slice, ToSlice)
import std.cmp (Equal)
import std.fmt (Format, Formatter)
import std.iter (Stream)
import std.map (MissingKey)
import std.mime.data
import std.mime.phf
import std.string (ToString)

let SPACE = 32
let DQUOTE = 34
let SCOL = 59
let EQ = 61

fn split_item[B: Bytes](input: Slice[B]) -> (Slice[B], Option[Slice[B]]) {
  match input.split_once(';') {
    case Some((item, pars)) -> (item.trim, Option.Some(pars.trim))
    case _ -> (input, Option.None)
  }
}

# Parses a set of key=value parameters as used by MIME types and HTTP headers.
#
# This is a separate method such that it can be used by other parts of the
# standard library, such as the `std.net.http` modules.
fn parameters[B: Bytes, S: ToSlice[B]](
  input: ref S,
) -> Stream[Result[(Slice[B], Slice[B]), Nil]] {
  let input = input.to_slice
  let mut idx = 0
  let max = input.size

  # Values may contain ";" when quoted, so we can't just use Slice.split and
  # related methods.
  Stream.new(fn move {
    # Skip the ";" and any spaces at the start of each parameter pair.
    while idx < max {
      match input.get(idx).or_panic {
        case SPACE or SCOL -> idx += 1
        case _ -> break
      }
    }

    let name_start = idx

    while idx < max {
      match input.get(idx).or_panic {
        case SPACE -> return Option.Some(Result.Error(nil))
        case EQ -> break
        case _ -> idx += 1
      }
    }

    # No name means we've reached the end.
    if idx - name_start == 0 { return Option.None }

    let name = input.slice(name_start, idx := idx + 1)

    # We've reached the end of the last parameter without a value.
    if idx >= max {
      let val = input.slice(0, 0)

      return Option.Some(Result.Ok((name, val)))
    }

    let mut quoted = match input.get(idx) {
      case Ok(DQUOTE) -> {
        idx += 1
        true
      }
      case _ -> false
    }

    let val_start = idx
    let mut val_end = idx

    while idx < max {
      match input.get(idx).or_panic {
        case DQUOTE if quoted -> {
          quoted = false
          idx += 1
          break
        }
        case DQUOTE -> return Option.Some(Result.Error(nil))
        case SCOL if quoted -> {}
        case SCOL -> {
          idx += 1
          break
        }
        case _ -> {}
      }

      val_end += 1
      idx += 1
    }

    # We reached the end before the closing quote.
    if quoted { return Option.Some(Result.Error(nil)) }

    let val = input.slice(val_start, val_end)

    Option.Some(Result.Ok((name, val)))
  })
}

# A MIME type.
#
# A `Mime` value consists of two `std.bytes.Slice[String]` values: one for the
# primary type and one for the subtype. A `Mime` stores slices internally such
# that it doesn't need to allocate new `String` values for these components.
#
# This does mean that if you parse a very large `String` into a `Mime` value,
# the entire `String` is kept around until the `Mime` value is dropped.
type pub Mime {
  # The primary type (i.e. `text` in `text/plain`) of the MIME type.
  let pub @type: Slice[String]

  # The subtype (i.e. `plain` in `text/plain`) of the MIME type.
  let pub @subtype: Slice[String]

  # Any additional parameters, such as a `charset` parameter.
  let pub @parameters: Map[Slice[String], Slice[String]]

  # Returns a new `Mime` type from the given `String`.
  #
  # This method is meant to be used with statically known strings and not
  # user-provided input.
  #
  # # Panics
  #
  # This method panics if `value` doesn't use the format `type/subtype`.
  #
  # # Examples
  #
  # ```inko
  # Mime.new('text/plain') # => Mime('text/plain')
  # ```
  fn pub inline static new(value: String) -> Self {
    parse(value).or_panic_with('the MIME type is invalid')
  }

  # Parses a `Mime` from a `String` or `Slice[String]`.
  #
  # # Errors
  #
  # If the input is invalid, an `Option.None` is returned.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # Mime.parse('text/plain') # => Option.Some(Mime('text/plain'))
  # Mime.parse('foo')        # => Option.None
  # ```
  fn pub static parse[S: ToSlice[String]](value: ref S) -> Option[Mime] {
    match value.to_slice.split_once('/') {
      case Some((typ, sub)) -> {
        let parameters = Map.new
        let sub = match split_item(sub) {
          case (sub, Some(pars)) -> {
            for res in parameters(pars) {
              match res {
                case Ok((key, val)) -> parameters.set(key, val)
                case _ -> break
              }
            }

            sub
          }
          case (sub, _) -> sub
        }

        Option.Some(Self(type: typ, subtype: sub, parameters: parameters))
      }
      case _ -> Option.None
    }
  }

  # Returns the value of the given parameter.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # let mime = Mime.parse('text/plain; charset=utf-8; q=0.5').get
  #
  # mime.get('charset').map(fn (v) { v.to_string }) # => Result.Ok('utf-8')
  # ```
  fn pub get(key: String) -> Result[Slice[String], MissingKey[String]] {
    match @parameters.get(key.slice(0, key.size)) {
      case Ok(v) -> Result.Ok(v.clone)
      case _ -> Result.Error(MissingKey.new(key))
    }
  }

  # Returns the primary (= first) MIME type for the given file extension.
  #
  # # Examples
  #
  # ```inko
  # import std.mime (Mime)
  #
  # Mime.from_extension('jpg')     # => Option.Some(Mime('image/jpeg'))
  # Mime.from_extension('txt')     # => Option.Some(Mime('text/plain'))
  # Mime.from_extension('kittens') # => Option.None
  # ```
  fn pub static from_extension[B: Bytes](extension: ref B) -> Option[Mime] {
    match phf.index_of(extension) {
      case -1 -> Option.None
      case i -> Option.Some(Mime.new(data.TYPES.get(i).or_panic.first.get))
    }
  }
}

impl Format for Mime {
  fn pub fmt(formatter: mut Formatter) {
    formatter.tuple('Mime').field(to_string).finish
  }
}

impl Equal for Mime {
  fn pub ==(other: ref Self) -> Bool {
    @type == other.type
      and @subtype == other.subtype
      and @parameters == other.parameters
  }
}

impl ToString for Mime {
  fn pub to_string -> String {
    let buf = ByteArray.new

    buf.append(@type)
    buf.append('/')
    buf.append(@subtype)

    for (key, val) in @parameters.iter {
      buf.append('; ')
      buf.append(key)
      buf.append('=')
      buf.append(val)
    }

    buf.into_string
  }
}
