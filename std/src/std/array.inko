# An ordered, integer-indexed generic collection of values.
import std::clone::Clone
import std::cmp::(Compare, Contains, Equal, Ordering, min)
import std::drop::Drop
import std::fmt::(Format, Formatter)
import std::hash::(Hash, Hasher)
import std::iter::(Enum, Iter)
import std::option::Option
import std::rand::Shuffle

class extern AnyResult {
  let @tag: Int
  let @value: Any
}

fn extern inko_array_reserve(array: Any, length: Int)
fn extern inko_array_set(array: Any, index: Int, value: Any) -> Any
fn extern inko_array_get(array: Any, index: Int) -> Any
fn extern inko_array_clear(array: Any)
fn extern inko_array_pop(array: Any) -> AnyResult
fn extern inko_array_remove(array: Any, index: Int) -> Any
fn extern inko_array_capacity(state: Pointer[Int8], array: Any) -> Int
fn extern inko_array_drop(state: Pointer[Int8], array: Any)
fn extern inko_array_length(state: Pointer[Int8], array: Any) -> Int

fn stable_sort[T: Compare[T]](
  array: mut Array[T],
  compare: mut fn (ref T, ref T) -> Bool,
) {
  let len = array.length

  # The algorithm here is the recursive merge sort algorithm. While faster
  # algorithms exist (e.g. Timsort, at least in certain cases), merge sort is
  # the easiest to implement and still offers good performance.
  if len <= 1 { return }

  # We don't set a length for `tmp` so we don't drop any of the temporary
  # values in it, as that would result in `self` being left with invalid
  # values. This works because merge() doesn't perform any bounds checking.
  let tmp: Array[T] = Array.with_capacity(len)

  len.times fn (i) {
    inko_array_set(tmp, i, inko_array_get(array, i))
  }

  merge_sort(tmp, array, start: 0, end: len, compare: compare)
}

fn merge_sort[T: Compare[T]](
  a: mut Array[T],
  b: mut Array[T],
  start: Int,
  end: Int,
  compare: mut fn (ref T, ref T) -> Bool
) {
  if end - start <= 1 { return }

  # https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html
  let mid = start.wrapping_add(end) >>> 1

  merge_sort(b, a, start, mid, compare)
  merge_sort(b, a, mid, end, compare)

  let mut i = start
  let mut j = mid
  let mut k = start

  while k < end {
    if i < mid
      and (j >= end or compare.call(a.get_unchecked(i), a.get_unchecked(j)))
    {
      inko_array_set(b, k, inko_array_get(a, i))
      i += 1
    } else {
      inko_array_set(b, k, inko_array_get(a, j))
      j += 1
    }

    k += 1
  }
}

# Checks if `index` is in the range of zero up to (but excluding) `length`.
#
# # Panics
#
# This method panics if the index is out of bounds.
fn pub bounds_check(index: Int, length: Int) {
  if index >= 0 and index < length { return }

  _INKO.panic("The index {index} is out of bounds (length: {length})")
}

# An ordered, integer-indexed generic collection of values.
#
# Accessing values in an `Array` is a constant-time operation.
#
# Arrays are created using the array literal syntax, instead of using a method.
# Here's how you'd create an empty Array:
#
#     []
#
# And here's how you'd create an Array with values:
#
#     [10, 20, 30]
#
# All values in an array must be of the same type, and the array's value type is
# based on the type of the first value.
class builtin Array[T] {
  # Returns a new `Array` with enough space for at least `amount` values.
  #
  # The actual capacity may be greater than the given value.
  fn pub static with_capacity(amount: Int) -> Array[T] {
    let vals = []

    inko_array_reserve(vals, amount)
    vals
  }

  # Returns an array filled with a certain amount of values.
  #
  # The `times` argument specifies how many times the `with` argument must
  # exist in the array.
  #
  # # Examples
  #
  #     Array.filled(with: 0, times: 4) # => [0, 0, 0, 0]
  fn pub static filled[V: Clone[V]](with: V, times: Int) -> Array[V] {
    if times == 0 { return [] }

    let array = with_capacity(times)
    let temp = ref with

    (times - 1).times fn (_) { array.push(temp.clone) }
    array.push(with)
    array
  }

  # Removes all values in the Array.
  #
  # # Examples
  #
  #     let array = [10, 20, 30]
  #
  #     array.clear
  #     array.empty? # => true
  fn pub mut clear {
    let mut index = 0
    let max = length

    while index < max {
      inko_array_get(self, (index := index + 1)) as T
    }

    inko_array_clear(self)
  }

  # Pushes a value to the back of the Array.
  #
  # # Examples
  #
  # Pushing a value into an Array:
  #
  #     let array = []
  #
  #     array.push(10) # => Nil
  #     array[0]       # => 10
  fn pub mut push(value: T) {
    _INKO.array_push(self, value)
    _INKO.moved(value)
  }

  # Removes a value from the back of the Array, returning the removed value.
  #
  # If no value was found, a None is returned instead.
  #
  # # Examples
  #
  # Popping an existing value:
  #
  #     let array = [10]
  #
  #     array.pop    # => Option.Some(10)
  #     array.empty? # => true
  #
  # Popping a value when the Array is empty:
  #
  #     let array = []
  #
  #     array.pop # => Option.None
  fn pub mut pop -> Option[T] {
    match inko_array_pop(self) {
      case { @tag = 0, @value = v } -> Option.Some(v as T)
      case _ -> Option.None
    }
  }

  # Removes the value at the given index, returning the removed value.
  #
  # # Examples
  #
  # Removing an existing value will result in the value being removed from the
  # Array and returned:
  #
  #     let array = [10]
  #
  #     array.remove_at(0) # => 10
  #     array.empty?       # => true
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  fn pub mut remove_at(index: Int) -> T {
    bounds_check(index, length)
    inko_array_remove(self, index) as T
  }

  # Returns an optional immutable reference to the value at the given index.
  #
  # # Examples
  #
  # Retrieving an existing value:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt(0) # => Option.Some(ref 10)
  #
  # Retrieving a value from a non-existing index:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt(5) # => Option.None
  fn pub opt(index: Int) -> Option[ref T] {
    if index < 0 or index >= length { return Option.None }

    Option.Some(get_unchecked(index))
  }

  # Returns an immutable reference to the value at the given index.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  #     let numbers = [10, 20]
  #
  #     numbers.get(0) # => 10
  fn pub get(index: Int) -> ref T {
    bounds_check(index, length)
    get_unchecked(index)
  }

  # Stores a value at the given index.
  #
  # If a value is already present at the given index, it's dropped before the
  # new value overwrites it.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  # Setting an index to a value:
  #
  #     let array = []
  #
  #     array.set(0, 10)
  #     array # => [10]
  fn pub mut set(index: Int, value: T) {
    bounds_check(index, length)
    inko_array_set(self, index, value) as T
    _INKO.moved(value)
  }

  # Inserts the value at the given index, returning the old value.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  #     let numbers = [10, 20, 30]
  #
  #     numbers.swap(index: 1, with: 40) # => 20
  #     numbers                          # => [10, 40, 30]
  fn pub mut swap(index: Int, with: T) -> T {
    bounds_check(index, length)

    let result = inko_array_set(self, index, with) as T

    _INKO.moved(with)
    result
  }

  # Returns an iterator that yields immutable references to the values in
  # `self`.
  fn pub iter -> Iter[ref T] {
    Enum.indexed(length) fn (index) { get(index) }
  }

  # Returns an `Iter` that iterates over all values in `self`, returning them
  # by value.
  #
  # # Examples
  #
  #     let numbers = [10, 20, 30]
  #     let iter = numbers.into_iter
  #
  #     iter.next # => Option.Some(10)
  #     iter.next # => Option.Some(20)
  #     iter.next # => Option.Some(30)
  #     iter.next # => Option.None
  fn pub move into_iter -> IntoIter[T] {
    IntoIter { @array = self, @index = 0 }
  }

  # Returns an `Iter` that iterates over all values in `self` in reverse
  # order.
  #
  # # Examples
  #
  # Iterating over an `Array` in reverse order:
  #
  #     let numbers = [10, 20, 30]
  #     let iter = numbers.reverse_iter
  #
  #     iter.next # => Option.Some(30)
  #     iter.next # => Option.Some(20)
  #     iter.next # => Option.Some(10)
  #     iter.next # => Option.None
  fn pub reverse_iter -> Iter[ref T] {
    let mut index = length - 1

    Enum.new fn move {
      if index > -1 {
        Option.Some(get(index := index - 1))
      } else {
        Option.None
      }
    }
  }

  # Appends the values of the given `Array` to `self`.
  #
  # # Examples
  #
  # Appending one `Array` to another:
  #
  #     let numbers = [10, 20, 30]
  #
  #     numbers.append([40, 50])
  #
  #     numbers.length # => 5
  fn pub mut append(other: Array[T]) {
    other.into_iter.each fn (v) { push(v) }
  }

  # Returns the number of values in this Array.
  #
  # # Examples
  #
  # Getting the length of an empty Array:
  #
  #     [].length # => 0
  #
  # Getting the length of an Array with values:
  #
  #     [10].length # => 1
  fn pub length -> Int {
    inko_array_length(_INKO.state, self)
  }

  # Returns the number of values that can be stored in `self` before `self`
  # needs to be resized.
  #
  # # Examples
  #
  #     Array.with_capacity(2).capacity # => 4
  fn pub capacity -> Int {
    inko_array_capacity(_INKO.state, self)
  }

  # Returns `true` if `self` is empty.
  #
  # # Examples
  #
  #     [10].empty? # => false
  #     [].empty?     # => true
  fn pub empty? -> Bool {
    length == 0
  }

  # Sorts the values in `self` such that they are in a random order.
  #
  # # Examples
  #
  #     let a = [10, 20]
  #
  #     a.shuffle
  #     a # => [20, 10]
  fn pub mut shuffle {
    Shuffle.new.sort(self)
  }

  # Reverses `self` in-place
  #
  # # Examples
  #
  #     let a = [10, 20, 30]
  #
  #     a.reverse
  #
  #     a # => [30, 20, 10]
  fn pub mut reverse {
    let mut a = 0
    let mut b = length - 1

    while a < b {
      let a_val = inko_array_get(self, a)

      inko_array_set(self, a, inko_array_set(self, b, a_val))
      a += 1
      b -= 1
    }
  }

  fn get_unchecked(index: Int) -> ref T {
    (ref inko_array_get(self, index)) as ref T
  }
}

impl Array if T: mut {
  # Returns an optional mutable reference to the value at the given index.
  #
  # # Examples
  #
  # Retrieving an existing value:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt_mut(0) # => Option.Some(mut 10)
  #
  # Retrieving a value from a non-existing index:
  #
  #     let numbers = [10, 20]
  #
  #     numbers.opt_mut(5) # => Option.None
  fn pub mut opt_mut(index: Int) -> Option[mut T] {
    if index < 0 or index >= length { return Option.None }

    Option.Some(get_unchecked_mut(index))
  }

  # Returns a mutable reference to the value at the given index.
  #
  # # Panics
  #
  # This method panics if the index is out of bounds.
  #
  # # Examples
  #
  #     let numbers = [10, 20]
  #
  #     numbers.get_mut(0) # => 10
  fn pub mut get_mut(index: Int) -> mut T {
    bounds_check(index, length)
    get_unchecked_mut(index)
  }

  # Returns an iterator that yields mutable references to the values in `self`.
  fn pub mut iter_mut -> Iter[mut T] {
    Enum.indexed(length) fn (index) { get_mut(index) }
  }

  fn mut get_unchecked_mut(index: Int) -> mut T {
    (mut inko_array_get(self, index)) as mut T
  }
}

impl Drop for Array {
  fn mut drop {
    let mut index = 0

    while index < length {
      inko_array_get(self, index := index + 1) as T
    }

    inko_array_drop(_INKO.state, self)
  }
}

impl Contains[T] for Array if T: Equal[T] {
  # Returns `true` if `self` contains the given value.
  #
  # # Examples
  #
  # Checking if an `Array` contains a value:
  #
  #     [10, 20, 30].contains?(10) # => true
  fn pub contains?(value: ref T) -> Bool {
    iter.any? fn (ours) { ours == value }
  }
}

impl Clone[Array[T]] for Array if T: Clone[T] {
  fn pub clone -> Array[T] {
    let copy = []
    let mut index = 0
    let max = length

    while index < max { copy.push(get(index := index + 1).clone) }

    copy
  }
}

impl Equal[Array[T]] for Array if T: Equal[T] {
  # Returns `true` if `self` and the given `Array` are identical.
  #
  # # Examples
  #
  # Comparing two identical arrays:
  #
  #     [10, 20, 30] == [10, 20, 30] # => true
  #
  # Comparing two arrays with a different length:
  #
  #     [10] == [10, 20] # => false
  #
  # Comparing two arrays with the same length but with different values:
  #
  #     [10, 20] == [20, 10] # => false
  fn pub ==(other: ref Array[T]) -> Bool {
    if length != other.length { return false }

    let mut index = 0
    let max = length

    while index < max {
      let ours = get(index)
      let theirs = other.get(index)

      if ours != theirs { return false }

      index += 1
    }

    true
  }
}

impl Hash for Array if T: Hash {
  fn pub hash(hasher: mut Hasher) {
    let mut index = 0
    let max = length

    while index < max { get(index := index + 1).hash(hasher) }
  }
}

impl Format for Array if T: Format {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write('[')

    iter.each_with_index fn (index, value) {
      if index > 0 { formatter.write(', ') }

      value.fmt(formatter)
    }

    formatter.write(']')
  }
}

impl Array if T: Compare[T] {
  # Sorts the values in `self` in ascending order.
  #
  # This method performs a stable sort, meaning it maintains the relative order
  # of duplicate values.
  #
  # # Examples
  #
  #     let nums = [0, 3, 3, 5, 9, 1]
  #
  #     nums.sort
  #     nums # => [0, 1, 3, 3, 5, 9]
  fn pub mut sort {
    stable_sort(self) fn (a, b) { a <= b }
  }

  # Sorts the values in `self` using a custom comparison closure.
  #
  # Like `Array.sort`, this method performs a stable sort.
  #
  # # Examples
  #
  #     let nums = [0, 3, 3, 5, 9, 1]
  #
  #     nums.sort_by fn (a, b) { b.cmp(a) }
  #     nums # => [9, 5, 3, 3, 1, 0]
  fn pub mut sort_by(block: fn (ref T, ref T) -> Ordering) {
    stable_sort(self) fn (a, b) {
      match block.call(a, b) {
        case Less or Equal -> true
        case _ -> false
      }
    }
  }
}

# An iterator that moves values out of an `Array`.
#
# When this iterator is dropped, any values not yet moved out of the `Array` are
# dropped.
class pub IntoIter[T] {
  # The Array is typed as `Any` so we don't run its destructor. This way we can
  # drop an `IntoIter` even when some values have been moved out of the Array.
  let @array: Any
  let @index: Int

  fn mut take_next -> T {
    inko_array_get(@array, @index := @index + 1) as T
  }

  fn length -> Int {
    inko_array_length(_INKO.state, @array)
  }
}

impl Drop for IntoIter {
  fn mut drop {
    while @index < length { take_next }

    inko_array_drop(_INKO.state, @array)
  }
}

impl Iter[T] for IntoIter {
  fn pub mut next -> Option[T] {
    if @index < length { Option.Some(take_next) } else { Option.None }
  }
}
