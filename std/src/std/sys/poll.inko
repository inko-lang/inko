import std.io (Error)
import std.sys.freebsd.poll (self as sys) if freebsd
import std.sys.linux.poll (self as sys) if linux
import std.sys.mac.poll (self as sys) if mac

let PRIMARY = 1
let SECONDARY = 2

# A value that signals a source isn't registered with a poller.
let NOT_REGISTERED = -1

# A value that signals the lack of a deadline.
let NO_DEADLINE = -1

fn extern inko_poll(
  state: Pointer[Uint8],
  process: Pointer[Uint8],
  poll: Pointer[Poll],
  interest: Int,
  deadline: Int,
) -> Bool

# A type which can be polled by the runtime.
type extern Poll {
  # The file descriptor of the socket.
  let @fd: Int32

  # The ID of the poller the source is registered with.
  let @registered: Uint8
}

fn inline new(fd: Int32) -> Poll {
  Poll(fd: fd, registered: NOT_REGISTERED as Uint8)
}

fn inline poll_raw(poll: Pointer[Poll], deadline: Int, write: Bool) -> Bool {
  inko_poll(_INKO.state, _INKO.process, poll, write.to_int, deadline)
}

fn inline poll(
  poll: Pointer[Poll],
  deadline: Int,
  write: Bool,
) -> Result[Nil, Error] {
  if poll_raw(poll, deadline, write) {
    Result.Ok(nil)
  } else {
    throw Error.TimedOut
  }
}

type inline Poller {
  let @inner: sys.Poller

  fn static new -> Result[Self, Error] {
    Result.Ok(Self(try sys.Poller.new))
  }

  fn mut add(
    primary: Pointer[Poll],
    secondary: Pointer[Poll],
  ) -> Result[Nil, Error] {
    try @inner.add(primary, id: PRIMARY)
    @inner.add(secondary, id: SECONDARY)
  }

  fn mut poll(deadline: Int) -> Result[Nil, Error] {
    match @inner.poll(deadline) {
      case Ok((1, PRIMARY)) -> Result.Ok(nil)
      case Ok(_) -> throw Error.Interrupted
      case Error(e) -> throw e
    }
  }
}
