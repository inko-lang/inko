import std.io (Error)
import std.libc.mac.amd64 (self as sys) if amd64
import std.libc.mac.arm64 (self as sys) if arm64
import std.reflect (size_of)

let AF_INET = 2
let AF_INET6 = 30
let AF_UNIX = 1
let AF_UNSPEC = 0
let AI_ADDRCONFIG = 0x400
let AI_V4MAPPED = 0x800
let AT_FDCWD = -2
let CLOCK_REALTIME = 0
let COPYFILE_ALL = 15
let DT_DIR = 4
let DT_LNK = 10
let DT_REG = 8
let EACCES = 13
let EADDRINUSE = 48
let EADDRNOTAVAIL = 49
let EAGAIN = 35
let EAI_ADDRFAMILY = 1
let EAI_AGAIN = 2
let EAI_FAIL = 4
let EAI_NONAME = 8
let EAI_SERVICE = 9
let EAI_SYSTEM = 11
let EBADF = 9
let EBUSY = 16
let ECONNABORTED = 53
let ECONNREFUSED = 61
let ECONNRESET = 54
let EDEADLK = 11
let EEXIST = 17
let EFAULT = 14
let EFBIG = 27
let EHOSTUNREACH = 65
let EINPROGRESS = 36
let EINTR = 4
let EINVAL = 22
let EIO = 5
let EISCONN = 56
let EISDIR = 21
let ENAMETOOLONG = 63
let ENETDOWN = 50
let ENETUNREACH = 51
let ENOENT = 2
let ENOMEM = 12
let ENOSPC = 28
let ENOTCONN = 57
let ENOTDIR = 20
let ENOTEMPTY = 66
let ENOTSUP = 45
let EOPNOTSUPP = 102
let EPERM = 1
let EPIPE = 32
let ERANGE = 34
let EROFS = 30
let ESPIPE = 29
let ETIME = 101
let ETIMEDOUT = 60
let EVFILT_READ = -1
let EV_ADD = 0x1
let EV_CLEAR = 0x20
let EV_RECEIPT = 0x040
let EXDEV = 18
let FD_CLOEXEC = 1
let F_BARRIERFSYNC = 85
let F_DUPFD_CLOEXEC = 67
let F_FULLFSYNC = 51
let F_GETFD = 1
let F_GETFL = 3
let F_SETFD = 2
let F_SETFL = 4
let IPPROTO_IP = 0
let IPPROTO_IPV6 = 41
let IPPROTO_TCP = 6
let IPV6_V6ONLY = 27
let IP_TTL = 4
let MSG_NOSIGNAL = 0x80000
let O_APPEND = 0x8
let O_CLOEXEC = 0x1000000
let O_CREAT = 0x200
let O_NONBLOCK = 0x4
let O_RDONLY = 0
let O_RDWR = 0x2
let O_TRUNC = 0x400
let O_WRONLY = 0x1
let POSIX_SPAWN_SETSIGDEF = 0x04
let POSIX_SPAWN_SETSIGMASK = 0x08
let SEEK_CUR = 1
let SEEK_END = 2
let SEEK_SET = 0
let SHUT_RD = 0
let SHUT_RDWR = 2
let SHUT_WR = 1
let SIGABRT = 6
let SIGCHLD = 20
let SIGCONT = 19
let SIGHUP = 1
let SIGINT = 2
let SIGKILL = 9
let SIGQUIT = 3
let SIGTERM = 15
let SIGTSTP = 18
let SIGTTIN = 21
let SIGTTOU = 22
let SIGUSR1 = 30
let SIGUSR2 = 31
let SIGWINCH = 28
let SIGXFSZ = 25
let SOCK_DGRAM = 2
let SOCK_RAW = 3
let SOCK_STREAM = 1
let SOL_SOCKET = 0xFFFF
let SO_BROADCAST = 0x20
let SO_ERROR = 0x1007
let SO_KEEPALIVE = 0x8
let SO_LINGER_SEC = 0x1080
let SO_RCVBUF = 0x1002
let SO_REUSEADDR = 0x4
let SO_REUSEPORT = 0x200
let SO_SNDBUF = 0x1001
let S_IFDIR = 0x4000
let S_IFLNK = 0xA000
let S_IFMT = 0xF000
let S_IFREG = 0x8000
let TCP_KEEPALIVE = 16
let TCP_KEEPINTVL = 257
let TCP_NODELAY = 1
let WNOHANG = 0x00000001

# macOS uses TCP_KEEPALIVE instead of TCP_KEEPIDLE. The latter is apparently too
# mainstream. We alias them here such std.libc doesn't need to know about this.
let TCP_KEEPIDLE = TCP_KEEPALIVE

# For macOS we need to use `SO_LINGER_SEC` to control the time in seconds
# instead of ticks, and `SO_LINGER` itself isn't useful.
let SO_LINGER = SO_LINGER_SEC

type extern Dirent {
  let @d_ino: Uint64
  let @d_seekoff: Uint64
  let @d_reclen: Uint16
  let @d_namlen: Uint16
  let @d_type: Uint8
}

type extern StatBuf {
  let @st_dev: Int32
  let @st_mode: Uint16
  let @st_nlink: Uint16
  let @st_ino: Uint64
  let @st_uid: Uint32
  let @st_gid: Uint32
  let @st_rdev: Int32
  let @st_atime: Int64
  let @st_atime_nsec: Int64
  let @st_mtime: Int64
  let @st_mtime_nsec: Int64
  let @st_ctime: Int64
  let @st_ctime_nsec: Int64
  let @st_birthtime: Int64
  let @st_birthtime_nsec: Int64
  let @st_size: Int64
  let @st_blocks: Int64
  let @st_blksize: Int32
  let @st_flags: Uint32
  let @st_gen: Uint32
  let @st_lspare: Int32
  let @st_qspare0: Int64
  let @st_qspare1: Int64
}

type extern Pipes {
  let @reader: Int32
  let @writer: Int32
}

type extern SigSet {
  let @inner: Uint32
}

type extern PosixSpawnAttrs {
  let @inner: Pointer[Uint8]
}

type extern PosixSpawnFileActions {
  let @inner: Pointer[Uint8]
}

type extern SockAddrIn {
  let @sin_len: Uint8
  let @sin_family: Uint8
  let @sin_port: Uint16
  let @sin_addr: Uint32
  let @sin_zero: Uint64
}

type extern SockAddrIn6 {
  let @sin6_len: Uint8
  let @sin6_family: Uint8
  let @sin6_port: Uint16
  let @sin6_flowinfo: Uint32
  let @sin6_addr0: Uint32
  let @sin6_addr1: Uint32
  let @sin6_addr2: Uint32
  let @sin6_addr3: Uint32
  let @sin6_scope_id: Uint32
}

type extern SockAddrUn {
  let @sun_len: Uint8
  let @sun_family: Uint8
  let @sun_path0: Uint8
  let @sun_path1: Uint8
  let @sun_path2: Uint8
  let @sun_path3: Uint8
  let @sun_path4: Uint8
  let @sun_path5: Uint8
  let @sun_path6: Uint8
  let @sun_path7: Uint8
  let @sun_path8: Uint8
  let @sun_path9: Uint8
  let @sun_path10: Uint8
  let @sun_path11: Uint8
  let @sun_path12: Uint8
  let @sun_path13: Uint8
  let @sun_path14: Uint8
  let @sun_path15: Uint8
  let @sun_path16: Uint8
  let @sun_path17: Uint8
  let @sun_path18: Uint8
  let @sun_path19: Uint8
  let @sun_path20: Uint8
  let @sun_path21: Uint8
  let @sun_path22: Uint8
  let @sun_path23: Uint8
  let @sun_path24: Uint8
  let @sun_path25: Uint8
  let @sun_path26: Uint8
  let @sun_path27: Uint8
  let @sun_path28: Uint8
  let @sun_path29: Uint8
  let @sun_path30: Uint8
  let @sun_path31: Uint8
  let @sun_path32: Uint8
  let @sun_path33: Uint8
  let @sun_path34: Uint8
  let @sun_path35: Uint8
  let @sun_path36: Uint8
  let @sun_path37: Uint8
  let @sun_path38: Uint8
  let @sun_path39: Uint8
  let @sun_path40: Uint8
  let @sun_path41: Uint8
  let @sun_path42: Uint8
  let @sun_path43: Uint8
  let @sun_path44: Uint8
  let @sun_path45: Uint8
  let @sun_path46: Uint8
  let @sun_path47: Uint8
  let @sun_path48: Uint8
  let @sun_path49: Uint8
  let @sun_path50: Uint8
  let @sun_path51: Uint8
  let @sun_path52: Uint8
  let @sun_path53: Uint8
  let @sun_path54: Uint8
  let @sun_path55: Uint8
  let @sun_path56: Uint8
  let @sun_path57: Uint8
  let @sun_path58: Uint8
  let @sun_path59: Uint8
  let @sun_path60: Uint8
  let @sun_path61: Uint8
  let @sun_path62: Uint8
  let @sun_path63: Uint8
  let @sun_path64: Uint8
  let @sun_path65: Uint8
  let @sun_path66: Uint8
  let @sun_path67: Uint8
  let @sun_path68: Uint8
  let @sun_path69: Uint8
  let @sun_path70: Uint8
  let @sun_path71: Uint8
  let @sun_path72: Uint8
  let @sun_path73: Uint8
  let @sun_path74: Uint8
  let @sun_path75: Uint8
  let @sun_path76: Uint8
  let @sun_path77: Uint8
  let @sun_path78: Uint8
  let @sun_path79: Uint8
  let @sun_path80: Uint8
  let @sun_path81: Uint8
  let @sun_path82: Uint8
  let @sun_path83: Uint8
  let @sun_path84: Uint8
  let @sun_path85: Uint8
  let @sun_path86: Uint8
  let @sun_path87: Uint8
  let @sun_path88: Uint8
  let @sun_path89: Uint8
  let @sun_path90: Uint8
  let @sun_path91: Uint8
  let @sun_path92: Uint8
  let @sun_path93: Uint8
  let @sun_path94: Uint8
  let @sun_path95: Uint8
  let @sun_path96: Uint8
  let @sun_path97: Uint8
  let @sun_path98: Uint8
  let @sun_path99: Uint8
  let @sun_path100: Uint8
  let @sun_path101: Uint8
  let @sun_path102: Uint8
  let @sun_path103: Uint8
}

type extern SockAddr {
  let @sa_len: Uint8
  let @sa_family: Uint8
  let @sa_data0: Uint8
  let @sa_data1: Uint8
  let @sa_data2: Uint8
  let @sa_data3: Uint8
  let @sa_data4: Uint8
  let @sa_data5: Uint8
  let @sa_data6: Uint8
  let @sa_data7: Uint8
  let @sa_data8: Uint8
  let @sa_data9: Uint8
  let @sa_data10: Uint8
  let @sa_data11: Uint8
  let @sa_data12: Uint8
  let @sa_data13: Uint8
}

type extern SockAddrStorage {
  let @ss_len: Uint8
  let @ss_family: Uint8
  let @__pad0: Uint16
  let @__pad1: Uint32
  let @__val0: Uint64
  let @__val1: Uint64
  let @__val2: Uint64
  let @__val3: Uint64
  let @__val4: Uint64
  let @__val5: Uint64
  let @__val6: Uint64
  let @__val7: Uint64
  let @__val8: Uint64
  let @__val9: Uint64
  let @__val10: Uint64
  let @__val11: Uint64
  let @__val12: Uint64
  let @__val13: Uint64
  let @__val14: Uint64
}

type extern AddrInfo {
  let @ai_flags: Int32
  let @ai_family: Int32
  let @ai_socktype: Int32
  let @ai_protocol: Int32
  let @ai_addrlen: Uint64
  let @ai_canonname: Pointer[Uint8]
  let @ai_addr: Pointer[SockAddr]
  let @ai_next: Pointer[AddrInfo]
}

type extern Kevent {
  let @__val0: Uint32
  let @__val1: Uint32
  let @__val2: Uint32
  let @__val3: Uint32
  let @__val4: Uint32
  let @__val5: Uint32
  let @__val6: Uint32
  let @__val7: Uint32
}

fn extern chmod(path: Pointer[Uint8], mode: Uint16) -> Int32

fn extern fsync(fd: Int32) -> Int32

fn extern fcntl(fd: Int32, cmd: Int32, ...) -> Int32

fn extern sendfile(
  input: Int32,
  out: Int32,
  offset: Int64,
  len: Pointer[Int64],
  hdtr: Pointer[Uint8],
  flags: Int32,
) -> Int32

fn extern fclonefileat(
  from: Int32,
  dir: Int32,
  to: Pointer[Uint8],
  flags: Int32,
) -> Int32

fn extern fcopyfile(
  from: Int32,
  to: Int32,
  state: Pointer[Uint8],
  flags: Uint32,
) -> Int32

fn extern pipe(pipes: Pointer[Pipes]) -> Int32

fn extern __error -> Pointer[Int32]

fn extern accept(
  socket: Int32,
  addr: Pointer[SockAddr],
  size: Pointer[Uint32],
) -> Int32

fn extern getentropy(buffer: Pointer[Uint8], size: Uint64) -> Int

fn extern kqueue -> Int32

fn extern kevent(
  kq: Int32,
  changes: Pointer[Kevent],
  nchanges: Int32,
  events: Pointer[Kevent],
  nevents: Int32,
  timeout: Pointer[Uint8],
) -> Int32

fn inline fstat(fd: Int32, buf: Pointer[StatBuf]) -> Int32 {
  sys.fstat(fd, buf)
}

fn inline stat(path: Pointer[Uint8], buf: Pointer[StatBuf]) -> Int32 {
  sys.stat(path, buf)
}

fn inline opendir(path: Pointer[Uint8]) -> Pointer[Uint8] {
  sys.opendir(path)
}

fn inline readdir(path: Pointer[Uint8]) -> Pointer[Dirent] {
  sys.readdir(path)
}

fn inline flush(fd: Int32) -> Int32 {
  # On macOS the guarantees of fsync() aren't as strong as on Linux
  # (https://mjtsai.com/blog/2022/02/17/apple-ssd-benchmarks-and-f_fullsync/),
  # instead one has to use a macOS specific fcntl() command to achieve the same
  # result.
  #
  # In addition, some non-Apple drives may not support F_FULLSYNC or
  # F_BARRIERFSYNC, in which case one should fall back to using fsync():
  #
  # You'd think Apple would fix this somehow, but instead every project that
  # intends to flush some data has te reimplement this logic (or rely on a
  # library that does).
  #
  # - https://github.com/libuv/libuv/issues/1579
  # - https://github.com/neovim/neovim/issues/9611
  # - https://github.com/mackyle/sqlite/blob/a03874b4f2a43506a571c47b84c50376921023e9/src/os_unix.c#L3485
  # - https://github.com/libuv/libuv/blob/f00d4b677556a007a28fcb0bb3548ecdb54a29ae/src/unix/fs.c#L174
  # - https://github.com/vim/vim/pull/4025
  if fcntl(fd, F_FULLFSYNC as Int32) as Int == 0 {
    0 as Int32
  } else if fcntl(fd, F_BARRIERFSYNC as Int32) as Int == 0 {
    0 as Int32
  } else {
    fsync(fd)
  }
}

fn inline dirent_type(pointer: Pointer[Dirent]) -> Int {
  pointer.d_type as Int
}

fn inline dirent_name(pointer: Pointer[Dirent]) -> Pointer[Uint8] {
  pointer as Int + 21 as Pointer[Uint8]
}

fn inline pipes(nonblocking: Bool) -> Result[(Int32, Int32), Error] {
  let pipes = Pipes()

  if pipe(mut pipes) as Int != 0 { throw Error.last_os_error }

  # macOS has no pipe2() function, so we have to manually set the CLOEXEC flag.
  if fcntl(pipes.reader, F_SETFD as Int32, FD_CLOEXEC as Int32) as Int != 0 {
    throw Error.last_os_error
  }

  if fcntl(pipes.writer, F_SETFD as Int32, FD_CLOEXEC as Int32) as Int != 0 {
    throw Error.last_os_error
  }

  if nonblocking {
    let flags = O_NONBLOCK as Int32

    if fcntl(pipes.reader, F_SETFL as Int32, flags) as Int != 0 {
      throw Error.last_os_error
    }

    if fcntl(pipes.writer, F_SETFL as Int32, flags) as Int != 0 {
      throw Error.last_os_error
    }
  }

  Result.Ok((pipes.reader, pipes.writer))
}

fn inline new_kevent(fd: Int32, id: Int, filter: Int, flags: Int) -> Kevent {
  let event = Kevent()

  ((mut event) as Pointer[Uint64]).0 = fd as Uint64
  ((mut event) as Int + 8 as Pointer[Int16]).0 = filter as Int16
  ((mut event) as Int + 10 as Pointer[Uint16]).0 = flags as Uint16
  ((mut event) as Int + 24 as Pointer[Uint64]).0 = id as Uint64

  event
}

fn inline errno_location -> Pointer[Int32] {
  __error
}

fn inline sockaddr_in_size -> Int {
  size_of[SockAddrIn]
}

fn inline sockaddr_in6_size -> Int {
  size_of[SockAddrIn6]
}

fn inline sockaddr_un_size -> Int {
  size_of[SockAddrUn]
}

fn inline sockaddr_un_name_offset -> Int {
  2
}

fn inline unix_socket_path_limit -> Int {
  104
}

fn inline sockaddr_storage_size -> Int {
  size_of[SockAddrStorage]
}
