# IPv4 and IPv6 address types.
import std.clone (Clone)
import std.cmp (Equal)
import std.fmt (Format as FormatTrait, Formatter)
import std.int (Format)
import std.string (IntoString, StringBuffer, ToString)

# The byte for a single dot (".").
let DOT_BYTE = 46

# The byte for zero as a string ("0").
let ZERO_BYTE = 48

# The byte for a single colon (":").
let COLON_BYTE = 58

# The number of octets in an IPv4 address.
let IPV4_OCTETS = 4

# The number of hextets in an IPv6 address.
let IPV6_HEXTETS = 8

# The minimum value of an IPv4 octet or IPv6 hextet.
let IP_MINIMUM_VALUE = 0

# The maximum value of an IPv4 octet.
let IPV4_OCTET_MAXIMUM = 0xff

# The maximum value of an IPv6 hextet.
let IPV6_HEXTET_MAXIMUM = 0xffff

# The maximum number of characters that can appear in an IPv6 address stored as
# a `String`.
let IPV6_STRING_MAXIMUM_LENGTH = 45

# The number of bits to shift for the first and third octets in an IPv4 address
# when converting them to IPv6 addresses.
let IPV4_TOIPV6_SHIFT = 8

# Converts a pair of IPv4 octets into a single IPv6 hextet.
fn octets_to_hextet(first: Int, second: Int) -> Int {
  first << IPV4_TOIPV6_SHIFT | second
}

# An IPv4 or IPv6 address.
class pub enum IpAddress {
  # An IPv4 address.
  case V4(Ipv4Address)

  # An IPv6 address.
  case V6(Ipv6Address)

  # Returns a new IPv4 address.
  #
  # This is a shortcut for `IpAddress.V4(Ipv4Address.new(...))`.
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (IpAddress)
  #
  # IpAdress.v4(127, 0, 0, 1)
  # ```
  fn pub static v4(a: Int, b: Int, c: Int, d: Int) -> IpAddress {
    V4(Ipv4Address.new(a, b, c, d))
  }

  # Returns a new IPv6 address.
  #
  # This is a shortcut for `IpAddress.V6(Ipv6Address.new(...))`.
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (IpAddress)
  #
  # IpAdress.v6(0, 0, 0, 0, 0, 0, 0, 1)
  # ```
  fn pub static v6(
    a: Int,
    b: Int,
    c: Int,
    d: Int,
    e: Int,
    f: Int,
    g: Int,
    h: Int,
  ) -> IpAddress {
    V6(Ipv6Address.new(a, b, c, d, e, f, g, h))
  }

  # Parses an IPv4 or IPv6 address.
  #
  # This method _only_ supports IPv4 or IPv6 _addresses_. Port numbers, IPv6
  # zones, and CIDR masks are not supported.
  #
  # # Examples
  #
  # Parsing an IPv4 address:
  #
  # ```inko
  # import std.net.ip (IpAddress)
  #
  # IpAddress.parse('1.2.3.4') # => Option.Some(IpAddress.V4(Ipv4Address.new(1, 2, 3, 4)))
  # ```
  #
  # Parsing an IPv6 address:
  #
  # ```inko
  # import std.net.ip (IpAddress)
  #
  # IpAddress.parse('::1') # => Option.Some(IpAddress.V6(Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1)))
  # ```
  fn pub static parse(address: String) -> Option[IpAddress] {
    if address.contains?(':') {
      Ipv6Address.parse(address).map(fn (v) { V6(v) })
    } else {
      Ipv4Address.parse(address).map(fn (v) { V4(v) })
    }
  }

  # Returns `true` if `self` is an IPv4 address.
  fn pub v4? -> Bool {
    match self {
      case V4(_) -> true
      case _ -> false
    }
  }

  # Returns `true` if `self` is an IPv6 address.
  fn pub v6? -> Bool {
    match self {
      case V6(_) -> true
      case _ -> false
    }
  }

  # Returns `true` if `self` is in the range designated for documentation.
  fn pub documentation? -> Bool {
    match self {
      case V4(ip) -> ip.documentation?
      case V6(ip) -> ip.documentation?
    }
  }

  # Returns `true` if `self` is a loopback address.
  fn pub loopback? -> Bool {
    match self {
      case V4(ip) -> ip.loopback?
      case V6(ip) -> ip.loopback?
    }
  }

  # Returns `true` if `self` is a multicast address.
  fn pub multicast? -> Bool {
    match self {
      case V4(ip) -> ip.multicast?
      case V6(ip) -> ip.multicast?
    }
  }

  # Returns `true` if `self` is the special "unspecified" address.
  fn pub unspecified? -> Bool {
    match self {
      case V4(ip) -> ip.unspecified?
      case V6(ip) -> ip.unspecified?
    }
  }
}

impl Equal[ref IpAddress] for IpAddress {
  fn pub ==(other: ref IpAddress) -> Bool {
    match self {
      case V4(a) -> {
        match other {
          case V4(b) -> a == b
          case _ -> false
        }
      }
      case V6(a) -> {
        match other {
          case V6(b) -> a == b
          case _ -> false
        }
      }
    }
  }
}

impl IntoString for IpAddress {
  fn pub move into_string -> String {
    match self {
      case V4(ip) -> ip.into_string
      case V6(ip) -> ip.into_string
    }
  }
}

impl ToString for IpAddress {
  fn pub to_string -> String {
    match self {
      case V4(ip) -> ip.to_string
      case V6(ip) -> ip.to_string
    }
  }
}

impl Clone[IpAddress] for IpAddress {
  fn pub clone -> IpAddress {
    match self {
      case V4(ip) -> IpAddress.V4(ip.clone)
      case V6(ip) -> IpAddress.V6(ip.clone)
    }
  }
}

impl FormatTrait for IpAddress {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write(to_string)
  }
}

# An IPv6 address.
class pub Ipv6Address {
  let @a: Int
  let @b: Int
  let @c: Int
  let @d: Int
  let @e: Int
  let @f: Int
  let @g: Int
  let @h: Int

  # Parses an IPv6 address literal.
  #
  # This method _only_ supports IPv6 _addresses_. Port numbers, zones, and CIDR
  # masks are not supported.
  #
  # # Examples
  #
  # Parsing an IPv6 address:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.parse('::1').get.v6? # => true
  # ```
  fn pub static parse(input: String) -> Option[Ipv6Address] {
    let bytes = input.to_byte_array
    let mut cursor = 0
    let max = bytes.size
    let segments = []
    let ipv4_segments = []
    let segment_bytes = ByteArray.new
    let mut compressed = false
    let mut ipv4_mode = false
    let mut max_hextet_value = IPV6_HEXTET_MAXIMUM
    let mut format = Format.Hex

    # No point in parsing the input if we're certain it's not a valid address.
    if max > IPV6_STRING_MAXIMUM_LENGTH { return Option.None }

    while cursor < max {
      # IPv6 addresses can embed IPv4 addresses, so instead of reading until we
      # encounter a ":" we will also stop reading when running into a ".".
      while
        cursor < max
          and bytes.get(cursor) != COLON_BYTE
          and bytes.get(cursor) != DOT_BYTE
      {
        segment_bytes.push(bytes.get(cursor))
        cursor += 1
      }

      # The moment we encounter a dot we'll enter IPv4 mode, and remain in this
      # mode until we reach the end of the input, as embedded IPv4 addresses
      # must be at the end of an IPv6 address.
      if ipv4_mode.false? and cursor < max and bytes.get(cursor) == DOT_BYTE {
        ipv4_mode = true
        format = Format.Decimal
        max_hextet_value = IPV4_OCTET_MAXIMUM
      }

      # When the IP starts with a "::" we won't be able to read input, so the
      # byte buffer is empty.
      if segment_bytes.size > 0 {
        let int = try Int.parse(segment_bytes, format)

        segment_bytes.clear

        if int < IP_MINIMUM_VALUE or int > max_hextet_value {
          return Option.None
        }

        if ipv4_mode { ipv4_segments.push(int) } else { segments.push(int) }
      }

      cursor += 1

      # We have reached another ":", which is used to compress one or more empty
      # groups together.
      if cursor < max and bytes.get(cursor) == COLON_BYTE {
        # Zero compression can only be applied once.
        if compressed { return Option.None }

        compressed = true

        let mut pad = IPV6_HEXTETS - segments.size
        let mut pad_cursor = cursor
        let mut ipv4_padded = false
        let look_ahead = cursor + 1 < max

        # Scan ahead in the input to determine how many empty hextets we need to
        # add, based on the remaining number of hextets.
        #
        # When the compression is at the end of the input (e.g. "1::") there is
        # no point in looking ahead, so we don't.
        while pad_cursor < max and look_ahead {
          let byte = bytes.get(pad_cursor)

          if byte == COLON_BYTE { pad -= 1 }

          # Two IPv4 octets can be stored in a single IPv6 hextet, meaning we'd
          # have to reduce padding by two. Since we already skip padding for the
          # ":" that preceeds the IPv4 address, we only reduce the padding by
          # one.
          if ipv4_padded.false? and byte == DOT_BYTE {
            ipv4_padded = true
            pad -= 1
          }

          pad_cursor += 1
        }

        while pad > 0 {
          segments.push(0)
          pad -= 1
        }

        cursor += 1
      }
    }

    if ipv4_segments.size == IPV4_OCTETS {
      segments.push(
        octets_to_hextet(ipv4_segments.get(0), ipv4_segments.get(1)),
      )
      segments.push(
        octets_to_hextet(ipv4_segments.get(2), ipv4_segments.get(3)),
      )
    }

    if segments.size != IPV6_HEXTETS { return Option.None }

    Option.Some(
      Ipv6Address.new(
        segments.get(0),
        segments.get(1),
        segments.get(2),
        segments.get(3),
        segments.get(4),
        segments.get(5),
        segments.get(6),
        segments.get(7),
      ),
    )
  }

  # Returns a new IPv6 address using the given hextets.
  fn pub static new(
    a: Int,
    b: Int,
    c: Int,
    d: Int,
    e: Int,
    f: Int,
    g: Int,
    h: Int,
  ) -> Ipv6Address {
    Ipv6Address(a: a, b: b, c: c, d: d, e: e, f: f, g: g, h: h)
  }

  # Returns `true` if `self` is an IPv4-compatible IPv6 address.
  #
  # # Examples
  #
  # Checking if an IPv6 address is an IPv4-compatible IPv6 address:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.new(0, 0, 0, 0, 0, 0, 1, 1).ipv4_compatible? # => true
  # ```
  fn pub ipv4_compatible? -> Bool {
    @a == 0 and @b == 0 and @c == 0 and @d == 0 and @e == 0 and @f == 0
  }

  # Returns `true` if `self` is an IPv4-mapped IPv6 address.
  #
  # # Examples
  #
  # Checking if an IPv6 address is an IPv4-mapped IPv6 address:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.new(0, 0, 0, 0, 0, 0xffff, 1, 1).ipv4_compatible? # => true
  # ```
  fn pub ipv4_mapped? -> Bool {
    @a == 0
      and @b == 0
      and @c == 0
      and @d == 0
      and @e == 0
      and @f == IPV6_HEXTET_MAXIMUM
  }

  # Returns `true` if `self` is in a range designated for documentation.
  #
  # All addresses in the range 2001:db8::/32 are designated for documentation.
  #
  # # Examples
  #
  # Checking if an IPv6 address is a documentation address:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.new(0x2001, 0xdb8, 0, 0, 0, 0, 0, 0).documentation # => true
  # ```
  fn pub documentation? -> Bool {
    @a == 0x2001 and @b == 0xdb8
  }

  # Returns `true` if `self` is a loopback address (::1).
  #
  # # Examples
  #
  # Checking if an address is a loopback address:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1).loopback? # => true
  # Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 2).loopback? # => false
  # ```
  fn pub loopback? -> Bool {
    @a == 0
      and @b == 0
      and @c == 0
      and @d == 0
      and @e == 0
      and @f == 0
      and @g == 0
      and @h == 1
  }

  # Returns `true` if `self` is a multicast address (ff00::/8).
  #
  # # Examples
  #
  # Checking if an address is a multicast address:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.new(0xff00, 0, 0, 0, 0, 0, 0, 0).multicast? # => true
  # Ipv6Address.new(0xff01, 0, 0, 0, 0, 0, 0, 0).multicast? # => true
  # Ipv6Address.new(0, 1, 0, 0, 0, 0, 0, 0).multicast?      # => false
  # ```
  fn pub multicast? -> Bool {
    @a & 0xff00 == 0xff00
  }

  # Returns `true` if `self` is the special "unspecified" address (::).
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 0).unspecified? # => true
  # Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1).unspecified? # => false
  # ```
  fn pub unspecified? -> Bool {
    @a == 0
      and @b == 0
      and @c == 0
      and @d == 0
      and @e == 0
      and @f == 0
      and @g == 0
      and @h == 0
  }
}

impl FormatTrait for Ipv6Address {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write(to_string)
  }
}

impl Equal[ref Ipv6Address] for Ipv6Address {
  # Returns `true` if `self` and the given IP address are the same.
  #
  # # Examples
  #
  # Comparing two IPv6 addresses:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # let addr1 = Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1)
  # let addr2 = Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1)
  # let addr3 = Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 2)
  #
  # addr1 == addr2 # => true
  # addr1 == addr3 # => false
  # ```
  fn pub ==(other: ref Ipv6Address) -> Bool {
    @a == other.a
      and @b == other.b
      and @c == other.c
      and @d == other.d
      and @e == other.e
      and @f == other.f
      and @g == other.g
      and @h == other.h
  }
}

impl ToString for Ipv6Address {
  # Converts `self` to a `String`.
  #
  # Zero compression is applied to the longest sequence of empty hextets, if
  # there are any.
  #
  # # Examples
  #
  # Converting an IPv6 address to a `String`:
  #
  # ```inko
  # import std.net.ip (Ipv6Address)
  #
  # Ipv6Address.new.to_string # => '::'
  # Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 1) # => '::1'
  # ```
  fn pub to_string -> String {
    if unspecified? { return '::' }

    if loopback? { return '::1' }

    let ipv4_compatible = ipv4_compatible?
    let ipv4_mapped = ipv4_mapped?

    if ipv4_compatible or ipv4_mapped {
      # This value (256) is used to convert a hextet to the second and fourth
      # octet in an IPv4 address. For example, for a hextet 0x2ff this produces
      # an octet of 255.
      let hextet_to_octet_modulo = IPV4_OCTET_MAXIMUM + 1
      let prefix = if ipv4_compatible { '::' } else { '::ffff:' }
      let a = @g >> IPV4_TOIPV6_SHIFT
      let b = @g % hextet_to_octet_modulo
      let c = @h >> IPV4_TOIPV6_SHIFT
      let d = @h % hextet_to_octet_modulo

      return '${prefix}${a}.${b}.${c}.${d}'
    }

    let mut compression_start = 0
    let mut compression_len = 0
    let mut current_at = 0
    let mut current_len = 0
    let mut index = 0
    let segments = [@a, @b, @c, @d, @e, @f, @g, @h]

    # Find the longest sequence of empty hextets, which we will compress
    # together.
    while index < segments.size {
      let hextet = segments.get(index)

      if hextet == 0 {
        if current_len == 0 { current_at = index }

        current_len += 1

        if current_len > compression_len {
          compression_len = current_len
          compression_start = current_at
        }
      } else {
        current_at = 0
        current_len = 0
      }

      index += 1
    }

    let format = Format.Hex

    if compression_len > 0 {
      let buffer = StringBuffer.new
      let compression_end = compression_start + compression_len

      segments.iter.each_with_index(fn (index, hextet) {
        if index == compression_start { buffer.push(':') }

        if index < compression_start or index >= compression_end {
          if index > 0 { buffer.push(':') }

          buffer.push(hextet.format(format))
        }
      })

      return buffer.to_string
    }

    let a = @a.format(format)
    let b = @b.format(format)
    let c = @c.format(format)
    let d = @d.format(format)
    let e = @e.format(format)
    let f = @f.format(format)
    let g = @g.format(format)
    let h = @h.format(format)

    '${a}:${b}:${c}:${d}:${e}:${f}:${g}:${h}'
  }
}

impl IntoString for Ipv6Address {
  fn pub move into_string -> String {
    to_string
  }
}

impl Clone[Ipv6Address] for Ipv6Address {
  fn pub clone -> Ipv6Address {
    Ipv6Address(a: @a, b: @b, c: @c, d: @d, e: @e, f: @f, g: @g, h: @h)
  }
}

# An IPv4 address.
class pub Ipv4Address {
  let @a: Int
  let @b: Int
  let @c: Int
  let @d: Int

  # Parses an IPv4 address literal (e.g. "1.2.3.4").
  #
  # # Examples
  #
  # Parsing an IPv4 address:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # let addr = Ipv4Address.parse('1.2.3.4').get
  #
  # addr.v4? # => true
  # ```
  fn pub static parse(input: String) -> Option[Ipv4Address] {
    # No IPv4 address can be longer than 15 characters (255.255.255.255).
    if input.size > 15 { return Option.None }

    let segments = []
    let format = Format.Decimal

    input.split('.').each(fn (segment) {
      # This handles inputs such as "." and "..."
      if segment.empty? { return }

      # We don't support octal formats, as it was never part of the spec.
      # Ignoring them can lead to security issues, as described in
      # https://www.bleepingcomputer.com/news/security/go-rust-net-library-affected-by-critical-ip-address-validation-vulnerability/.
      if segment.byte(0) == ZERO_BYTE and segment.size > 1 { return }

      match Int.parse(segment, format) {
        case Some(int) if int >= IP_MINIMUM_VALUE and int <= IPV4_OCTET_MAXIMUM
        -> {
          segments.push(int)
        }
        case _ -> {}
      }
    })

    if segments.size != IPV4_OCTETS { return Option.None }

    Option.Some(
      Ipv4Address(
        a: segments.get(0),
        b: segments.get(1),
        c: segments.get(2),
        d: segments.get(3),
      ),
    )
  }

  # Returns a new IPv4 address using the given octets.
  fn pub static new(a: Int, b: Int, c: Int, d: Int) -> Ipv4Address {
    Ipv4Address(a: a, b: b, c: c, d: d)
  }

  # Returns `true` if `self` is a broadcast address (255.255.255.255).
  #
  # # Examples
  #
  # Checking if an IPv4 address is a broadcast address:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new(127, 0, 0, 1).broadcast? # => false
  # Ipv4Address.new(255, 255, 255, 255).broadcast? # => true
  # ```
  fn pub broadcast? -> Bool {
    @a == IPV4_OCTET_MAXIMUM
      and @b == IPV4_OCTET_MAXIMUM
      and @c == IPV4_OCTET_MAXIMUM
      and @d == IPV4_OCTET_MAXIMUM
  }

  # Returns `true` if `self` is link-local (169.254.0.0/16).
  #
  # # Examples
  #
  # Checking if an address is link-local:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new(169, 254, 0, 0).link_local? # => true
  # Ipv4Address.new(169, 254, 1, 0).link_local? # => true
  # Ipv4Address.new(169, 255, 1, 0).link_local? # => false
  # ```
  fn pub link_local? -> Bool {
    @a == 169 and @b == 254
  }

  # Returns `true` if `self` is a private address.
  #
  # The following ranges are private IPv4 ranges:
  #
  # - 10.0.0.0/8
  # - 172.16.0.0/12
  # - 192.168.0.0/16
  #
  # # Examples
  #
  # Checking if an address is in a private range:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new(10, 0, 0, 1).private? # => true
  # Ipv4Address.new(127, 0, 0, 1).private? # => false
  # ```
  fn pub private? -> Bool {
    if @a == 10 { return true }

    if @a == 172 and @b >= 16 and @b <= 31 { return true }

    @a == 192 and @b == 168
  }

  # Converts this IP address to an IPv4-compatible IPv6 address.
  #
  # # Examples
  #
  # Converting an IPv4 address:
  #
  # ```inko
  # import std.net.ip (Ipv4Address, Ipv6Address)
  #
  # let ipv4 = Ipv4Address.new(192, 0, 2, 255)
  # let ipv6 = ipv4.to_ipv6_compatible
  #
  # ipv6.segments # => [0, 0, 0, 0, 0, 0, 0xc000, 0x2ff]
  # ```
  fn pub to_ipv6_compatible -> Ipv6Address {
    Ipv6Address.new(
      0,
      0,
      0,
      0,
      0,
      0,
      octets_to_hextet(@a, @b),
      octets_to_hextet(@c, @d),
    )
  }

  # Converts this IP address to an IPv4-mapped IPv6 address.
  fn pub to_ipv6_mapped -> Ipv6Address {
    Ipv6Address.new(
      0,
      0,
      0,
      0,
      0,
      IPV6_HEXTET_MAXIMUM,
      octets_to_hextet(@a, @b),
      octets_to_hextet(@c, @d),
    )
  }

  # Returns `true` if `self` is in a range designated for documentation.
  #
  # The following IPv4 ranges are designated for documentation:
  #
  # - 192.0.2.0/24 (TEST-NET-1)
  # - 198.51.100.0/24 (TEST-NET-2)
  # - 203.0.113.0/24 (TEST-NET-3)
  #
  # # Examples
  #
  # Checking if an IPv4 address is a documentation address:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new(192, 0, 2, 0).documentation? # => true
  # Ipv4Address.new(192, 1, 2, 0).documentation? # => false
  # ```
  fn pub documentation? -> Bool {
    if @a == 192 and @b == 0 and @c == 2 { return true }

    if @a == 198 and @b == 51 and @c == 100 { return true }

    @a == 203 and @b == 0 and @c == 113
  }

  # Returns `true` if `self` is a loopback address (127.0.0.0/8).
  #
  # # Examples
  #
  # Checking if an address is a loopback address:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new(127, 0, 0, 1).loopback? # => true
  # Ipv4Address.new(127, 0, 1, 1).loopback? # => true
  # Ipv4Address.new(255, 0, 0, 0).loopback? # => false
  # ```
  fn pub loopback? -> Bool {
    @a == 127
  }

  # Returns `true` if `self` is a multicast address (244.0.0.0/4).
  #
  # # Examples
  #
  # Checking if an address is a multicast address:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new(224, 254, 0, 0).multicast? # => true
  # Ipv4Address.new(127, 0, 0, 1).multicast? # => false
  # ```
  fn pub multicast? -> Bool {
    let first = @a

    first >= 224 and first <= 239
  }

  # Returns `true` if `self` is the special "unspecified" address (0.0.0.0).
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new(0, 0, 0, 0).unspecified? # => true
  # Ipv4Address.new(0, 0, 0, 1).unspecified? # => false
  # ```
  fn pub unspecified? -> Bool {
    @a == 0 and @b == 0 and @c == 0 and @d == 0
  }
}

impl FormatTrait for Ipv4Address {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write(to_string)
  }
}

impl Equal[ref Ipv4Address] for Ipv4Address {
  # Returns `true` if `self` and the given IP address are the same.
  #
  # # Examples
  #
  # Comparing two IPv4 addresses:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # let addr1 = Ipv4Address.new(127, 0, 0, 1)
  # let addr2 = Ipv4Address.new(127, 0, 0, 1)
  # let addr3 = Ipv4Address.new(127, 0, 0, 2)
  #
  # addr1 == addr2 # => true
  # addr1 == addr3 # => false
  # ```
  fn pub ==(other: ref Ipv4Address) -> Bool {
    @a == other.a and @b == other.b and @c == other.c and @d == other.d
  }
}

impl ToString for Ipv4Address {
  # Converts `self` to a `String`.
  #
  # # Examples
  #
  # Converting an IPv4 address to a `String`:
  #
  # ```inko
  # import std.net.ip (Ipv4Address)
  #
  # Ipv4Address.new.to_string # => '0.0.0.0'
  # Ipv4Address.new(127, 0, 0, 1) # => '127.0.0.1'
  # ```
  fn pub to_string -> String {
    '${@a}.${@b}.${@c}.${@d}'
  }
}

impl IntoString for Ipv4Address {
  fn pub move into_string -> String {
    to_string
  }
}

impl Clone[Ipv4Address] for Ipv4Address {
  fn pub clone -> Ipv4Address {
    Ipv4Address(a: @a, b: @b, c: @c, d: @d)
  }
}
