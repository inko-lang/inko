# TLS support for sockets.
#
# This module provides socket support for TLS 1.2 and TLS 1.3.
#
# The two main socket types are `Client` and `Server`, both acting as wrappers
# around existing socket types (e.g. `std.net.socket.TcpClient`) that
# transparently handle TLS encryption and decryption.
#
# For more details on how to set up a client and/or server socket, refer to the
# documentation of `Client.new` and `Server.new`.
#
# # Handling closing of connections
#
# The TLS specification states that clients _should_ send the `close_notify`
# message when they disconnect, but not every TLS implementation/user sends it.
# The `Client` and `Server` types provided by this module automatically send the
# `close_notify` message when they're dropped.
#
# When performing an IO operation on a socket closed without an explicit
# `close_notify` message being sent first, an `Error.EndOfInput` error is
# produced.
#
# When receiving a `close_notify` message during or after an IO operation (e.g.
# a write), a `Error.InvalidData` or `Error.BrokenPipe` error may be produced.
import std.bytes (Bytes)
import std.clone (Clone)
import std.cmp (Equal)
import std.crypto.x509 (Certificate, PrivateKey)
import std.drop (Drop)
import std.fmt (Format, Formatter)
import std.fs.file (ReadOnlyFile)
import std.io (Error, Read, Write, WriteInternal)
import std.net.socket (Deadline, RawSocketOperations, SendFile)
import std.ptr
import std.string (PrimitiveString, ToString)
import std.sys.net
import std.sys.unix.net (self as sys)
import std.time (ToInstant)

let INVALID_CERT = -1
let INVALID_CLIENT_HELLO = -3
let INVALID_CONNECTION = -4
let DEFAULT_ALPN = []

fn extern inko_tls_client_config_new -> AnyResult

fn extern inko_tls_client_config_clone(config: Pointer[UInt8]) -> Pointer[UInt8]

fn extern inko_tls_client_config_add_alpn(
  config: Pointer[UInt8],
  name: Pointer[UInt8],
  size: Int,
) -> Bool

fn extern inko_tls_client_config_drop(config: Pointer[UInt8])

fn extern inko_tls_client_config_with_certificate(
  certificate: Pointer[UInt8],
  size: Int,
) -> AnyResult

fn extern inko_tls_client_connection_new(
  config: Pointer[UInt8],
  name: PrimitiveString,
  alpn: Pointer[PrimitiveString],
  alpn_size: Int,
) -> AnyResult

fn extern inko_tls_client_connection_alpn(
  connection: Pointer[UInt8],
) -> PrimitiveString

fn extern inko_tls_client_connection_drop(connection: Pointer[UInt8])

fn extern inko_tls_server_config_new(
  certificate: Pointer[UInt8],
  certificate_size: Int,
  key: Pointer[UInt8],
  key_size: Int,
) -> AnyResult

fn extern inko_tls_server_config_add_alpn(
  config: Pointer[UInt8],
  name: Pointer[UInt8],
  size: Int,
) -> Bool

fn extern inko_tls_server_config_clone(config: Pointer[UInt8]) -> Pointer[UInt8]

fn extern inko_tls_server_config_drop(config: Pointer[UInt8])

fn extern inko_tls_server_connection_new(
  config: Pointer[UInt8],
) -> Pointer[UInt8]

fn extern inko_tls_server_connection_alpn(
  connection: Pointer[UInt8],
) -> PrimitiveString

fn extern inko_tls_server_connection_drop(connection: Pointer[UInt8])

fn extern inko_tls_client_read(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  buffer: Pointer[UInt8],
  size: Int,
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_client_write(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  buffer: Pointer[UInt8],
  size: Int,
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_client_flush(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_client_close(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_server_read(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  buffer: Pointer[UInt8],
  size: Int,
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_server_write(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  buffer: Pointer[UInt8],
  size: Int,
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_server_flush(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_server_close(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_client_complete_io(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_server_complete_io(
  socket: Pointer[net.RawSocket],
  connection: Pointer[UInt8],
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> IntResult

fn extern inko_tls_pending_server_new(
  socket: Pointer[net.RawSocket],
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> AnyResult

fn extern inko_tls_pending_server_name(
  accepted: Pointer[UInt8],
) -> PrimitiveString

fn extern inko_tls_pending_server_into_server_connection(
  accepted: Pointer[UInt8],
  config: Pointer[UInt8],
  socket: Pointer[net.RawSocket],
  deadline: Int,
  reader: Pointer[UInt8],
  writer: Pointer[UInt8],
) -> AnyResult

fn extern inko_tls_pending_server_drop(accepted: Pointer[UInt8])

let OK = 0
let NONE = 1
let ERROR = 2

type extern AnyResult {
  let @tag: Int
  let @value: UInt64
}

type extern IntResult {
  let @tag: Int
  let @value: Int
}

fn extern read_callback(
  socket: Pointer[net.RawSocket],
  buffer: Pointer[UInt8],
  size: Int,
  deadline: Int,
) -> IntResult {
  match sys.read_raw(socket, buffer, size, deadline) {
    case Ok(v) -> IntResult(tag: OK, value: v)
    case Error(e) -> IntResult(tag: ERROR, value: e)
  }
}

fn extern write_callback(
  socket: Pointer[net.RawSocket],
  buffer: Pointer[UInt8],
  size: Int,
  deadline: Int,
) -> IntResult {
  match sys.write_raw(socket, buffer, size, deadline) {
    case Ok(v) -> IntResult(tag: OK, value: v)
    case Error(e) -> IntResult(tag: ERROR, value: e)
  }
}

fn client_config_not_unique_error -> Never {
  panic('a ClientConfig may only be updated if it has a single owner')
}

fn server_config_not_unique_error -> Never {
  panic('a ServerConfig may only be updated if it has a single owner')
}

# An error produced when creating a `ServerConfig`.
type pub copy enum ServerConfigError {
  # The certificate exists but is invalid, such as when it's revoked or not
  # encoded correctly.
  case InvalidCertificate

  # The private key exists but is invalid.
  case InvalidPrivateKey
}

impl Equal for ServerConfigError {
  fn pub ==(other: ServerConfigError) -> Bool {
    match (self, other) {
      case (InvalidCertificate, InvalidCertificate) -> true
      case (InvalidPrivateKey, InvalidPrivateKey) -> true
      case _ -> false
    }
  }
}

impl ToString for ServerConfigError {
  fn pub to_string -> String {
    match self {
      case InvalidCertificate -> 'the certificate is invalid'
      case InvalidPrivateKey -> 'the private key is invalid'
    }
  }
}

impl Format for ServerConfigError {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case InvalidCertificate -> formatter.tuple('InvalidCertificate').finish
      case InvalidPrivateKey -> formatter.tuple('InvalidPrivateKey').finish
    }
  }
}

# A type storing the configuration details for TLS clients.
#
# To configure a `Server`, use `ServerConfig` instead.
#
# Creating a `ClientConfig` is potentially expensive, depending on the amount of
# certificates that need to be processed. As such, it's recommended to only
# create a `ClientConfig` once and use `ClientConfig.clone` to clone it whenever
# necessary (e.g. when sharing a `ClientConfig` between processes), as cloning a
# `ClientConfig` is cheap.
type pub ClientConfig {
  let @raw: Pointer[UInt8]

  # Returns a new `ClientConfig` that uses the system's certificate store.
  #
  # If the system's TLS configuration can't be loaded, an `Option.None` is
  # returned.
  #
  # # Examples
  #
  # ```inko
  # import std.net.tls (ClientConfig)
  #
  # ClientConfig.new.some? # => true
  # ```
  fn pub static new -> Option[ClientConfig] {
    match inko_tls_client_config_new {
      case { @tag = OK, @value = v } -> {
        Option.Some(ClientConfig(v as Pointer[UInt8]))
      }
      case _ -> Option.None
    }
  }

  # Returns a new `ClientConfig` using the specified PEM encoded X.509
  # certificate.
  #
  # # Errors
  #
  # If the certificate isn't valid, a `None` is returned.
  #
  # # Examples
  #
  # ```inko
  # import std.net.tls (ClientConfig)
  # import std.crypto.x509 (Certificate)
  #
  # # In a real program you'd load the certificate from a file or a database.
  # let cert = Certificate.new(ByteArray.from_array[1, 2, 3, 4])
  #
  # ClientConfig
  #   .with_certificate(cert)
  #   .or_panic_with('the client configuration is invalid')
  # ```
  fn pub static with_certificate(
    certificate: ref Certificate,
  ) -> Option[ClientConfig] {
    match
      inko_tls_client_config_with_certificate(
        certificate.bytes.pointer,
        certificate.bytes.size,
      )
    {
      case { @tag = OK, @value = v } -> {
        Option.Some(ClientConfig(v as Pointer[UInt8]))
      }
      case _ -> Option.None
    }
  }

  # Adds the given ALPN names to `self`.
  #
  # # Panics
  #
  # This method panics if `self` has more than one owner, such as when
  # `ClientConfig.clone` is called or one or more `Client` instances using
  # `self` exist.
  #
  # # Examples
  #
  # ```inko
  # import std.net.tls (ClientConfig)
  #
  # ClientConfig
  #   .new
  #   .get
  #   .alpn(['h2', 'http/1.1'])
  # ```
  fn pub move alpn(names: ref Array[String]) -> Self {
    for name in names.iter {
      if !inko_tls_client_config_add_alpn(@raw, name.pointer, name.size) {
        client_config_not_unique_error
      }
    }

    self
  }
}

impl Drop for ClientConfig {
  fn mut drop {
    inko_tls_client_config_drop(@raw)
  }
}

impl Clone for ClientConfig {
  fn pub clone -> ClientConfig {
    ClientConfig(inko_tls_client_config_clone(@raw))
  }
}

# An error produced when creating a new client.
type pub inline enum ClientError {
  # The server name is not a valid DNS name or IP address.
  case InvalidServer

  # The handshake timed out.
  case TimedOut

  # The server's certificate is invalid.
  case InvalidCertificate

  # The TLS handshake couldn't be completed, such as when the client's "hello"
  # message contains invalid data.
  case InvalidHandshake
}

impl ToString for ClientError {
  fn pub to_string -> String {
    match self {
      case InvalidServer -> 'the server name is invalid'
      case InvalidCertificate -> "the server's certificate is invalid"
      case TimedOut -> 'the operation timed out'
      case InvalidHandshake -> "the TLS handshake couldn't be completed"
    }
  }
}

impl Format for ClientError {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case InvalidServer -> formatter.tuple('InvalidServer').finish
      case InvalidCertificate -> formatter.tuple('InvalidCertificate').finish
      case TimedOut -> formatter.tuple('TimedOut').finish
      case InvalidHandshake -> formatter.tuple('InvalidHandshake').finish
    }
  }
}

impl Equal for ClientError {
  fn pub ==(other: ref Self) -> Bool {
    match (self, other) {
      case (InvalidServer, InvalidServer) -> true
      case (InvalidHandshake, InvalidHandshake) -> true
      case (InvalidCertificate, InvalidCertificate) -> true
      case (TimedOut, TimedOut) -> true
      case _ -> false
    }
  }
}

# A type that acts as the client in a TLS session.
#
# `Client` values wrap existing sockets such as `std.net.socket.TcpClient` and
# apply TLS encryption/decryption to IO operations.
#
# # Closing TLS connections
#
# When a `Client` is dropped, the TLS connection is closed by sending the TLS
# `close_notify` message.
#
# # Examples
#
# ```inko
# import std.net.ip (IpAddress)
# import std.net.socket (TcpClient)
# import std.net.tls (Client, ClientConfig)
#
# let conf = ClientConfig.new
# let sock = TcpClient
#   .new(ips: [IpAddress.v4(127, 0, 0, 1)], port: 9000)
#   .or_panic_with('failed to connect to the server')
# let client = Client
#   .new(sock, conf, name: 'localhost')
#   .or_panic_with('the server name is invalid')
#
# client.write('ping').or_panic_with('failed to write the message')
#
# let response = ByteArray.new
#
# client.read_all(response).or_panic_with('failed to read the response')
# ```
type pub Client[T: mut + Deadline + RawSocketOperations] {
  # The socket wrapped by this `Client`.
  let pub @socket: T

  # The TLS connection state.
  let @state: Pointer[UInt8]

  # Returns a `Client` acting as the client in a TLS session.
  #
  # The `socket` argument is the socket (e.g. `std.net.socket.TcpClient`) to
  # wrap. This can be either an owned socket or a mutable borrow of a socket.
  #
  # The `name` argument is the DNS name to use for Server Name Indication (SNI).
  # Setting this to an IP address disables the use of SNI. In most cases you'll
  # want to set this to the DNS name of the server the socket is connecting to.
  #
  # The `config` argument is a `ClientConfig` instance to use for configuring
  # the TLS connection.
  #
  # This method returns once the TLS handshake is complete or an error is
  # encountered during the handshake.
  #
  # # Errors
  #
  # This method returns a `ClientError` if the handshake couldn't be completed,
  # such as when it times out or the server's certificate is invalid.
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (IpAddress)
  # import std.net.socket (TcpClient)
  # import std.net.tls (Client, ClientConfig)
  #
  # let conf = ClientConfig.new
  # let sock = TcpClient
  #   .new(ips: [IpAddress.v4(127, 0, 0, 1)], port: 9000)
  #   .or_panic_with('failed to connect to the server')
  #
  # Client.new(sock, conf, server: 'localhost').or_panic
  # ```
  fn pub static new(
    socket: T,
    config: ref ClientConfig,
    server: String,
  ) -> Result[Client[T], ClientError] {
    with_alpn(socket, config, server, DEFAULT_ALPN)
  }

  # Returns a `Client` with a list of enabled ALPN names for just this
  # connection.
  #
  # Refer to the documentation of `Client.new` for more details.
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (IpAddress)
  # import std.net.socket (TcpClient)
  # import std.net.tls (Client, ClientConfig)
  #
  # let conf = ClientConfig.new
  # let sock = TcpClient
  #   .new(ips: [IpAddress.v4(127, 0, 0, 1)], port: 9000)
  #   .or_panic_with('failed to connect to the server')
  #
  # Client
  #   .with_alpn(sock, conf, server: 'localhost', alpn: ['h2', 'http/1.1'])
  #   .or_panic
  # ```
  fn pub static with_alpn(
    socket: T,
    config: ref ClientConfig,
    server: String,
    alpn: ref Array[String],
  ) -> Result[Client[T], ClientError] {
    let alpn_raw = alpn.iter.map(fn (n) { n.to_primitive }).to_array
    let state = match
      inko_tls_client_connection_new(
        config.raw,
        server.to_primitive,
        alpn_raw.pointer,
        alpn_raw.size,
      )
    {
      case { @tag = OK, @value = v } -> v as Pointer[UInt8]
      case { @tag = NONE } -> throw ClientError.InvalidServer
      case _ -> throw ClientError.InvalidHandshake
    }

    match
      inko_tls_client_complete_io(
        socket.raw_socket,
        state,
        socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = NONE } -> {}
      case { @value = INVALID_CERT } -> throw ClientError.InvalidCertificate
      case { @value = v } -> {
        match Error.from_os_error(v) {
          case TimedOut -> throw ClientError.TimedOut
          case _ -> throw ClientError.InvalidHandshake
        }
      }
    }

    Result.Ok(Client(socket, state))
  }

  # Returns the negotiated ALPN name.
  #
  # If no name is negotiated (e.g. the client didn't supply any names) then an
  # `Option.None` is returned.
  fn pub alpn -> Option[String] {
    let prim = inko_tls_client_connection_alpn(@state)

    if prim.size > 0 {
      Option.Some(String.from_primitive(prim))
    } else {
      Option.None
    }
  }

  # Sends the TLS `close_notify` message to the socket, informing the peer that
  # the connection is being closed.
  fn mut close -> Result[Nil, Error] {
    match
      inko_tls_client_close(
        @socket.raw_socket,
        @state,
        @socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = NONE } -> Result.Ok(nil)
      case { @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Deadline for Client {
  fn pub mut timeout_after=[I: ToInstant](deadline: ref I) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl Drop for Client {
  fn mut drop {
    # Per the TLS specification, the connection _should_ be closed explicitly
    # when discarding the socket.
    let _ = close

    inko_tls_client_connection_drop(@state)
  }
}

impl Read[Error] for Client {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    into.reserve_exact(size)

    let len = into.size
    let ptr = ptr.add(into.pointer, len)

    match
      inko_tls_client_read(
        @socket.raw_socket,
        @state,
        ptr,
        size,
        @socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = OK, @value = v } -> {
        into.size = len + v
        Result.Ok(v)
      }
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl WriteInternal for Client {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    match
      inko_tls_client_write(
        @socket.raw_socket,
        @state,
        data,
        size,
        @socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = OK, @value = v } -> Result.Ok(v)
      case { @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Write[Error] for Client {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    write_all_internal(bytes.pointer, bytes.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

impl RawSocketOperations for Client {
  fn inline mut raw_socket -> Pointer[net.RawSocket] {
    @socket.raw_socket
  }

  fn inline raw_deadline -> Int {
    @socket.raw_deadline
  }
}

impl SendFile[Error] for Client {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    net.send_file_userspace(buffer, file, self)
  }
}

# A type storing the configuration details for TLS servers.
#
# To configure a `Client`, use `ClientConfig` instead.
#
# Creating a `ServerConfig` is potentially expensive, depending on the
# certificate and private key that are used. As such, it's recommended to only
# create a `ServerConfig` once and use `ServerConfig.clone` to clone it whenever
# necessary, as cloning a `ServerConfig` is cheap.
type pub ServerConfig {
  let @raw: Pointer[UInt8]

  # Returns a new `ServerConfig` using the specified PEM encoded X.509
  # certificate and private key.
  #
  # # Errors
  #
  # A `ServerConfigError` is returned if any of the following is true:
  #
  # - The certificate is invalid
  # - The private key is invalid
  #
  # # Examples
  #
  # ```inko
  # import std.net.tls (ServerConfig)
  # import std.crypto.x509 (Certificate, PrivateKey)
  #
  # let cert = Certificate.new(ByteArray.from_array([1, 2, 3]))
  # let key = PrivateKey.new(ByteArray.from_array([4, 5, 6]))
  #
  # ServerConfig
  #   .new(cert, key)
  #   .or_panic
  # ```
  fn pub static new(
    certificate: ref Certificate,
    key: ref PrivateKey,
  ) -> Result[ServerConfig, ServerConfigError] {
    match
      inko_tls_server_config_new(
        certificate: certificate.bytes.pointer,
        certificate_size: certificate.bytes.size,
        key: key.bytes.pointer,
        key_size: key.bytes.size,
      )
    {
      case { @tag = OK, @value = v } -> {
        Result.Ok(ServerConfig(v as Pointer[UInt8]))
      }
      case { @value = e } if e as Int == INVALID_CERT -> {
        Result.Error(ServerConfigError.InvalidCertificate)
      }
      case _ -> Result.Error(ServerConfigError.InvalidPrivateKey)
    }
  }

  # Adds the given ALPN names to `self`.
  #
  # # Panics
  #
  # This method panics if `self` has more than one owner, such as when
  # `ServerConfig.clone` is called or one or more `Server` instances using
  # `self` exist.
  #
  # # Examples
  #
  # ```inko
  # import std.net.tls (ServerConfig)
  # import std.crypto.x509 (Certificate, PrivateKey)
  #
  # let cert = Certificate.new(ByteArray.from_array([1, 2, 3]))
  # let key = PrivateKey.new(ByteArray.from_array([4, 5, 6]))
  #
  # ServerConfig
  #   .new(cert, key)
  #   .or_panic
  #   .alpn(['h2', 'http/1.1'])
  # ```
  fn pub move alpn(names: ref Array[String]) -> Self {
    for name in names.iter {
      if !inko_tls_server_config_add_alpn(@raw, name.pointer, name.size) {
        server_config_not_unique_error
      }
    }

    self
  }
}

impl Drop for ServerConfig {
  fn mut drop {
    inko_tls_server_config_drop(@raw)
  }
}

impl Clone for ServerConfig {
  fn pub clone -> ServerConfig {
    ServerConfig(inko_tls_server_config_clone(@raw))
  }
}

# An error produced when creating a new server.
type pub inline enum ServerError {
  # The handshake timed out.
  case TimedOut

  # The TLS handshake couldn't be completed, such as when the client's "hello"
  # message contains invalid data.
  case InvalidHandshake
}

impl ToString for ServerError {
  fn pub to_string -> String {
    match self {
      case InvalidHandshake -> "the TLS handshake couldn't be completed"
      case TimedOut -> 'the operation timed out'
    }
  }
}

impl Format for ServerError {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case InvalidHandshake -> formatter.tuple('InvalidHandshake').finish
      case TimedOut -> formatter.tuple('TimedOut').finish
    }
  }
}

impl Equal for ServerError {
  fn pub ==(other: ref Self) -> Bool {
    match (self, other) {
      case (InvalidHandshake, InvalidHandshake) -> true
      case (TimedOut, TimedOut) -> true
      case _ -> false
    }
  }
}

# A type that acts as the server in a TLS session.
#
# `Server` values wrap existing sockets such as `std.net.socket.TcpClient` and
# apply TLS encryption/decryption to IO operations.
#
# # Closing TLS connections
#
# When a `Client` is dropped the TLS connection is closed by sending the TLS
# `close_notify` message.
#
# # Examples
#
# ```inko
# import std.crypto.x509 (Certificate, PrivateKey)
# import std.net.ip (IpAddress)
# import std.net.socket (TcpServer)
# import std.net.tls (Server, ServerConfig)
#
# let cert = Certificate.new(ByteArray.from_array([1, 2, 3]))
# let key = PrivateKey.new(ByteArray.from_array([4, 5, 6]))
#
# let conf = ServerConfig
#   .new(cert, key)
#   .or_panic_with('failed to create the server configuration')
#
# let server = TcpServer
#   .new(ip: IpAddress.v4(0, 0, 0, 0), port: 9000)
#   .or_panic_with('failed to start the server')
#
# let con = server
#   .accept
#   .map(fn (sock) { Server.new(sock, conf).or_panic })
#   .or_panic_with('failed to accept the new connection')
#
# let bytes = ByteArray.new
#
# con.read(into: bytes, size: 32).or_panic_with('failed to read the data')
# ```
type pub Server[T: mut + Deadline + RawSocketOperations] {
  # The socket wrapped by this `Server`.
  let pub @socket: T

  # The TLS connection state.
  let @state: Pointer[UInt8]

  # Returns a `Server` acting as the server in a TLS session.
  #
  # The `socket` argument is the socket (e.g. `std.net.socket.TcpClient`) to
  # wrap. This can be either an owned socket or a mutable borrow of a socket.
  #
  # The `config` argument is a `ServerConfig` instance to use for configuring
  # the TLS connection.
  #
  # This method returns once the TLS handshake is complete or an error is
  # encountered during the handshake.
  #
  # # Errors
  #
  # This method returns a `ServerError` if the TLS handshake couldn't be
  # completed, such as when it times out or the client's hello message is
  # invalid.
  #
  # # Examples
  #
  # ```inko
  # import std.crypto.x509 (Certificate, PrivateKey)
  # import std.net.ip (IpAddress)
  # import std.net.socket (TcpServer)
  # import std.net.tls (Server, ServerConfig)
  #
  # let cert = Certificate.new(ByteArray.from_array([1, 2, 3]))
  # let key = PrivateKey.new(ByteArray.from_array([4, 5, 6]))
  #
  # let conf = ServerConfig
  #   .new(cert, key)
  #   .or_panic_with('failed to create the server configuration')
  #
  # let server = TcpServer
  #   .new(ip: IpAddress.v4(0, 0, 0, 0), port: 9000)
  #   .or_panic_with('failed to start the server')
  #
  # server
  #   .accept
  #   .map(fn (sock) { Server.new(sock, conf).or_panic })
  #   .or_panic_with('failed to accept the new connection')
  # ```
  fn pub static new(
    socket: T,
    config: ref ServerConfig,
  ) -> Result[Server[T], ServerError] {
    let state = inko_tls_server_connection_new(config.raw)

    match
      inko_tls_server_complete_io(
        socket.raw_socket,
        state,
        socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = NONE } -> {}
      case { @value = v } -> {
        match Error.from_os_error(v) {
          case TimedOut -> throw ServerError.TimedOut
          case _ -> throw ServerError.InvalidHandshake
        }
      }
    }

    Result.Ok(Server(socket, state))
  }

  # Returns the negotiated ALPN name.
  #
  # If no name is negotiated (e.g. the client didn't supply any names) then an
  # `Option.None` is returned.
  fn pub alpn -> Option[String] {
    let prim = inko_tls_server_connection_alpn(@state)

    if prim.size > 0 {
      Option.Some(String.from_primitive(prim))
    } else {
      Option.None
    }
  }

  # Sends the TLS `close_notify` message to the socket, informing the peer that
  # the connection is being closed.
  fn mut close -> Result[Nil, Error] {
    match
      inko_tls_server_close(
        @socket.raw_socket,
        @state,
        @socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = NONE } -> Result.Ok(nil)
      case { @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Deadline for Server {
  fn pub mut timeout_after=[I: ToInstant](deadline: ref I) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl Drop for Server {
  fn mut drop {
    # Per the TLS specification, the connection _should_ be closed explicitly
    # when discarding the socket.
    let _ = close

    inko_tls_server_connection_drop(@state)
  }
}

impl Read[Error] for Server {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    into.reserve_exact(size)

    let len = into.size
    let ptr = ptr.add(into.pointer, len)

    match
      inko_tls_server_read(
        @socket.raw_socket,
        @state,
        ptr,
        size,
        @socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = OK, @value = v } -> {
        into.size = len + v
        Result.Ok(v)
      }
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl WriteInternal for Server {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    match
      inko_tls_server_write(
        @socket.raw_socket,
        @state,
        data,
        size,
        @socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = OK, @value = v } -> Result.Ok(v)
      case { @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Write[Error] for Server {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    write_all_internal(bytes.pointer, bytes.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

impl RawSocketOperations for Server {
  fn inline mut raw_socket -> Pointer[net.RawSocket] {
    @socket.raw_socket
  }

  fn inline raw_deadline -> Int {
    @socket.raw_deadline
  }
}

impl SendFile[Error] for Server {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    net.send_file_userspace(buffer, file, self)
  }
}

# An error produced when creating a `PendingServer` or when converting it into a
# `Server`.
type pub inline enum PendingServerError {
  # The client's hello message is invalid.
  case InvalidClientHello

  # The handshake timed out.
  case TimedOut

  # The TLS handshake couldn't be completed, such as when the client's "hello"
  # message contains invalid data.
  case InvalidHandshake

  # An error produced while reading TLS data.
  case Read(Error)
}

impl ToString for PendingServerError {
  fn pub to_string -> String {
    match self {
      case InvalidClientHello -> "the client's hello message is invalid"
      case InvalidHandshake -> "the TLS handshake couldn't be completed"
      case TimedOut -> 'the operation timed out'
      case Read(e) -> 'failed to read the TLS data: ${e}'
    }
  }
}

impl Format for PendingServerError {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case InvalidClientHello -> formatter.tuple('InvalidClientHello').finish
      case InvalidHandshake -> formatter.tuple('InvalidHandshake').finish
      case TimedOut -> formatter.tuple('TimedOut').finish
      case Read(v) -> formatter.tuple('Read').field(v).finish
    }
  }
}

impl Equal for PendingServerError {
  fn pub ==(other: ref Self) -> Bool {
    match (self, other) {
      case (InvalidClientHello, InvalidClientHello) -> true
      case (InvalidHandshake, InvalidHandshake) -> true
      case (TimedOut, TimedOut) -> true
      case (Read(a), Read(b)) -> a == b
      case _ -> false
    }
  }
}

# A type that represents a socket that has parsed the client's "hello" message
# and may be converted into a `Server`.
#
# # Examples
#
# ```inko
# import std.crypto.x509 (Certificate, PrivateKey)
# import std.net.ip (IpAddress)
# import std.net.socket (TcpServer)
# import std.net.tls (PendingServer, ServerConfig)
#
# let tcp_server = TcpServer
#   .new(IpAddress.v4(127, 0, 0, 1), port: 8_000)
#   .or_panic
# let pending = PendingServer.new(tcp_server.accept.or_panic).or_panic
# let (cert, key) = match pending.server_name {
#   case Some('foo.com') -> {
#     (
#       Certificate.new('foo.com cert'.to_byte_array),
#       PrivateKey.new('foo.com key'.to_byte_array),
#     )
#   }
#   case Some('bar.com') -> {
#     (
#       Certificate.new('bar.com cert'.to_byte_array),
#       PrivateKey.new('bar.com key'.to_byte_array),
#     )
#   }
#   case _ -> panic('unsupported server name')
# }
#
# let conf = ServerConfig.new(cert, key).or_panic
#
# pending.into_server(conf).or_panic
# ```
type pub PendingServer[T: mut + Deadline + RawSocketOperations] {
  # The socket to use for the server.
  #
  # This uses an `Option` so we can move the socket out of a `PendingServer` in
  # spite of it defining a custom destructor.
  let mut @socket: Option[T]

  # The rustls `Accepted` state.
  let @state: Pointer[UInt8]

  # Returns a new `PendingServer` that uses the given socket.
  #
  # This method performs the initial handshake and returns a `PendingServer` if
  # this succeeeds.
  #
  # Once created, you can use `PendingServer.server_name` to determine what TLS
  # configuration to use based on the server name indicator.
  #
  # # Errors
  #
  # If the handshake fails (e.g. the client's hello message is invalid) or times
  # out, a `PendingServerError` is returned.
  fn pub static new(socket: T) -> Result[Self, PendingServerError] {
    let state = match
      inko_tls_pending_server_new(
        socket.raw_socket,
        socket.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = OK, @value = state } -> state as Pointer[UInt8]
      case { @value = code } -> {
        let code = code as Int

        if code == INVALID_CLIENT_HELLO {
          throw PendingServerError.InvalidClientHello
        } else {
          match Error.from_os_error(code) {
            case TimedOut -> throw PendingServerError.TimedOut
            case e -> throw PendingServerError.Read(e)
          }
        }
      }
    }

    Result.Ok(Self(socket: Option.Some(socket), state: state))
  }

  # Returns a mutable borrow of the underlying socket.
  fn pub mut socket -> mut T {
    @socket.as_mut.get
  }

  # Returns the server name indicator.
  #
  # If no server name is given, an `Option.None` is returned.
  fn pub server_name -> Option[String] {
    let prim = inko_tls_pending_server_name(@state)

    if prim.size > 0 {
      Option.Some(String.from_borrowed_primitive(prim))
    } else {
      Option.None
    }
  }

  # Converts `self` into a `Server` using the given TLS configuration.
  #
  # # Errors
  #
  # This method may fail if the client's hello message is invalid or if the TLS
  # handshake can't be completed.
  fn pub move into_server(
    config: ref ServerConfig,
  ) -> Result[Server[T], PendingServerError] {
    let sock = (@socket := Option.None).get
    let server_state = match
      inko_tls_pending_server_into_server_connection(
        @state,
        config.raw,
        sock.raw_socket,
        sock.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = OK, @value = state } -> state as Pointer[UInt8]
      case _ -> throw PendingServerError.InvalidClientHello
    }

    match
      inko_tls_server_complete_io(
        sock.raw_socket,
        server_state,
        sock.raw_deadline,
        mut read_callback,
        mut write_callback,
      )
    {
      case { @tag = NONE } -> {}
      case { @value = v } -> {
        match Error.from_os_error(v) {
          case TimedOut -> throw PendingServerError.TimedOut
          case _ -> throw PendingServerError.InvalidHandshake
        }
      }
    }

    Result.Ok(Server(socket: sock, state: server_state))
  }
}

impl Drop for PendingServer {
  fn mut drop {
    if @socket.some? { inko_tls_pending_server_drop(@state) }
  }
}
