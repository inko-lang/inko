import std.bytes (Bytes)
import std.ptr

# The code in this module is generated using ./std/gen/hash.py and _must not_ be
# edited by hand. For more information, refer to ./std/gen/README.md.

let G = [
  0, 0, 0, 0, 59, 116, 0, 0, 0, 0, 43, 0, 0, 111, 0, 0, 57, 0, 0, 100, 0, 17,
  82, 108, 123, 0, 35, 0, 117, 110, 0, 0, 0, 0, 0, 0, 73, 0, 92, 0, 0, 0, 0, 48,
  56, 11, 0, 31, 90, 0, 0, 0, 0, 90, 121, 0, 47, 2, 0, 0, 9, 54, 11, 0, 2, 20,
  53, 1, 0, 56, 0, 36, 37, 0, 0, 0, 36, 0, 42, 19, 20, 26, 30, 121, 0, 0, 33,
  32, 81, 0, 9, 9, 57, 7, 0, 15, 68, 9, 51, 90, 0, 119, 25, 50, 0, 16, 44, 41,
  55, 120, 0, 9, 0, 30, 0, 94, 0, 30, 42, 120, 25, 0, 0, 26, 13, 0, 115, 5,
]
let S1 = [
  44, 46, 97, 50, 29, 113, 102, 112, 61, 78, 87, 124, 49, 125, 2, 105, 108, 91,
  59, 101, 2, 17, 52, 22, 112, 64, 39, 28, 37, 111, 56, 106,
]
let S2 = [
  22, 100, 37, 107, 104, 90, 48, 3, 29, 65, 17, 119, 71, 35, 70, 117, 7, 104,
  115, 78, 15, 77, 119, 40, 94, 68, 33, 90, 41, 18, 75, 51,
]
let KEYS = [
  'accept',
  'accept-charset',
  'accept-encoding',
  'accept-language',
  'accept-ranges',
  'access-control-allow-credentials',
  'access-control-allow-headers',
  'access-control-allow-methods',
  'access-control-allow-origin',
  'access-control-max-age',
  'access-control-method',
  'access-control-request-method',
  'access-control-request-methods',
  'access-control-request-headers',
  'age',
  'allow',
  'alt-svc',
  'authorization',
  'cache-control',
  'connection',
  'content-disposition',
  'content-encoding',
  'content-language',
  'content-length',
  'content-location',
  'content-range',
  'content-type',
  'cookie',
  'date',
  'etag',
  'expect',
  'expires',
  'from',
  'host',
  'if-match',
  'if-modified-since',
  'if-none-match',
  'if-range',
  'if-unmodified-since',
  'keep-alive',
  'last-modified',
  'link',
  'location',
  'max-forwards',
  'origin',
  'pragma',
  'proxy-authenticate',
  'proxy-authorization',
  'proxy-connection',
  'range',
  'referer',
  'retry-after',
  'server',
  'set-cookie',
  'strict-transport-security',
  'trailer',
  'transfer-encoding',
  'upgrade',
  'upgrade-insecure-requests',
  'user-agent',
  'vary',
  'via',
  'www-authenticate',
  'sec-fetch-site',
  'sec-fetch-mode',
  'sec-fetch-user',
  'sec-fetch-dest',
  'sec-websocket-accept',
  'sec-websocket-extensions',
  'sec-websocket-key',
  'sec-websocket-protocol',
  'sec-websocket-version',
]

fn inline hash[B: Bytes](key: ref B) -> (Int, Int) {
  let mut i = 0
  let mut h1 = 0
  let mut h2 = 0

  while i < key.size {
    let s1 = S1.get_unchecked(i)
    let s2 = S2.get_unchecked(i)
    let k = ptr.add(key.pointer, i).0 as Int

    h1 = h1.wrapping_add(s1.wrapping_mul(k))
    h2 = h2.wrapping_add(s2.wrapping_mul(k))
    i += 1
  }

  (h1 & 127, h2 & 127)
}

# Returns the index of the given key.
#
# If the key is an unknown key, `-1` is returned.
fn inline index_of[B: Bytes](key: ref B) -> Int {
  if key.size > 32 { return -1 }

  let (k1, k2) = hash(key)
  let a = G.get_unchecked(k1)
  let b = G.get_unchecked(k2)
  let i = a.wrapping_add(b) & 127

  match KEYS.get(i) {
    case Ok(v) if key.equals?(v) -> i
    case _ -> -1
  }
}
