import std.bytes (Bytes)

# The code in this module is generated using ./std/gen/hash.py and _must not_ be
# edited by hand. For more information, refer to ./std/gen/README.md.

let G = [
  0, 0, 0, 64, 0, 32, 0, 52, 44, 59, 0, 84, 30, 63, 20, 0, 32, 44, 20, 44, 0, 3,
  59, 0, 58, 73, 76, 0, 8, 38, 0, 18, 31, 58, 3, 43, 52, 36, 17, 20, 0, 46, 17,
  33, 50, 10, 79, 41, 8, 0, 17, 40, 73, 10, 5, 28, 0, 21, 23, 19, 0, 24, 0, 0,
  0, 28, 3, 23, 20, 89, 9, 88, 19, 56, 23, 6, 87, 33, 7, 41, 45, 22, 34, 79, 42,
  84, 19, 57, 50, 6,
]
let S1 = [
  27, 48, 23, 34, 52, 26, 36, 14, 63, 70, 79, 57, 36, 15, 78, 72, 81, 10, 4, 1,
  5, 58, 69, 33, 3, 15, 89, 51, 4, 24, 32, 42,
]
let S2 = [
  86, 7, 7, 68, 82, 35, 38, 89, 71, 60, 6, 86, 39, 86, 45, 6, 51, 83, 8, 44, 71,
  29, 36, 50, 55, 22, 55, 30, 58, 24, 77, 59,
]
let KEYS = [
  'accept',
  'accept-charset',
  'accept-encoding',
  'accept-language',
  'accept-ranges',
  'access-control-allow-credentials',
  'access-control-allow-headers',
  'access-control-allow-methods',
  'access-control-allow-origin',
  'access-control-max-age',
  'access-control-method',
  'access-control-request-method',
  'access-control-request-methods',
  'access-control-request-headers',
  'age',
  'allow',
  'alt-svc',
  'authorization',
  'cache-control',
  'connection',
  'content-disposition',
  'content-encoding',
  'content-language',
  'content-length',
  'content-location',
  'content-range',
  'content-type',
  'cookie',
  'date',
  'etag',
  'expect',
  'expires',
  'from',
  'host',
  'if-match',
  'if-modified-since',
  'if-none-match',
  'if-range',
  'if-unmodified-since',
  'keep-alive',
  'last-modified',
  'link',
  'location',
  'max-forwards',
  'origin',
  'pragma',
  'proxy-authenticate',
  'proxy-authorization',
  'proxy-connection',
  'range',
  'referer',
  'retry-after',
  'server',
  'set-cookie',
  'strict-transport-security',
  'trailer',
  'transfer-encoding',
  'upgrade',
  'upgrade-insecure-requests',
  'user-agent',
  'vary',
  'via',
  'www-authenticate',
  'sec-fetch-site',
  'sec-fetch-mode',
  'sec-fetch-user',
  'sec-fetch-dest',
  'sec-websocket-accept',
  'sec-websocket-extensions',
  'sec-websocket-key',
  'sec-websocket-protocol',
  'sec-websocket-version',
]

fn inline hash[B: Bytes](key: ref B, salt: ref Array[Int]) -> Int {
  let mut i = 0
  let mut h = 0

  while i < key.size {
    h = h.wrapping_add(salt.get(i).or_panic.wrapping_mul(key.get(i).or_panic))
    i += 1
  }

  h % 90
}

# Returns the index of the given key.
#
# If the key is an unknown key, `-1` is returned.
fn index_of[B: Bytes](key: ref B) -> Int {
  if key.size > 32 { return -1 }

  let a = G.get(hash(key, S1)).or_panic
  let b = G.get(hash(key, S2)).or_panic
  let i = a.wrapping_add(b) % 90

  match KEYS.get(i) {
    case Ok(v) if key.equals?(v) -> i
    case _ -> -1
  }
}
