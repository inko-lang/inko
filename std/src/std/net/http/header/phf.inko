import std.bytes (Bytes)

# The code in this module is generated using ./std/gen/hash.py and _must not_ be
# edited by hand. For more information, refer to ./std/gen/README.md.

let G = [
  0, 0, 0, 0, 0, 0, 0, 69, 0, 0, 0, 13, 0, 0, 57, 73, 0, 0, 0, 0, 88, 45, 0, 95,
  65, 0, 25, 93, 0, 24, 0, 62, 0, 0, 33, 34, 0, 53, 0, 0, 22, 44, 70, 120, 0,
  42, 0, 0, 0, 0, 106, 0, 0, 115, 0, 0, 32, 36, 0, 48, 0, 124, 0, 17, 0, 0, 126,
  0, 12, 39, 78, 126, 14, 73, 44, 0, 114, 9, 0, 71, 41, 27, 0, 33, 111, 16, 44,
  39, 9, 56, 65, 97, 114, 18, 4, 8, 85, 18, 17, 0, 0, 49, 79, 125, 15, 0, 6, 25,
  126, 0, 0, 0, 55, 0, 0, 0, 40, 49, 60, 0, 72, 0, 0, 23, 101, 0, 0, 35,
]
let S1 = [
  92, 79, 103, 125, 37, 86, 14, 81, 32, 63, 81, 119, 67, 57, 23, 71, 119, 47,
  12, 18, 48, 115, 18, 31, 26, 68, 64, 59, 13, 35, 8, 54,
]
let S2 = [
  83, 116, 9, 69, 34, 40, 13, 102, 10, 29, 87, 32, 15, 127, 34, 104, 93, 122,
  12, 18, 42, 66, 62, 8, 31, 21, 127, 107, 26, 28, 21, 34,
]
let KEYS = [
  'accept',
  'accept-charset',
  'accept-encoding',
  'accept-language',
  'accept-ranges',
  'access-control-allow-credentials',
  'access-control-allow-headers',
  'access-control-allow-methods',
  'access-control-allow-origin',
  'access-control-max-age',
  'access-control-method',
  'access-control-request-method',
  'access-control-request-methods',
  'access-control-request-headers',
  'age',
  'allow',
  'alt-svc',
  'authorization',
  'cache-control',
  'connection',
  'content-disposition',
  'content-encoding',
  'content-language',
  'content-length',
  'content-location',
  'content-range',
  'content-type',
  'cookie',
  'date',
  'etag',
  'expect',
  'expires',
  'from',
  'host',
  'if-match',
  'if-modified-since',
  'if-none-match',
  'if-range',
  'if-unmodified-since',
  'keep-alive',
  'last-modified',
  'link',
  'location',
  'max-forwards',
  'origin',
  'pragma',
  'proxy-authenticate',
  'proxy-authorization',
  'proxy-connection',
  'range',
  'referer',
  'retry-after',
  'server',
  'set-cookie',
  'strict-transport-security',
  'trailer',
  'transfer-encoding',
  'upgrade',
  'upgrade-insecure-requests',
  'user-agent',
  'vary',
  'via',
  'www-authenticate',
  'sec-fetch-site',
  'sec-fetch-mode',
  'sec-fetch-user',
  'sec-fetch-dest',
  'sec-websocket-accept',
  'sec-websocket-extensions',
  'sec-websocket-key',
  'sec-websocket-protocol',
  'sec-websocket-version',
]

fn inline hash[B: Bytes](key: ref B, salt: ref Array[Int]) -> Int {
  let mut i = 0
  let mut h = 0

  while i < key.size {
    h = h.wrapping_add(salt.get(i).or_panic.wrapping_mul(key.get(i).or_panic))
    i += 1
  }

  h & 127
}

# Returns the index of the given key.
#
# If the key is an unknown key, `-1` is returned.
fn index_of[B: Bytes](key: ref B) -> Int {
  if key.size > 32 { return -1 }

  let a = G.get(hash(key, S1)).or_panic
  let b = G.get(hash(key, S2)).or_panic
  let i = a.wrapping_add(b) & 127

  match KEYS.get(i) {
    case Ok(v) if key.equals?(v) -> i
    case _ -> -1
  }
}
