import std.alloc
import std.bytes (Bytes)
import std.fmt (Formatter)
import std.hash (Hasher)
import std.net.http (Method)
import std.string (ToString)

# The code in this module is generated and _must not_ be edited by hand. For
# more information, refer to ./std/gen/README.md.

let MIN = 3
let MAX = 7

fn inline string_to_int[B: Bytes](value: ref B) -> Int {
  let val = 0 as Uint64
  let len = value.size

  alloc.copy(from: value.pointer, to: (mut val) as Pointer[Uint8], size: len)
  val as Int
}

fn parse[B: Bytes + ToString](input: ref B) -> Option[Method] {
  let len = input.size

  if len < MIN or len > MAX { return Option.None }

  let val = string_to_int(input)
  let start = val & 0xFF

  match len {
    case 3 -> {
      match start {
        case 71 if val == 0x544547 -> Option.Some(Method.Get)
        case 80 if val == 0x545550 -> Option.Some(Method.Put)
        case _ -> Option.None
      }
    }
    case 4 -> {
      match start {
        case 72 if val == 0x44414548 -> Option.Some(Method.Head)
        case 80 if val == 0x54534f50 -> Option.Some(Method.Post)
        case _ -> Option.None
      }
    }
    case 5 -> {
      match start {
        case 84 if val == 0x4543415254 -> Option.Some(Method.Trace)
        case _ -> Option.None
      }
    }
    case 6 -> {
      match start {
        case 68 if val == 0x4554454c4544 -> Option.Some(Method.Delete)
        case _ -> Option.None
      }
    }
    case 7 -> {
      match start {
        case 67 if val == 0x5443454e4e4f43 -> Option.Some(Method.Connect)
        case 79 if val == 0x534e4f4954504f -> Option.Some(Method.Options)
        case _ -> Option.None
      }
    }
    case _ -> Option.None
  }
}

fn hash[H: mut + Hasher](hasher: mut H, method: Method) {
  match method {
    case Connect -> 0.hash(hasher)
    case Delete -> 1.hash(hasher)
    case Get -> 2.hash(hasher)
    case Head -> 3.hash(hasher)
    case Options -> 4.hash(hasher)
    case Post -> 5.hash(hasher)
    case Put -> 6.hash(hasher)
    case Trace -> 7.hash(hasher)
  }
}

fn eq(left: Method, right: Method) -> Bool {
  match (left, right) {
    case (Connect, Connect) -> true
    case (Delete, Delete) -> true
    case (Get, Get) -> true
    case (Head, Head) -> true
    case (Options, Options) -> true
    case (Post, Post) -> true
    case (Put, Put) -> true
    case (Trace, Trace) -> true
    case _ -> false
  }
}

fn to_string(method: Method) -> String {
  match method {
    case Connect -> 'CONNECT'
    case Delete -> 'DELETE'
    case Get -> 'GET'
    case Head -> 'HEAD'
    case Options -> 'OPTIONS'
    case Post -> 'POST'
    case Put -> 'PUT'
    case Trace -> 'TRACE'
  }
}

fn format(formatter: mut Formatter, method: Method) {
  match method {
    case Connect -> formatter.tuple('Connect').finish
    case Delete -> formatter.tuple('Delete').finish
    case Get -> formatter.tuple('Get').finish
    case Head -> formatter.tuple('Head').finish
    case Options -> formatter.tuple('Options').finish
    case Post -> formatter.tuple('Post').finish
    case Put -> formatter.tuple('Put').finish
    case Trace -> formatter.tuple('Trace').finish
  }
}
