# IP and Unix domain sockets.
#
# This module provides types for various socket types, such as TCP, UDP and Unix
# sockets.
#
# The types `Socket` and `UnixSocket` are low-level sockets that implement most
# of the socket logic. Types such as `TcpServer` and `TcpClient` wrap these
# sockets to make it easier to create commonly used sockets, such as a TCP
# client.
#
# # Deadlines and timeouts
#
# Socket timeouts are supported through a mechanism known as a "deadline". A
# deadline specifies the time after which socket operations must time out. While
# deadlines can be constructed from durations (e.g. using `std.time.Duration`),
# they represent fixed points in time.
#
# The use of deadlines instead of timeouts makes it easier to apply time limits
# to multiple operations. Consider the following chain of events:
#
# 1. read()
# 1. write()
# 1. read()
#
# Traditionally one might set a timeout such as 10 seconds. This poses a
# problem: the timeout is applied to every operation, meaning each operation is
# allowed to run up to 10 seconds, resulting in a total maximum runtime of 30
# seconds.
#
# Using deadlines one sets a deadline in the future, and no matter the amount of
# operations performed, the operations time out once we cross the deadline. In
# our above example that means we can easily limit the total runtime to 10
# seconds using a deadline that's 10 seconds in the future.
#
# Deadlines are set using `Socket.timeout_after` and `UnixSocket.timeout_after`.
# Here's an example using deadlines to limit the time spent waiting for a client
# to connect:
#
#     import std.net.ip (IpAddress)
#     import std.net.socket (TcpServer)
#     import std.time (Duration)
#
#     let server = TcpServer.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9000).get
#
#     server.socket.timeout_after = Duration.from_secs(3)
#
#     # This times out after roughly three seconds.
#     server.accept.get
#
# For more information about timeouts versus deadlines, consider reading [this
# article](https://vorpus.org/blog/timeouts-and-cancellation-for-humans/).
import std.cmp (Equal)
import std.drop (Drop)
import std.fmt (Format, Formatter)
import std.fs.path (Path)
import std.io (Error, Read, Write)
import std.net.ip (IpAddress)
import std.string (ToString)
import std.time (Duration, ToInstant)

class extern RawSocket {
  let @inner: Int32
  let @registered: UInt8
  let @unix: UInt8
}

class extern RawAddress {
  let @address: String
  let @port: Int
}

class extern AnyResult {
  let @tag: Int
  let @value: UInt64
}

class extern IntResult {
  let @tag: Int
  let @value: Int
}

fn extern inko_socket_new(
  proto: Int,
  kind: Int,
  out: Pointer[RawSocket],
) -> Int64

fn extern inko_socket_accept(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  deadline: Int,
  out: Pointer[RawSocket],
) -> Int64

fn extern inko_socket_local_address(
  state: Pointer[UInt8],
  socket: Pointer[RawSocket],
  out: Pointer[RawAddress],
) -> Int64

fn extern inko_socket_peer_address(
  state: Pointer[UInt8],
  socket: Pointer[RawSocket],
  out: Pointer[RawAddress],
) -> Int64

fn extern inko_socket_receive_from(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: mut ByteArray,
  amount: Int,
  deadline: Int,
  out: Pointer[RawAddress],
) -> Int64

fn extern inko_socket_bind(
  socket: Pointer[RawSocket],
  address: String,
  port: Int,
) -> IntResult

fn extern inko_socket_read(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: mut ByteArray,
  amount: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_connect(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  address: String,
  port: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_listen(
  socket: Pointer[RawSocket],
  value: Int,
) -> IntResult

fn extern inko_socket_drop(socket: Pointer[RawSocket])

fn extern inko_socket_send_bytes_to(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: ref ByteArray,
  address: String,
  port: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_send_string_to(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: String,
  address: String,
  port: Int,
  deadline: Int,
) -> IntResult

fn extern inko_socket_write_bytes(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: ref ByteArray,
  deadline: Int,
) -> IntResult

fn extern inko_socket_write_string(
  state: Pointer[UInt8],
  process: Pointer[UInt8],
  socket: Pointer[RawSocket],
  buffer: String,
  deadline: Int,
) -> IntResult

fn extern inko_socket_try_clone(
  socket: Pointer[RawSocket],
  out: Pointer[RawSocket],
) -> Int64

fn extern inko_socket_shutdown_read(socket: Pointer[RawSocket]) -> IntResult

fn extern inko_socket_shutdown_write(socket: Pointer[RawSocket]) -> IntResult

fn extern inko_socket_shutdown_read_write(
  socket: Pointer[RawSocket],
) -> IntResult

fn extern inko_socket_set_broadcast(
  socket: Pointer[RawSocket],
  value: Bool,
) -> IntResult

fn extern inko_socket_set_keepalive(
  socket: Pointer[RawSocket],
  value: Bool,
) -> IntResult

fn extern inko_socket_set_linger(
  socket: Pointer[RawSocket],
  value: Int,
) -> IntResult

fn extern inko_socket_set_recv_size(
  socket: Pointer[RawSocket],
  value: Int,
) -> IntResult

fn extern inko_socket_set_send_size(
  socket: Pointer[RawSocket],
  value: Int,
) -> IntResult

fn extern inko_socket_set_ttl(
  socket: Pointer[RawSocket],
  value: Int,
) -> IntResult

fn extern inko_socket_set_nodelay(
  socket: Pointer[RawSocket],
  value: Bool,
) -> IntResult

fn extern inko_socket_set_only_v6(
  socket: Pointer[RawSocket],
  value: Bool,
) -> IntResult

fn extern inko_socket_set_reuse_address(
  socket: Pointer[RawSocket],
  value: Bool,
) -> IntResult

fn extern inko_socket_set_reuse_port(
  socket: Pointer[RawSocket],
  value: Bool,
) -> IntResult

# The maximum value valid for a listen() call.
#
# Linux and FreeBSD do not allow for values greater than this as they internally
# use an u16, so we'll limit the backlog to this value. We don't use SOMAXCONN
# because it might be hardcoded. This means that setting `net.core.somaxconn` on
# Linux (for example) would have no effect.
let MAXIMUM_LISTEN_BACKLOG = 65_535

# A value that signals the lack of a socket deadline.
let NO_DEADLINE = -1
let IPV4 = 0
let IPV6 = 1
let UNIX = 2

# The type of a socket.
class pub enum Type {
  # The type corresponding to `SOCK_STREAM`.
  case STREAM

  # The type corresponding to `SOCK_DGRAM`.
  case DGRAM

  # The type corresponding to `SOCK_SEQPACKET`.
  case SEQPACKET

  # The type corresponding to `SOCK_RAW`.
  case RAW

  # Converts a `Type` into the underlying `SOCK_*` integer.
  fn pub move into_int -> Int {
    match self {
      case STREAM -> 0
      case DGRAM -> 1
      case SEQPACKET -> 2
      case RAW -> 3
    }
  }
}

# An IPv4 or IPv6 socket address.
class pub SocketAddress {
  # The IPv4/IPv6 address of this socket address.
  #
  # This is stored as a `String` so we don't need to parse the address every
  # time a `SocketAddress` is created.
  let pub @address: String

  # The port number of this socket address.
  let pub @port: Int

  fn pub static new(address: String, port: Int) -> SocketAddress {
    SocketAddress { @address = address, @port = port }
  }

  # Returns the IPv4/IPv6 address associated with `self`.
  fn pub ip -> Option[IpAddress] {
    IpAddress.parse(@address)
  }
}

impl Equal[ref SocketAddress] for SocketAddress {
  # Returns `true` if `self` and `other` are the same.
  fn pub ==(other: ref SocketAddress) -> Bool {
    @address == other.address and @port == other.port
  }
}

impl Format for SocketAddress {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write('${@address}:${@port}')
  }
}

# A low-level, non-blocking IPv4 or IPv6 socket.
class pub Socket {
  let @raw: RawSocket

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let @deadline: Int

  # Creates a new IPv4 socket.
  #
  # # Examples
  #
  #     import std.net.socket (Type, Socket)
  #
  #     Socket.ipv4(Type.DGRAM).get
  fn pub static ipv4(type: Type) -> Result[Socket, Error] {
    let sock = RawSocket {
      @inner = 0 as Int32,
      @registered = 0 as UInt8,
      @unix = 0 as UInt8,
    }

    match inko_socket_new(IPV4, type.into_int, mut sock) as Int {
      case 0 -> Result.Ok(Socket { @raw = sock, @deadline = NO_DEADLINE })
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Creates a new IPv6 socket.
  #
  # # Examples
  #
  #     import std.net.socket (Type, Socket)
  #
  #     Socket.ipv6(Type.DGRAM).get
  fn pub static ipv6(type: Type) -> Result[Socket, Error] {
    let sock = RawSocket {
      @inner = 0 as Int32,
      @registered = 0 as UInt8,
      @unix = 0 as UInt8,
    }

    match inko_socket_new(IPV6, type.into_int, mut sock) as Int {
      case 0 -> Result.Ok(Socket { @raw = sock, @deadline = NO_DEADLINE })
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the point in time after which socket operations must time out, known as
  # a "deadline".
  #
  # # Examples
  #
  # Using a `Duration` results in this method calculating the absolute time
  # after which operations time out:
  #
  #     import std.net.socket (Socket, Type)
  #     import std.time (Duration)
  #
  #     let socket = Socket.ipv4(Type.DGRAM)
  #
  #     socket.timeout_after = Duration.from_secs(5)
  #
  # We can also use an `Instant`:
  #
  #     import std.net.socket (Socket, Type)
  #     import std.time (Duration, Instant)
  #
  #     let socket = Socket.ipv4(Type.DGRAM)
  #
  #     socket.timeout_after = Instant.new + Duration.from_secs(5)
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  # Clears the deadline to apply to socket operations.
  fn pub mut reset_deadline {
    @deadline = NO_DEADLINE
  }

  # Binds this socket to the specified address.
  #
  # # Examples
  #
  # Binding a socket:
  #
  #     import std.net.socket (Socket, Type)
  #     import std.net.ip (IpAddress)
  #
  #     let socket = Socket.ipv4(Type.DGRAM).get
  #
  #     socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  fn pub mut bind[T: ToString](ip: ref T, port: Int) -> Result[Nil, Error] {
    match inko_socket_bind(@raw, ip.to_string, port) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a socket:
  #
  #     import std.net.socket (Socket, Type)
  #     import std.net.ip (IpAddress)
  #
  #     let listener = Socket.ipv4(Type.STREAM).get
  #     let client = Socket.ipv4(Type.STREAM).get
  #
  #     socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #     socket.listen.get
  #     client.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  fn pub mut connect[T: ToString](ip: ref T, port: Int) -> Result[Nil, Error] {
    match
      inko_socket_connect(
        _INKO.state,
        _INKO.process,
        @raw,
        ip.to_string,
        port,
        @deadline,
      )
    {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  #     import std.net.socket (Socket, Type)
  #     import std.net.ip (IpAddress)
  #
  #     let socket = Socket.ipv4(Type.STREAM).get
  #
  #     socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #     socket.listen.get
  fn pub mut listen -> Result[Nil, Error] {
    match inko_socket_listen(@raw, MAXIMUM_LISTEN_BACKLOG) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  #     import std.net.socket (Socket, Type)
  #     import std.net.ip (IpAddress)
  #
  #     let listener = Socket.ipv4(Type.STREAM).get
  #     let stream = Socket.ipv4(Type.STREAM).get
  #
  #     listener.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #     listener.listen.get
  #
  #     stream.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #     stream.write_string('ping').get
  #
  #     let client = listener.accept.get
  #     let buffer = ByteArray.new
  #
  #     client.read(into: buffer, size: 4).get
  #
  #     buffer.to_string # => 'ping'
  fn pub accept -> Result[Socket, Error] {
    let sock = RawSocket {
      @inner = 0 as Int32,
      @registered = 0 as UInt8,
      @unix = 0 as UInt8,
    }

    match
      inko_socket_accept(_INKO.state, _INKO.process, @raw, @deadline, mut sock)
        as Int
    {
      case 0 -> Result.Ok(Socket { @raw = sock, @deadline = NO_DEADLINE })
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std.net.socket (Socket, Type)
  #     import std.net.ip (IpAddress)
  #
  #     let socket = Socket.ipv4(Type.DGRAM).get
  #
  #     socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #     socket
  #       .send_string_to(
  #         string: 'hello',
  #         ip: IpAddress.v4(0, 0, 0, 0),
  #         port: 9999
  #       )
  #       .get
  fn pub mut send_string_to[T: ToString](
    string: String,
    ip: ref T,
    port: Int,
  ) -> Result[Int, Error] {
    match
      inko_socket_send_string_to(
        _INKO.state,
        _INKO.process,
        @raw,
        string,
        ip.to_string,
        port,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std.net.socket (Socket, Type)
  #     import std.net.ip (IpAddress)
  #
  #     let socket = Socket.ipv4(Type.DGRAM).get
  #     let bytes = 'hello'.to_byte_array
  #
  #     socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #     socket
  #       .send_bytes_to(
  #         bytes: bytes,
  #         ip: IpAddress.v4(0, 0, 0, 0),
  #         port: 9999
  #       )
  #       .get
  fn pub mut send_bytes_to[T: ToString](
    bytes: ref ByteArray,
    ip: ref T,
    port: Int,
  ) -> Result[Int, Error] {
    match
      inko_socket_send_bytes_to(
        _INKO.state,
        _INKO.process,
        @raw,
        bytes,
        ip.to_string,
        port,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  #     import std.net.socket (Socket, Type)
  #     import std.net.ip (IpAddress)
  #
  #     let socket = Socket.ipv4(Type.DGRAM).get
  #     let bytes = ByteArray.new
  #
  #     socket
  #       .send_string_to(
  #         'hello',
  #         ip: IpAddress.v4(0, 0, 0, 0),
  #         port: 9999
  #       )
  #       .get
  #
  #     let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  #     bytes.to_string       # => 'hello'
  #     received_from.address # => '0.0.0.0'
  #     received_from.port    # => 9999
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[SocketAddress, Error] {
    let raw = RawAddress { @address = '', @port = 0 }

    match
      inko_socket_receive_from(
        _INKO.state,
        _INKO.process,
        @raw,
        bytes,
        size,
        @deadline,
        mut raw,
      )
        as Int
    {
      case 0 -> Result.Ok(SocketAddress.new(raw.address, raw.port))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[SocketAddress, Error] {
    let raw = RawAddress { @address = '', @port = 0 }

    match inko_socket_local_address(_INKO.state, @raw, mut raw) as Int {
      case 0 -> Result.Ok(SocketAddress.new(raw.address, raw.port))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[SocketAddress, Error] {
    let raw = RawAddress { @address = '', @port = 0 }

    match inko_socket_peer_address(_INKO.state, @raw, mut raw) as Int {
      case 0 -> Result.Ok(SocketAddress.new(raw.address, raw.port))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `IP_TTL` option.
  fn pub mut ttl=(value: Int) -> Result[Nil, Error] {
    match inko_socket_set_ttl(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `IPV6_V6ONLY` option.
  fn pub mut only_ipv6=(value: Bool) -> Result[Nil, Error] {
    match inko_socket_set_only_v6(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `TCP_NODELAY` option.
  fn pub mut no_delay=(value: Bool) -> Result[Nil, Error] {
    match inko_socket_set_nodelay(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_BROADCAST` option.
  fn pub mut broadcast=(value: Bool) -> Result[Nil, Error] {
    match inko_socket_set_broadcast(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_LINGER` option.
  fn pub mut linger=(value: ref Duration) -> Result[Nil, Error] {
    match inko_socket_set_linger(@raw, value.to_nanos) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    match inko_socket_set_recv_size(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    match inko_socket_set_send_size(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_KEEPALIVE` option.
  fn pub mut keepalive=(value: Bool) -> Result[Nil, Error] {
    match inko_socket_set_keepalive(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_REUSEADDR` option.
  fn pub mut reuse_address=(value: Bool) -> Result[Nil, Error] {
    match inko_socket_set_reuse_address(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the supplied
  # argument will be ignored.
  fn pub mut reuse_port=(value: Bool) -> Result[Nil, Error] {
    match inko_socket_set_reuse_port(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    match inko_socket_shutdown_read(@raw) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    match inko_socket_shutdown_write(@raw) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    match inko_socket_shutdown_read_write(@raw) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[Socket, Error] {
    let sock = RawSocket {
      @inner = 0 as Int32,
      @registered = 0 as UInt8,
      @unix = 0 as UInt8,
    }

    match inko_socket_try_clone(@raw, mut sock) as Int {
      case 0 -> Result.Ok(Socket { @raw = sock, @deadline = NO_DEADLINE })
      case e -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Drop for Socket {
  fn mut drop {
    inko_socket_drop(@raw)
  }
}

impl Read for Socket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    match
      inko_socket_read(_INKO.state, _INKO.process, @raw, into, size, @deadline)
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Write for Socket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Int, Error] {
    match
      inko_socket_write_bytes(
        _INKO.state,
        _INKO.process,
        @raw,
        bytes,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  fn pub mut write_string(string: String) -> Result[Int, Error] {
    match
      inko_socket_write_string(
        _INKO.state,
        _INKO.process,
        @raw,
        string,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A UDP socket.
#
# A `UdpSocket` can be used to easily create a bound UDP socket from an IP
# address and a port.
class pub UdpSocket {
  # The raw `Socket` wrapped by this `UdpSocket`.
  let pub @socket: Socket

  # Creates a new `UdpSocket`, bound to the given address.
  #
  # # Examples
  #
  # Creating a new bound UDP socket:
  #
  #     import std.net.socket (UdpSocket)
  #     import std.net.ip (IpAddress)
  #
  #     let ip = IpAddress.parse('0.0.0.0').get
  #
  #     UdpSocket.new(ip, port: 0).get
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[UdpSocket, Error] {
    let socket = if ip.v6? {
      try Socket.ipv6(Type.DGRAM)
    } else {
      try Socket.ipv4(Type.DGRAM)
    }

    try socket.bind(ip, port)
    Result.Ok(UdpSocket { @socket = socket })
  }

  # Connects `self` to the remote address.
  #
  # Connecting a `UdpSocket` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UdpSocket.receive_from` and `UdpSocket.send_to`.
  #
  # # Examples
  #
  # Connecting a UDP socket:
  #
  #     import std.net.socket (UdpSocket)
  #     import std.net.ip (IpAddress)
  #
  #     let socket1 =
  #       UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 40_000).get
  #     let socket2 =
  #       UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  #
  #     socket1.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  fn pub mut connect[T: ToString](ip: ref T, port: Int) -> Result[Nil, Error] {
    @socket.connect(ip, port)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `Socket.send_string_to` for more information.
  #
  # # Examples
  #
  #     import std.net.socket (UdpSocket)
  #     import std.net.ip (IpAddress)
  #
  #     let socket =
  #       UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #
  #     socket
  #       .send_string_to(
  #         string: 'hello',
  #         ip: IpAddress.v4(0, 0, 0, 0),
  #         port: 9999
  #       )
  #       .get
  fn pub mut send_string_to[T: ToString](
    string: String,
    ip: ref T,
    port: Int,
  ) -> Result[Int, Error] {
    @socket.send_string_to(string, ip, port)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `Socket.send_bytes_to` for more information.
  #
  # # Examples
  #
  #     import std.net.socket (UdpSocket)
  #     import std.net.ip (IpAddress)
  #
  #     let socket =
  #       UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #     let bytes = 'hello'.to_byte_array
  #
  #     socket
  #       .send_bytes_to(
  #         bytes: bytes,
  #         ip: IpAddress.v4(0, 0, 0, 0),
  #         port: 9999
  #       )
  #       .get
  fn pub mut send_bytes_to[T: ToString](
    bytes: ref ByteArray,
    ip: ref T,
    port: Int,
  ) -> Result[Int, Error] {
    @socket.send_bytes_to(bytes, ip, port)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # See the documentation of `Socket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[SocketAddress, Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UdpSocket, Error] {
    @socket.try_clone.map(fn (sock) { UdpSocket { @socket = sock } })
  }
}

impl Read for UdpSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UdpSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Int, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Int, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A TCP socket connected to another TCP socket.
class pub TcpClient {
  # The raw `Socket` wrapped by this `TcpClient`.
  let pub @socket: Socket

  # Creates a new `TcpClient` that is connected to the TCP socket at the given
  # IP address and port.
  #
  # This method doesn't enforce a deadline on establishing the connection. If
  # you need to limit the amount of time spent waiting to establish the
  # connection, use `TcpClient.with_timeout` instead.
  #
  # # Examples
  #
  # Connecting a `TcpClient`:
  #
  #     import std.net.socket (TcpClient)
  #     import std.net.ip (IpAddress)
  #
  #     let ip = IpAddress.parse('127.0.0.1').get
  #
  #     TcpClient.new(ip, port: 40_000).get
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[TcpClient, Error] {
    let socket = if ip.v6? {
      try Socket.ipv6(Type.STREAM)
    } else {
      try Socket.ipv4(Type.STREAM)
    }

    try socket.connect(ip, port)
    Result.Ok(TcpClient { @socket = socket })
  }

  # Creates a new `TcpClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` times out. The deadline is cleared once connected.
  #
  # See `TcpClient.new` for more information.
  #
  # # Examples
  #
  #     import std.net.socket (TcpClient)
  #     import std.net.ip (IpAddress)
  #     import std.time (Duration)
  #
  #     TcpClient
  #       .with_timeout(
  #         ip: IpAddress.v4(0, 0, 0, 0),
  #         port: 40_000,
  #         timeout_after: Duration.from_secs(5)
  #       )
  #       .get
  fn pub static with_timeout[T: ToInstant](
    ip: ref IpAddress,
    port: Int,
    timeout_after: T,
  ) -> Result[TcpClient, Error] {
    let socket = if ip.v6? {
      try Socket.ipv6(Type.STREAM)
    } else {
      try Socket.ipv4(Type.STREAM)
    }

    let _ = socket.timeout_after = timeout_after

    try socket.connect(ip, port)
    Result.Ok(TcpClient { @socket = socket })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `Socket.peer_address` for more information.
  fn pub peer_address -> Result[SocketAddress, Error] {
    @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpClient, Error] {
    @socket.try_clone.map(fn (sock) { TcpClient { @socket = sock } })
  }
}

impl Read for TcpClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for TcpClient {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Int, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Int, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A TCP socket server that can accept incoming connections.
class pub TcpServer {
  # The raw `Socket` wrapped by this `TcpServer`.
  let pub @socket: Socket

  # Creates a new `TcpServer` bound to and listening on the given IP address
  # and port.
  #
  # A `TcpServer` uses `SO_REUSEADDR` and `SO_REUSEPORT` to allow for fast
  # rebinding of sockets. `SO_REUSEPORT` is only used on platforms that support
  # it.
  #
  # The `only_ipv6` argument is ignored when binding to an IPv4 address.
  #
  # # Examples
  #
  # Creating a `TcpServer`:
  #
  #     import std.net.socket (TcpServer)
  #     import std.net.ip (IpAddress)
  #
  #     let ip = IpAddress.parse('0.0.0.0').get
  #
  #     TcpServer.new(ip, port: 40_000).get
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[TcpServer, Error] {
    let socket = if ip.v6? {
      try Socket.ipv6(Type.STREAM)
    } else {
      try Socket.ipv4(Type.STREAM)
    }

    try socket.reuse_address = true
    try socket.reuse_port = true
    try socket.bind(ip, port)
    try socket.listen
    Result.Ok(TcpServer { @socket = socket })
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  #     import std.net.socket (TcpServer, TcpClient)
  #     import std.net.ip (IpAddress)
  #
  #     let listener =
  #       TcpServer.new(ip: IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  #     let client =
  #       TcpClient.new(ip: IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  #
  #     client.write_string('ping')
  #
  #     let connection = listener.accept.get
  #     let buffer = ByteArray.new
  #
  #     connection.read(into: buffer, size: 4).get
  #
  #     buffer.to_string # => 'ping'
  fn pub accept -> Result[TcpClient, Error] {
    @socket.accept.map(fn (sock) { TcpClient { @socket = sock } })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpServer, Error] {
    @socket.try_clone.map(fn (sock) { TcpServer { @socket = sock } })
  }
}

# A Unix domain socket address.
class pub UnixAddress {
  # The path or name of the address.
  #
  # This is a `String` since using a `Path` does not make sense for abstract
  # and unnamed addresses.
  let pub @address: String

  # Creates a new `UnixAddress` from the given path or name.
  #
  # # Examples
  #
  # Creating a `UnixAddress` that uses a path:
  #
  #     import std.net.socket (UnixAddress)
  #
  #     UnixAddress.new('/tmp/test.sock')
  #
  # Creating a `UnixAddress` that uses an unnamed address:
  #
  #     import std.net.socket (UnixAddress)
  #
  #     UnixAddress.new('')
  #
  # Creating a `UnixAddress` that uses an abstract address:
  #
  #     import std.net.socket (UnixAddress)
  #
  #     UnixAddress.new("\0example")
  fn pub static new[T: ToString](address: ref T) -> UnixAddress {
    UnixAddress { @address = address.to_string }
  }

  # Returns the path of this address.
  #
  # If the address is unnamed or an abstract address, None is returned.
  fn pub to_path -> Option[Path] {
    if unnamed? or abstract? {
      Option.None
    } else {
      Option.Some(@address.to_path)
    }
  }

  # Returns `true` if `self` is an abstract address.
  #
  # # Examples
  #
  # Checking if an address is abstract:
  #
  #     import std.net.socket (UnixAddress)
  #
  #     UnixAddress.new('/tmp/test.sock').abstract?    # => false
  #     UnixAddress.new("\0example-address").abstract? # => true
  fn pub abstract? -> Bool {
    @address.starts_with?('\0')
  }

  # Returns `true` if `self` is an unnamed address.
  #
  # # Examples
  #
  # Checking if an address is unnamed:
  #
  #     import std.net.socket (UnixAddress)
  #
  #     UnixAddress.new('/tmp/test.sock').unnamed? # => false
  #     UnixAddress.new('').unnamed?               # => true
  fn pub unnamed? -> Bool {
    @address.empty?
  }
}

impl Format for UnixAddress {
  fn pub fmt(formatter: mut Formatter) {
    let write = if abstract? {
      '@${@address.slice(start: 1, size: @address.size - 1)}'
    } else if unnamed? {
      'unnamed'
    } else {
      @address
    }

    formatter.write(write)
  }
}

impl Equal[ref UnixAddress] for UnixAddress {
  # Returns `true` if `self` and `other` are the same socket addresses.
  #
  # # Examples
  #
  # Comparing two `UnixAddress` objects:
  #
  #     import std.net.socket (UnixAddress)
  #
  #     UnixAddress.new('a.sock') == UnixAddress.new('a.sock') # => true
  #     UnixAddress.new('a.sock') == UnixAddress.new('b.sock') # => false
  fn pub ==(other: ref UnixAddress) -> Bool {
    @address == other.address
  }
}

impl ToString for UnixAddress {
  # Returns the address name or path as a `String`.
  #
  # # Examples
  #
  # Converting a `UnixAddress` to a `String`:
  #
  #     import std.net.socket (UnixAddress)
  #
  #     UnixAddress.new('/tmp/test.sock').to_string # => '/tmp/test.sock'
  #     UnixAddress.new("\0example").to_string      # => "\0example"
  fn pub to_string -> String {
    @address
  }
}

# A low-level, non-blocking Unix domain socket.
class pub UnixSocket {
  let @raw: RawSocket

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let @deadline: Int

  # Creates a new Unix domain socket.
  #
  # # Examples
  #
  # Creating a new socket:
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     UnixSocket.new(Type.DGRAM).get
  fn pub static new(type: Type) -> Result[UnixSocket, Error] {
    let sock = RawSocket {
      @inner = 0 as Int32,
      @registered = 0 as UInt8,
      @unix = 1 as UInt8,
    }

    match inko_socket_new(UNIX, type.into_int, mut sock) as Int {
      case 0 -> Result.Ok(UnixSocket { @raw = sock, @deadline = NO_DEADLINE })
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the point in time after which socket operations must time out, known as
  # a "deadline".
  #
  # # Examples
  #
  # Using a `Duration` results in this method calculating the absolute time
  # after which operations time out:
  #
  #     import std.net.socket (UnixSocket, Type)
  #     import std.time (Duration)
  #
  #     let socket = UnixSocket.new(Type.DGRAM)
  #
  #     socket.timeout_after = Duration.from_secs(5)
  #
  # We can also use an `Instant`:
  #
  #     import std.net.socket (UnixSocket, Type)
  #     import std.time (Duration, Instant)
  #
  #     let socket = UnixSocket.new(Type.DGRAM)
  #
  #     socket.timeout_after = Instant.new + Duration.from_secs(5)
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  # Clears the deadline to apply to socket operations.
  fn pub mut reset_deadline {
    @deadline = NO_DEADLINE
  }

  # Binds this socket to the specified path or abstract address.
  #
  # # Examples
  #
  # Binding a Unix socket to a path:
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     let socket = UnixSocket.new(Type.DGRAM).get
  #
  #     socket.bind('/tmp/test.sock').get
  fn pub mut bind[T: ToString](path: ref T) -> Result[Nil, Error] {
    match inko_socket_bind(@raw, path.to_string, 0) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a Unix socket:
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     let listener = UnixSocket.new(Type.STREAM).get
  #     let stream = UnixSocket.new(Type.STREAM).get
  #
  #     listener.bind('/tmp/test.sock').get
  #     listener.listen.get
  #
  #     stream.connect('/tmp/test.sock').get
  fn pub mut connect[T: ToString](path: ref T) -> Result[Nil, Error] {
    match
      inko_socket_connect(
        _INKO.state,
        _INKO.process,
        @raw,
        path.to_string,
        0,
        @deadline,
      )
    {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     let socket = UnixSocket.new(Type.STREAM).get
  #
  #     socket.bind('/tmp/test.sock').get
  #     socket.listen.get
  fn pub mut listen -> Result[Nil, Error] {
    match inko_socket_listen(@raw, MAXIMUM_LISTEN_BACKLOG) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     let listener = UnixSocket.new(Type.STREAM).get
  #     let stream = UnixSocket.new(Type.STREAM).get
  #
  #     listener.bind('/tmp/test.sock').get
  #     listener.listen.get
  #
  #     stream.connect('/tmp/test.sock').get
  #     stream.write_string('ping').get
  #
  #     let client = listener.accept.get
  #     let buffer = ByteArray.new
  #
  #     client.read(into: buffer, size: 4).get
  #
  #     buffer.to_string # => 'ping'
  fn pub accept -> Result[UnixSocket, Error] {
    let sock = RawSocket {
      @inner = 0 as Int32,
      @registered = 0 as UInt8,
      @unix = 1 as UInt8,
    }

    match
      inko_socket_accept(_INKO.state, _INKO.process, @raw, @deadline, mut sock)
        as Int
    {
      case 0 -> Result.Ok(UnixSocket { @raw = sock, @deadline = NO_DEADLINE })
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     let socket = UnixSocket.new(Type.DGRAM).get
  #
  #     socket.bind('/tmp/test.sock').get
  #     socket.send_string_to(string: 'hello', address: '/tmp/test.sock').get
  fn pub mut send_string_to[T: ToString](
    string: String,
    address: ref T,
  ) -> Result[Int, Error] {
    let addr = address.to_string

    match
      inko_socket_send_string_to(
        _INKO.state,
        _INKO.process,
        @raw,
        string,
        addr,
        0,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     let socket = UnixSocket.new(Type.DGRAM).get
  #     let bytes = 'hello'.to_byte_array
  #
  #     socket.bind('/tmp/test.sock').get
  #     socket.send_bytes_to(bytes: bytes, address: '/tmp/test.sock').get
  fn pub mut send_bytes_to[T: ToString](
    bytes: ref ByteArray,
    address: ref T,
  ) -> Result[Int, Error] {
    let addr = address.to_string

    match
      inko_socket_send_bytes_to(
        _INKO.state,
        _INKO.process,
        @raw,
        bytes,
        addr,
        0,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  #     import std.net.socket (Type, UnixSocket)
  #
  #     let socket = UnixSocket.new(Type.DGRAM).get
  #     let bytes = ByteArray.new
  #
  #     socket.send_string_to('hello', address: '/tmp/test.sock').get
  #
  #     let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  #     bytes.to_string         # => 'hello'
  #     received_from.to_string # => '/tmp/test.sock'
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[UnixAddress, Error] {
    let raw = RawAddress { @address = '', @port = 0 }

    match
      inko_socket_receive_from(
        _INKO.state,
        _INKO.process,
        @raw,
        bytes,
        size,
        @deadline,
        mut raw,
      )
        as Int
    {
      case 0 -> Result.Ok(UnixAddress.new(raw.address))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[UnixAddress, Error] {
    let raw = RawAddress { @address = '', @port = 0 }

    match inko_socket_local_address(_INKO.state, @raw, mut raw) as Int {
      case 0 -> Result.Ok(UnixAddress.new(raw.address))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[UnixAddress, Error] {
    let raw = RawAddress { @address = '', @port = 0 }

    match inko_socket_peer_address(_INKO.state, @raw, mut raw) as Int {
      case 0 -> Result.Ok(UnixAddress.new(raw.address))
      case e -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    match inko_socket_set_recv_size(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    match inko_socket_set_send_size(@raw, value) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    match inko_socket_shutdown_read(@raw) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    match inko_socket_shutdown_write(@raw) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    match inko_socket_shutdown_read_write(@raw) {
      case { @tag = 1, @value = _ } -> Result.Ok(nil)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixSocket, Error] {
    let sock = RawSocket {
      @inner = 0 as Int32,
      @registered = 0 as UInt8,
      @unix = 1 as UInt8,
    }

    match inko_socket_try_clone(@raw, mut sock) as Int {
      case 0 -> Result.Ok(UnixSocket { @raw = sock, @deadline = NO_DEADLINE })
      case e -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Drop for UnixSocket {
  fn mut drop {
    inko_socket_drop(@raw)
  }
}

impl Read for UnixSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    match
      inko_socket_read(_INKO.state, _INKO.process, @raw, into, size, @deadline)
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }
}

impl Write for UnixSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Int, Error] {
    match
      inko_socket_write_bytes(
        _INKO.state,
        _INKO.process,
        @raw,
        bytes,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  fn pub mut write_string(string: String) -> Result[Int, Error] {
    match
      inko_socket_write_string(
        _INKO.state,
        _INKO.process,
        @raw,
        string,
        @deadline,
      )
    {
      case { @tag = 0, @value = v } -> Result.Ok(v)
      case { @tag = _, @value = e } -> Result.Error(Error.from_os_error(e))
    }
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A Unix datagram socket.
class pub UnixDatagram {
  # The raw `UnixSocket` wrapped by this `UnixDatagram`.
  let pub @socket: UnixSocket

  # Creates a new Unix datagram socket bound to the given address.
  #
  # # Examples
  #
  # Creating a new Unix datagram socket:
  #
  #     import std.net.socket (UnixDatagram)
  #
  #     UnixDatagram.new('/tmp/test.sock').get
  fn pub static new[T: ToString](
    address: ref T,
  ) -> Result[UnixDatagram, Error] {
    let socket = try UnixSocket.new(Type.DGRAM)

    try socket.bind(address)
    Result.Ok(UnixDatagram { @socket = socket })
  }

  # Connects `self` to the remote addres.s
  #
  # Connecting a `UnixDatagram` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UnixDatagram.receive_from` and `UnixDatagram.send_to`.
  #
  # # Examples
  #
  # Connecting a Unix datagram socket:
  #
  #     import std.net.socket (UnixDatagram)
  #
  #     let socket1 = UnixDatagram.new('/tmp/test1.sock').get
  #     let socket2 = UnixDatagram.new('/tmp/test2.sock').get
  #
  #     socket1.connect('/tmp/test2.sock').get
  fn pub mut connect[T: ToString](address: ref T) -> Result[Nil, Error] {
    @socket.connect(address)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `UnixSocket.send_string_to` for more information.
  #
  # # Examples
  #
  #     import std.net.socket (UnixDatagram)
  #
  #     let socket = UnixDatagram.new('/tmp/test.sock').get
  #
  #     socket.send_string_to(string: 'hello', address: '/tmp/test.sock').get
  fn pub mut send_string_to[T: ToString](
    string: String,
    address: ref T,
  ) -> Result[Int, Error] {
    @socket.send_string_to(string, address)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `UnixSocket.send_bytes_to` for more information.
  #
  # # Examples
  #
  #     import std.net.socket (UnixDatagram)
  #
  #     let socket = UnixDatagram.new('/tmp/test.sock').get
  #     let bytes = 'hello'.to_byte_array
  #
  #     socket.send_bytes_to(bytes: bytes, address: '/tmp/test.sock').get
  fn pub mut send_bytes_to[T: ToString](
    bytes: ref ByteArray,
    address: ref T,
  ) -> Result[Int, Error] {
    @socket.send_bytes_to(bytes, address)
  }

  # Receives a single datagram message on the socket, returning the address the
  # message was sent from.
  #
  # See the documentation of `UnixSocket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[UnixAddress, Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixDatagram, Error] {
    @socket.try_clone.map(fn (sock) { UnixDatagram { @socket = sock } })
  }
}

impl Read for UnixDatagram {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UnixDatagram {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Int, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Int, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A Unix stream socket connected to another Unix socket.
class pub UnixClient {
  # The raw `UnixSocket` wrapped by this `UnixClient`.
  let pub @socket: UnixSocket

  # Creates a new `UnixClient` that is connected to the given address.
  #
  # This method doesn't enforce a deadline on establishing the connection. If
  # you need to limit the amount of time spent waiting to establish the
  # connection, use `UnixClient.with_timeout` instead.
  #
  # # Examples
  #
  # Connecting a `UnixClient`:
  #
  #     import std.net.socket (UnixServer, UnixClient)
  #
  #     let listener = UnixServer.new('/tmp/test.sock').get
  #
  #     UnixClient.new('/tmp/test.sock').get
  fn pub static new[T: ToString](address: ref T) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.new(Type.STREAM)

    try socket.connect(address)
    Result.Ok(UnixClient { @socket = socket })
  }

  # Creates a new `UnixClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` times out. The deadline is cleared once connected.
  #
  # See `UnixClient.new` for more information.
  #
  # # Examples
  #
  #     import std.net.socket (UnixClient)
  #     import std.time (Duration)
  #
  #     UnixClient
  #       .with_timeout(
  #         address: '/tmp/test.sock'
  #         timeout_after: Duration.from_secs(5)
  #       )
  #       .get
  fn pub static with_timeout[A: ToString, I: ToInstant](
    address: ref A,
    timeout_after: I,
  ) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.new(Type.STREAM)

    let _ = socket.timeout_after = timeout_after

    try socket.connect(address)
    Result.Ok(UnixClient { @socket = socket })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `UnixSocket.peer_address` for more information.
  fn pub peer_address -> Result[UnixAddress, Error] {
    @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixClient, Error] {
    @socket.try_clone.map(fn (sock) { UnixClient { @socket = sock } })
  }
}

impl Read for UnixClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UnixClient {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Int, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Int, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

# A Unix socket server that can accept incoming connections.
class pub UnixServer {
  # The raw `UnixSocket` wrapped by this `UnixServer`.
  let pub @socket: UnixSocket

  # Creates a new `UnixServer` bound to and listening on the given address.
  #
  # The `backlog` argument can be used to set the listen backlog.
  #
  # # Examples
  #
  # Creating a `UnixServer`:
  #
  #     import std.net.socket (UnixServer)
  #
  #     UnixServer.new('/tmp/test.sock').get
  fn pub static new[T: ToString](address: ref T) -> Result[UnixServer, Error] {
    let socket = try UnixSocket.new(Type.STREAM)

    try socket.bind(address)
    try socket.listen
    Result.Ok(UnixServer { @socket = socket })
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  #     import std.net.socket (UnixServer, UnixClient)
  #
  #     let listener = UnixServer.new('/tmp/test.sock').get
  #     let client = UnixClient.new('/tmp/test.sock').get
  #
  #     client.write_string('ping')
  #
  #     let connection = listener.accept.get
  #     let buffer = ByteArray.new
  #
  #     connection.read(into: buffer, size: 4).get
  #
  #     buffer.to_string # => 'ping'
  fn pub accept -> Result[UnixClient, Error] {
    @socket.accept.map(fn (sock) { UnixClient { @socket = sock } })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixServer, Error] {
    @socket.try_clone.map(fn (sock) { UnixServer { @socket = sock } })
  }
}
