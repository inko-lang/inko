# IP and Unix domain sockets.
#
# This module provides types for various socket types, such as TCP, UDP and Unix
# sockets.
#
# The types `Socket` and `UnixSocket` are low-level sockets that implement most
# of the socket logic. Types such as `TcpServer` and `TcpClient` wrap these
# sockets to make it easier to create commonly used sockets, such as a TCP
# client.
#
# # Deadlines and timeouts
#
# Socket timeouts are supported through a mechanism known as a "deadline". A
# deadline specifies the time after which socket operations must time out when
# waiting for them to complete. Deadlines represent a fixed point in time, and
# can be created from both `Duration` and `Instant` values.
#
# The use of deadlines instead of timeouts makes it easier to apply time limits
# to multiple operations. Consider the following chain of events:
#
# 1. `read()`
# 1. `write()`
# 1. `read()`
#
# Traditionally one might set a timeout such as 10 seconds. This poses a
# problem: the timeout is applied to every operation, meaning each operation is
# allowed to run up to 10 seconds, resulting in a total maximum runtime of 30
# seconds.
#
# Using deadlines one sets a deadline in the future, and no matter the amount of
# operations performed, the operations time out once we cross the deadline. In
# our above example that means we can easily limit the total runtime to 10
# seconds using a deadline that's 10 seconds in the future.
#
# Deadlines are set using `Socket.timeout_after` and
# `UnixSocket.timeout_after=`. Here's an example using deadlines to limit the
# time spent waiting for a client to connect:
#
# ```inko
# import std.net.ip (IpAddress)
# import std.net.socket (TcpServer)
# import std.time (Duration)
#
# let server = TcpServer.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9000).get
#
# server.socket.timeout_after = Duration.from_secs(3)
#
# # This times out after roughly three seconds.
# server.accept.get
# ```
#
# It's important to keep in mind that deadlines only apply when an operation
# must wait, i.e. a read is performed but no data is available. If the operation
# completes immediately (i.e. a read is performed and enough data _is_
# available), the deadline is ignored. This means that if you perform an
# operation in a loop and set a deadline, and data is always available such that
# the operation never blocks, the loop may run indefinitely; depending on what
# the loop does of course.
#
# For more information about timeouts versus deadlines, consider reading [this
# article](https://vorpus.org/blog/timeouts-and-cancellation-for-humans/).
import std.bytes (Bytes)
import std.clone (Clone)
import std.cmp (Equal)
import std.drop (Drop)
import std.fmt (Format, Formatter)
import std.fs.file (ReadOnlyFile)
import std.fs.path (Path)
import std.hash (Hash, Hasher)
import std.io (Error, Read, Write, WriteInternal)
import std.libc
import std.net.happy
import std.net.ip (IpAddress)
import std.pipe (Pipe, PipeWriter)
import std.string (ToString)
import std.sync (AtomicBool)
import std.sys.net
import std.sys.poll
import std.sys.unix.net (self as sys) if unix
import std.time (Duration, Instant, ToInstant)

# The maximum value valid for a listen() call.
#
# Linux and FreeBSD do not allow for values greater than this as they internally
# use an u16, so we'll limit the backlog to this value. We don't use SOMAXCONN
# because it might be hardcoded. This means that setting `net.core.somaxconn` on
# Linux (for example) would have no effect.
let MAXIMUM_LISTEN_BACKLOG = 65_535

fn pub try_ips[R, E](
  ips: ref Array[IpAddress],
  fun: fn (IpAddress) -> Result[R, E],
) -> Result[R, E] {
  let iter = ips.iter
  let mut last = Option.None

  loop {
    match iter.next {
      case Some(ip) -> {
        match fun.call(ip) {
          case Ok(v) -> return Result.Ok(v)
          case Error(e) -> last = Option.Some(e)
        }
      }
      case _ -> break
    }
  }

  Result.Error(last.or_panic_with('at least one IP address must be specified'))
}

trait RawSocketOperations {
  fn mut raw_socket -> Pointer[poll.Poll]

  fn raw_deadline -> Int
}

trait SendFile[E] {
  # Sends a read-only file to the other half of `self`, without the need for an
  # intermediate buffer.
  #
  # Upon success the number of copied bytes is returned.
  #
  # Upon returning from this method, the cursor/offset of the source file is the
  # same as it was before calling this method.
  #
  # The `buffer` argument may be used by the implementation to read chunks from
  # the input file before sending the chunks to the client. Currently this is
  # only used when the fallback implementation is used.
  #
  # # Platform differences
  #
  # The exact mechanism used for sending the file may vary per platform. For
  # example, on FreeBSD, Linux and macOS this method uses the `sendfile` system
  # call.
  #
  # # Fallbacks
  #
  # Not all platforms or socket types support zero-copy sending of files. In
  # such cases a userspace copy is performed. Such a fallback is applied to:
  #
  # - TLS sockets provided by `std.net.tls`
  # - `UdpSocket.send_file` and `UnixDatagram.send_file` on FreeBSD and macOS
  #
  # The userspace implementation copies data in chunks of 256 KiB and resets the
  # cursor of `file` to its original position after copying the data. While
  # resetting the cursor incurs a small cost, it ensures behavior is consistent
  # with the kernel implementations of this method.
  #
  # # Examples
  #
  # ```inko
  # import std.fs.file (ReadOnlyFile)
  # import std.net.ip (IpAddress)
  # import std.net.socket (UdpSocket)
  #
  # let file = ReadOnlyFile.new('README.md'.to_path).or_panic
  # let server = UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 9999).or_panic
  # let client = UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 0).or_panic
  # let buf = ByteArray.new
  #
  # client.connect(IpAddress.v4(0, 0, 0, 0), port: 9999).or_panic
  # client.send_file(buf, file).or_panic
  # server.read(buf, 1024).or_panic
  # buf.to_string # => '...'
  # ```
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, E]
}

trait Deadline {
  # Sets the point in time after which socket operations must time out, known as
  # a "deadline".
  #
  # # Examples
  #
  # Using a `Duration` results in this method calculating the absolute time
  # after which operations time out:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.time (Duration)
  #
  # let socket = Socket.datagram(ipv6: false)
  #
  # socket.timeout_after = Duration.from_secs(5)
  # ```
  #
  # We can also use an `Instant`:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.time (Duration, Instant)
  #
  # let socket = Socket.datagram(ipv6: false)
  #
  # socket.timeout_after = Instant.new + Duration.from_secs(5)
  # ```
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T)

  # Resets the deadline.
  #
  # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.time (Duration)
  #
  # let socket = Socket.datagram(ipv6: false)
  #
  # socket.timeout_after = Duration.from_secs(5)
  # socket.reset_deadline
  # ```
  fn pub mut reset_deadline
}

trait Shutdown {
  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error]

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error]

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error]
}

# An IPv4 or IPv6 socket address.
type pub copy SocketAddress {
  # The IPv4/IPv6 address of this socket address.
  let pub @ip: IpAddress

  # The port number of this socket address.
  let pub @port: Int
}

impl Clone for SocketAddress {
  fn pub clone -> Self {
    self
  }
}

impl Equal for SocketAddress {
  # Returns `true` if `self` and `other` are the same.
  fn pub inline ==(other: SocketAddress) -> Bool {
    @ip == other.ip and @port == other.port
  }
}

impl Hash for SocketAddress {
  fn pub hash[H: mut + Hasher](hasher: mut H) {
    @ip.hash(hasher)
    @port.hash(hasher)
  }
}

impl ToString for SocketAddress {
  fn pub to_string -> String {
    '${@ip}:${@port}'
  }
}

impl Format for SocketAddress {
  fn pub fmt(formatter: mut Formatter) {
    formatter
      .object('SocketAddress')
      .field('ip', @ip)
      .field('port', @port)
      .finish
  }
}

# A low-level, non-blocking IPv4 or IPv6 socket.
type pub Socket {
  let @socket: poll.Poll

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let mut @deadline: Int

  fn inline static from(socket: poll.Poll) -> Self {
    Self(socket: socket, deadline: poll.NO_DEADLINE)
  }

  fn static new(ipv6: Bool, kind: Int, protocol: Int) -> Result[Socket, Error] {
    let sock = net.raw_socket
    let domain = if ipv6 { libc.AF_INET6 } else { libc.AF_INET }

    try sys.init_socket(mut sock, domain, kind, protocol)
    Result.Ok(from(sock))
  }

  # Returns a new `Socket` configured as a stream socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.stream(ipv6: false)
  # ```
  fn pub static stream(ipv6: Bool) -> Result[Socket, Error] {
    Socket.new(ipv6, libc.SOCK_STREAM, protocol: 0)
  }

  # Returns a new `Socket` configured as a datagram socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.datagram(ipv6: false)
  # ```
  fn pub static datagram(ipv6: Bool) -> Result[Socket, Error] {
    Socket.new(ipv6, libc.SOCK_DGRAM, protocol: 0)
  }

  # Returns a new `Socket` configured as a raw socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # The `protocol` argument must specify a valid IANA IP protocol as defined in
  # RFC 1700.
  #
  # Note that on certain platforms (e.g. Linux, and probably most other Unix
  # systems) you'll need root privileges in order to create a raw socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.raw(ipv6: false, protocol: 1)
  # ```
  fn pub static raw(ipv6: Bool, protocol: Int) -> Result[Socket, Error] {
    Socket.new(ipv6, libc.SOCK_RAW, protocol)
  }

  # Binds this socket to the specified address.
  #
  # # Examples
  #
  # Binding a socket:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut bind(ip: IpAddress, port: Int) -> Result[Nil, Error] {
    sys.bind_ip(@socket.fd, ip, port)
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a socket:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let listener = Socket.stream(ipv6: false).get
  # let client = Socket.stream(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket.listen.get
  # client.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut connect(ip: IpAddress, port: Int) -> Result[Nil, Error] {
    sys.connect_ip(@socket, ip, port, @deadline)
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.stream(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket.listen.get
  # ```
  fn pub mut listen -> Result[Nil, Error] {
    sys.listen(@socket.fd, MAXIMUM_LISTEN_BACKLOG)
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let listener = Socket.stream(ipv6: false).get
  # let stream = Socket.stream(ipv6: false).get
  #
  # listener.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # listener.listen.get
  #
  # stream.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # stream.write('ping').get
  #
  # let client = listener.accept.get
  # let buffer = ByteArray.new
  #
  # client.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[Socket, Error] {
    let peer = net.raw_socket

    try sys.accept(@socket, mut peer, @deadline, poller: Option.None)
    Result.Ok(Socket.from(peer))
  }

  # Sends a `Bytes` value to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket.send_to('hello', ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut send_to[B: Bytes](
    bytes: ref B,
    ip: IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    sys.send_to_ip(@socket, bytes.pointer, bytes.size, ip, port, @deadline)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  # let bytes = ByteArray.new
  #
  # socket.send_to('hello', ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #
  # let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  # bytes.to_string         # => 'hello'
  # received_from.0         # => 5
  # received_from.1.address # => '0.0.0.0'
  # received_from.1.port    # => 9999
  # ```
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, SocketAddress), Error] {
    match sys.receive_from_ip(@socket, bytes, size, @deadline) {
      case Ok((read, ip, port)) -> Result.Ok((read, SocketAddress(ip, port)))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[SocketAddress, Error] {
    match sys.ip_local_address(@socket) {
      case Ok((ip, port)) -> Result.Ok(SocketAddress(ip, port))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[SocketAddress, Error] {
    match sys.ip_peer_address(@socket) {
      case Ok((ip, port)) -> Result.Ok(SocketAddress(ip, port))
      case Error(e) -> Result.Error(e)
    }
  }

  # Sets the value of the `IP_TTL` option.
  fn pub mut ttl=(value: Int) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_IP, libc.IP_TTL, value)
  }

  # Sets the value of the `IPV6_V6ONLY` option.
  fn pub mut only_ipv6=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_IPV6, libc.IPV6_V6ONLY, value.to_int)
  }

  # Sets the value of the `TCP_NODELAY` option.
  fn pub mut no_delay=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_TCP, libc.TCP_NODELAY, value.to_int)
  }

  # Returns `true` if the `TCP_NODELAY` option is set.
  fn pub no_delay? -> Bool {
    get_option(libc.IPPROTO_TCP, libc.TCP_NODELAY) != 0
  }

  # Sets the value of the `SO_BROADCAST` option.
  fn pub mut broadcast=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_BROADCAST, value.to_int)
  }

  # Sets the value of the `SO_LINGER` option.
  #
  # If a `Some` is given, the linger value is set to the duration in seconds. If
  # a `None` is given, the linger value is instead reset.
  #
  # On most platforms the linger duration has a precision of whole seconds. If a
  # `Duration` is supplied that is less than one second long or contains
  # fractional seconds, the value may be truncated or rounded to the nearest
  # second.
  fn pub mut linger=(value: Option[Duration]) -> Result[Nil, Error] {
    let linger = libc.Linger(l_onoff: 0 as Int32, l_linger: 0 as Int32)

    match value {
      case Some(d) -> {
        linger.l_onoff = 1 as Int32
        linger.l_linger = d.to_secs.to_int as Int32
      }
      case _ -> {}
    }

    let res = libc.setsockopt(
      @socket.fd,
      libc.SOL_SOCKET as Int32,
      libc.SO_LINGER as Int32,
      (mut linger) as Pointer[UInt8],
      8 as Int32,
    )
      as Int

    if res == 0 { Result.Ok(nil) } else { Result.Error(Error.last_os_error) }
  }

  # Returns the value of the `SO_LINGER` option.
  fn pub linger -> Option[Duration] {
    let linger = libc.Linger(l_onoff: 0 as Int32, l_linger: 0 as Int32)
    let size = 8 as Int32
    let res = libc.getsockopt(
      @socket.fd,
      libc.SOL_SOCKET as Int32,
      libc.SO_LINGER as Int32,
      (mut linger) as Pointer[UInt8],
      mut size,
    )
      as Int

    # Similar to get_option(), this method shouldn't ever reach this point, but
    # we panic just in case we do.
    if res != 0 { sys.getsockopt_error }

    if linger.l_onoff as Int != 0 {
      Option.Some(Duration.from_secs(linger.l_linger as Int))
    } else {
      Option.None
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_RCVBUF, value.to_int)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_SNDBUF, value.to_int)
  }

  # Sets the value of the `SO_KEEPALIVE` option.
  fn pub mut keepalive=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_KEEPALIVE, value.to_int)
  }

  # Sets the TCP keep-alive time to the given value.
  fn pub mut keepalive_time=(value: Duration) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_TCP, libc.TCP_KEEPIDLE, value.to_secs.to_int)
  }

  # Sets the TCP keep-alive interval to the given value.
  fn pub mut keepalive_interval=(value: Duration) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_TCP, libc.TCP_KEEPINTVL, value.to_secs.to_int)
  }

  # Sets the value of the `SO_REUSEADDR` option.
  fn pub mut reuse_address=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_REUSEADDR, value.to_int)
  }

  # Sets the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the supplied
  # argument will be ignored.
  fn pub mut reuse_port=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_REUSEPORT, value.to_int)
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[Socket, Error] {
    let sock = net.raw_socket

    try sys.try_clone(@socket, mut sock)
    Result.Ok(Socket.from(sock))
  }

  fn mut set_option(level: Int, option: Int, value: Int) -> Result[Nil, Error] {
    sys.set_int32_option(@socket.fd, level, option, value)
  }

  fn get_option(level: Int, option: Int) -> Int {
    sys.get_int32_option(@socket.fd, level, option)
  }
}

impl Shutdown for Socket {
  fn pub mut shutdown_read -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: false)
  }

  fn pub mut shutdown_write -> Result[Nil, Error] {
    sys.shutdown(@socket, read: false, write: true)
  }

  fn pub mut shutdown -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: true)
  }
}

impl Deadline for Socket {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  fn pub mut reset_deadline {
    @deadline = poll.NO_DEADLINE
  }
}

impl RawSocketOperations for Socket {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket
  }

  fn inline raw_deadline -> Int {
    @deadline
  }
}

impl SendFile[Error] for Socket {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    sys.send_file_stream(file, self)
  }
}

impl Drop for Socket {
  fn mut drop {
    sys.close(@socket)
  }
}

impl Read[Error] for Socket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    sys.read(@socket, into, size, @deadline)
  }
}

impl WriteInternal for Socket {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    sys.write(@socket, data, size, @deadline)
  }
}

impl Write[Error] for Socket {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    write_all_internal(bytes.pointer, bytes.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A UDP socket.
#
# A `UdpSocket` can be used to easily create a bound UDP socket from an IP
# address and a port.
type pub UdpSocket {
  # The raw `Socket` wrapped by this `UdpSocket`.
  let pub @socket: Socket

  # Creates a new `UdpSocket`, bound to the given address.
  #
  # # Examples
  #
  # Creating a new bound UDP socket:
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 0).get
  # ```
  fn pub static new(ip: IpAddress, port: Int) -> Result[UdpSocket, Error] {
    let socket = try Socket.datagram(ip.v6?)

    try socket.bind(ip, port)
    Result.Ok(UdpSocket(socket))
  }

  # Connects `self` to the remote address.
  #
  # Connecting a `UdpSocket` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UdpSocket.receive_from` and `UdpSocket.send_to`.
  #
  # # Examples
  #
  # Connecting a UDP socket:
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket1 =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 40_000).get
  # let socket2 =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  #
  # socket1.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  # ```
  fn pub mut connect(ip: IpAddress, port: Int) -> Result[Nil, Error] {
    @socket.connect(ip, port)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `Socket.send_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #
  # socket.send_to('hello', ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut send_to[B: Bytes](
    bytes: ref B,
    ip: IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    @socket.send_to(bytes, ip, port)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # See the documentation of `Socket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, SocketAddress), Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UdpSocket, Error] {
    @socket.try_clone.map(fn (sock) { UdpSocket(sock) })
  }
}

impl Deadline for UdpSocket {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl RawSocketOperations for UdpSocket {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket.socket
  }

  fn inline raw_deadline -> Int {
    @socket.deadline
  }
}

impl SendFile[Error] for UdpSocket {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    sys.send_file_datagram(buffer, file, self)
  }
}

impl Read[Error] for UdpSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write[Error] for UdpSocket {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    @socket.write(bytes)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A TCP socket connected to another TCP socket.
type pub TcpClient {
  # The raw `Socket` wrapped by this `TcpClient`.
  let pub @socket: Socket

  fn static connect(
    ip: IpAddress,
    port: Int,
    timeout_after: Instant,
  ) -> Result[TcpClient, Error] {
    let socket = try Socket.stream(ip.v6?)

    try socket.no_delay = true
    socket.timeout_after = timeout_after
    try socket.connect(ip, port)
    socket.reset_deadline
    Result.Ok(TcpClient(socket))
  }

  # Creates a new `TcpClient` that's connected to an IP address and port number,
  # using a default timeout.
  #
  # This method uses a default timeout of 5 seconds. If you wish to use a
  # custom timeout/deadline, use `TcpClient.with_timeout` instead.
  #
  # For more details, refer to the documentation of `TcpClient.with_timeout`.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (TcpClient)
  # import std.net.ip (IpAddress)
  #
  # TcpClient.new([IpAddress.v4(127, 0, 0, 1)], port: 40_000).get
  # ```
  fn pub static new(
    ips: ref Array[IpAddress],
    port: Int,
  ) -> Result[TcpClient, Error] {
    with_timeout(ips, port, Duration.from_secs(5))
  }

  # Creates a new `TcpClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` system call times out. This deadline is _not_ inherited by the
  # returned `TcpClient`.
  #
  # # Connecting to multiple IP addresses
  #
  # If multiple IP addresses are given, this method attempts to connect to them
  # in accordance with [RFC 8305](https://datatracker.ietf.org/doc/html/rfc8305)
  # (also known as "Happy Eyeballs version 2"), with the following differences:
  #
  # - DNS requests are performed separately and thus not subject to the Happy
  #   Eyeballs algorithm.
  # - We always interleave IPv6 and IPv4 addresses, starting with an IPv6
  #   address (so `IPv6, IPv4, IPv6, IPv4, ...`).
  # - There's no way to configure this behavior, nor is it planned to add the
  #   ability to do so.
  #
  # # Errors
  #
  # If the connection can't be established, a `std.io.Error` error is returned.
  #
  # If `ips` contains multiple IP addresses and a connection can't be
  # established to any of the addresses, one of the following errors is
  # returned:
  #
  # - `Error.ConnectionRefused` if no connection could be established before the
  #   deadline expired
  # - `Error.TimedOut` if the deadline expired
  #
  # If `ips` is empty, an `Error.InvalidArgument` error is returned instead of
  # producing a panic. This is to allow handling of cases where one passes the
  # output of e.g. `std.net.dns.Resolver.resolve` directly to this method
  # without checking if the DNS record actually contains any IP addresses.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (TcpClient)
  # import std.net.ip (IpAddress)
  # import std.time (Duration)
  #
  # TcpClient
  #   .with_timeout(
  #     ips: [IpAddress.v4(0, 0, 0, 0)],
  #     port: 40_000,
  #     timeout_after: Duration.from_secs(5)
  #   )
  #   .get
  # ```
  fn pub static with_timeout[T: ToInstant](
    ips: ref Array[IpAddress],
    port: Int,
    timeout_after: ref T,
  ) -> Result[TcpClient, Error] {
    happy.connect(ips, port, timeout_after.to_instant)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `Socket.peer_address` for more information.
  fn pub peer_address -> Result[SocketAddress, Error] {
    @socket.peer_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpClient, Error] {
    @socket.try_clone.map(fn (sock) { TcpClient(sock) })
  }
}

impl Shutdown for TcpClient {
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }
}

impl Deadline for TcpClient {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl RawSocketOperations for TcpClient {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket.socket
  }

  fn inline raw_deadline -> Int {
    @socket.deadline
  }
}

impl SendFile[Error] for TcpClient {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    sys.send_file_stream(file, self)
  }
}

impl Read[Error] for TcpClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write[Error] for TcpClient {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    @socket.write(bytes)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

type inline Waiter {
  let @reader: Pipe
  let @notified: AtomicBool

  fn static new(reader: Pipe, notified: AtomicBool) -> Self {
    Self(reader: reader, notified: notified)
  }

  fn notified? -> Bool {
    @notified.load
  }

  fn mut as_poll -> Pointer[poll.Poll] {
    @reader.as_poll
  }
}

# A type for notifying a `TcpServer` or `UnixServer` such that the current or
# next call to `accept` returns an `std.io.Error.Interrupted` error.
type pub inline Notifier {
  let @writer: PipeWriter
  let @notified: AtomicBool

  fn static new -> Result[(uni Notifier, Waiter), Error] {
    let (r, w) = try Pipe.new
    let not = AtomicBool.new(false)

    Result.Ok((recover Notifier(writer: w, notified: not), Waiter.new(r, not)))
  }

  # Notifies the corresponding `TcpServer` or `UnixServer` socket.
  fn pub mut notify {
    if @notified.compare_and_swap(current: false, new: true) {
      @writer.write('1')
    }
  }
}

# A TCP socket server that can accept incoming connections.
type pub TcpServer {
  # The raw `Socket` wrapped by this `TcpServer`.
  let pub @socket: Socket
  let @waiter: Waiter
  let mut @notifier: Option[uni Notifier]
  let @poller: poll.Poller

  fn static from(socket: Socket) -> Result[Self, Error] {
    let (not, wait) = try Notifier.new
    let poller = try poll.Poller.new

    try poller.add(socket.raw_socket, wait.as_poll)
    Result.Ok(
      Self(
        socket: socket,
        waiter: wait,
        notifier: Option.Some(not),
        poller: poller,
      ),
    )
  }

  # Creates a new `TcpServer` bound to and listening on the given IP address
  # and port.
  #
  # A `TcpServer` uses `SO_REUSEADDR` and `SO_REUSEPORT` to allow for fast
  # rebinding of sockets. `SO_REUSEPORT` is only used on platforms that support
  # it.
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (IpAddress)
  # import std.net.socket (TcpServer)
  #
  # TcpServer.new(IpAddress.v4(0, 0, 0, 0), port: 40_000).get
  # ```
  fn pub static new(ip: IpAddress, port: Int) -> Result[TcpServer, Error] {
    let socket = try Socket.stream(ip.v6?)

    try socket.no_delay = true
    try socket.reuse_address = true
    try socket.reuse_port = true
    try socket.bind(ip, port)
    try socket.listen

    from(socket)
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Errors
  #
  # This method may return a `std.io.Error` error for various reasons depending
  # on the underlying platform.
  #
  # # Interrupts
  #
  # An application may wish to interrupt a call to this method as part of a
  # graceful shutdown sequence. While some platforms support doing so using
  # `TcpServer.try_clone` and calling `Socket.shutdown` on the resulting socket
  # (through the `TcpServer.socket` field), this is not portable and most
  # notably macOS doesn't support this.
  #
  # Instead one can obtain a `Notifier` instance using `TcpServer.notifier`.
  # This `Notifier` can then be sent to another process to notify and wake up a
  # `TcpServer` based on some condition. A `Notifier` may only be acquired once.
  #
  # When a `Notifier` notifies its corresponding `TcpServer`, the current or
  # next call to `TcpServer.accept` will return a `std.io.Error.Interrupted`
  # error, and continues to do so on future calls, meaning the `TcpServer` is no
  # longer able to accept new connections.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  # ```inko
  # import std.net.socket (TcpServer, TcpClient)
  # import std.net.ip (IpAddress)
  #
  # let listener = TcpServer.new(IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  # let client = TcpClient.new(IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  #
  # client.write('ping')
  #
  # let connection = listener.accept.get
  # let buffer = ByteArray.new
  #
  # connection.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  #
  # Interrupting the `accept` call:
  #
  # ```inko
  # import std.net.ip (IpAddress)
  # import std.net.socket (Notifier, TcpServer)
  # import std.process (sleep)
  # import std.time (Duration)
  #
  # type async Notify {
  #   fn async notify(notifier: uni Notifier) {
  #     sleep(Duration.from_secs(1))
  #     notifier.notify
  #   }
  # }
  #
  # type async Main {
  #   fn async main {
  #     let sock = TcpServer.new(IpAddress.v4(127, 0, 0, 1), port: 8000).get
  #     let not = sock.notifier.get
  #
  #     Notify().notify(not)
  #     sock.accept # => Result.Error(std.io.Error.Interrupted)
  #   }
  # }
  # ```
  fn pub mut accept -> Result[TcpClient, Error] {
    if @waiter.notified? { throw Error.Interrupted }

    let peer = net.raw_socket

    try sys.accept(
      @socket.raw_socket,
      mut peer,
      @socket.deadline,
      poller: Option.Some(@poller),
    )

    Result.Ok(TcpClient(Socket.from(peer)))
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpServer, Error] {
    TcpServer.from(try @socket.try_clone)
  }

  # Takes ownership of the notifier in `self` and returns it, if it's still
  # present.
  #
  # For more details refer to the documentation of `TcpServer.accept`.
  fn pub mut notifier -> Option[uni Notifier] {
    @notifier := Option.None
  }
}

impl Deadline for TcpServer {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl RawSocketOperations for TcpServer {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket.socket
  }

  fn inline raw_deadline -> Int {
    @socket.deadline
  }
}

# A Unix domain socket address.
type pub inline UnixAddress {
  # The path or name of the address.
  #
  # This is a `String` since using a `Path` does not make sense for abstract
  # and unnamed addresses.
  let pub @address: String

  # Returns the path of this address.
  #
  # If the address is unnamed or an abstract address, None is returned.
  fn pub to_path -> Option[Path] {
    if unnamed? or abstract? {
      Option.None
    } else {
      Option.Some(@address.to_path)
    }
  }

  # Returns `true` if `self` is an abstract address.
  #
  # # Examples
  #
  # Checking if an address is abstract:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress('/tmp/test.sock'.to_path).abstract?    # => false
  # UnixAddress("\0example-address".to_path).abstract? # => true
  # ```
  fn pub abstract? -> Bool {
    @address.get(0).or(-1) == 0
  }

  # Returns `true` if `self` is an unnamed address.
  #
  # # Examples
  #
  # Checking if an address is unnamed:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress('/tmp/test.sock'.to_path).unnamed? # => false
  # UnixAddress(''.to_path).unnamed?               # => true
  # ```
  fn pub unnamed? -> Bool {
    @address.empty?
  }

  # Returns a `String` containing a human-readable representation of the
  # address.
  #
  # While `UnixAddress.to_string` returns the address as-is, this method returns
  # a more readable version. For example, for abstract addresses the leading
  # NULL byte is replaced with `@` and for unnamed addresses the `String`
  # "unnamed" is returned.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress('test.sock'.to_path).to_readable_string # => 'test.sock'
  # UnixAddress('test.sock'.to_path).to_readable_string # => 'test.sock'
  # ```
  fn pub to_readable_string -> String {
    if abstract? {
      '@${@address.slice(start: 1, end: @address.size)}'
    } else if unnamed? {
      'unnamed'
    } else {
      @address
    }
  }
}

impl Clone for UnixAddress {
  fn pub clone -> Self {
    Self(@address)
  }
}

impl Format for UnixAddress {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write(to_readable_string)
  }
}

impl Equal for UnixAddress {
  # Returns `true` if `self` and `other` are the same socket addresses.
  #
  # # Examples
  #
  # Comparing two `UnixAddress` objects:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress('a.sock'.to_path) == UnixAddress('a.sock'.to_path) # => true
  # UnixAddress('a.sock'.to_path) == UnixAddress('b.sock'.to_path) # => false
  # ```
  fn pub ==(other: ref UnixAddress) -> Bool {
    @address == other.address
  }
}

impl ToString for UnixAddress {
  # Returns the address name or path as a `String`.
  #
  # # Examples
  #
  # Converting a `UnixAddress` to a `String`:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress('/tmp/test.sock'.to_path).to_string # => '/tmp/test.sock'
  # UnixAddress("\0example".to_path).to_string      # => "\0example"
  # ```
  fn pub to_string -> String {
    @address
  }
}

impl Hash for UnixAddress {
  fn pub hash[H: mut + Hasher](hasher: mut H) {
    @address.hash(hasher)
  }
}

# A low-level, non-blocking Unix domain socket.
type pub UnixSocket {
  let @socket: poll.Poll

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let mut @deadline: Int

  fn inline static from(socket: poll.Poll) -> Self {
    Self(socket: socket, deadline: poll.NO_DEADLINE)
  }

  fn static new(kind: Int) -> Result[UnixSocket, Error] {
    let sock = net.raw_socket

    try sys.init_socket(mut sock, libc.AF_UNIX, kind, protocol: 0)
    Result.Ok(from(sock))
  }

  # Returns a new `UnixSocket` configured as a stream socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # UnixSocket.stream
  # ```
  fn pub static stream -> Result[UnixSocket, Error] {
    UnixSocket.new(libc.SOCK_STREAM)
  }

  # Returns a new `UnixSocket` configured as a datagram socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # UnixSocket.datagram
  # ```
  fn pub static datagram -> Result[UnixSocket, Error] {
    UnixSocket.new(libc.SOCK_DGRAM)
  }

  # Binds this socket to the specified path or abstract address.
  #
  # # Abstract sockets
  #
  # Linux supports the concept of an "abstract" socket. These are sockets that
  # don't use regular file paths, instead the path starts with a NULL byte and
  # is followed by zero or more additional (and optional) bytes. While this
  # method supports creating such sockets, this isn't portable across platforms
  # (e.g. macOS and FreeBSD don't support it).
  #
  # # Unnamed sockets
  #
  # Linux supports the concept of an "unnamed" socket. These are sockets that
  # don't specify a path to bind to, resulting in the kernel assigning them an
  # address. Such sockets are created by using an empty `Path` as the argument
  # for this method.
  #
  # On non-Linux platforms this isn't supported and providing an empty `Path`
  # will result in an `Error.InvalidArgument` error.
  #
  # # Path sizes
  #
  # Different platforms enforce different limits on the maximum size of `path`.
  # For example, on Linux the path size limit is 108 bytes (including the
  # trailing NULL byte). If the path is too long, this method returns an
  # `Error.InvalidArgument` error.
  #
  # # Examples
  #
  # Binding a Unix socket to a path:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # ```
  fn pub mut bind(path: ref Path) -> Result[Nil, Error] {
    sys.bind_unix(@socket.fd, path)
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a Unix socket:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let listener = UnixSocket.stream.get
  # let stream = UnixSocket.stream.get
  #
  # listener.bind('/tmp/test.sock'.to_path).get
  # listener.listen.get
  #
  # stream.connect('/tmp/test.sock').get
  # ```
  fn pub mut connect(path: ref Path) -> Result[Nil, Error] {
    sys.connect_unix(@socket, path, @deadline)
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.stream.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket.listen.get
  # ```
  fn pub mut listen -> Result[Nil, Error] {
    sys.listen(@socket.fd, MAXIMUM_LISTEN_BACKLOG)
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let listener = UnixSocket.stream.get
  # let stream = UnixSocket.stream.get
  #
  # listener.bind('/tmp/test.sock'.to_path).get
  # listener.listen.get
  #
  # stream.connect('/tmp/test.sock').get
  # stream.write('ping').get
  #
  # let client = listener.accept.get
  # let buffer = ByteArray.new
  #
  # client.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[UnixSocket, Error] {
    let peer = net.raw_socket

    try sys.accept(@socket, mut peer, @deadline, poller: Option.None)
    Result.Ok(UnixSocket(socket: peer, deadline: poll.NO_DEADLINE))
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket.send_to('hello', address: '/tmp/test.sock'.to_path).get
  # ```
  fn pub mut send_to[B: Bytes](
    bytes: ref B,
    address: ref Path,
  ) -> Result[Int, Error] {
    sys.send_to_unix(@socket, bytes.pointer, bytes.size, address, @deadline)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  # let bytes = ByteArray.new
  #
  # socket.send_to('hello', address: '/tmp/test.sock'.to_path).get
  #
  # let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  # bytes.to_string           # => 'hello'
  # received_from.0           # => 5
  # received_from.1.to_string # => '/tmp/test.sock'
  # ```
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, UnixAddress), Error] {
    match sys.receive_from_unix(@socket, bytes, size, @deadline) {
      case Ok((read, path)) -> Result.Ok((read, UnixAddress(path)))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[UnixAddress, Error] {
    match sys.unix_local_address(@socket) {
      case Ok(path) -> Result.Ok(UnixAddress(path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[UnixAddress, Error] {
    match sys.unix_peer_address(@socket) {
      case Ok(path) -> Result.Ok(UnixAddress(path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_RCVBUF, value.to_int)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_SNDBUF, value.to_int)
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixSocket, Error] {
    let sock = net.raw_socket

    try sys.try_clone(@socket, mut sock)
    Result.Ok(UnixSocket(socket: sock, deadline: poll.NO_DEADLINE))
  }

  fn mut set_option(level: Int, option: Int, value: Int) -> Result[Nil, Error] {
    sys.set_int32_option(@socket.fd, level, option, value)
  }
}

impl Shutdown for UnixSocket {
  fn pub mut shutdown_read -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: false)
  }

  fn pub mut shutdown_write -> Result[Nil, Error] {
    sys.shutdown(@socket, read: false, write: true)
  }

  fn pub mut shutdown -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: true)
  }
}

impl Deadline for UnixSocket {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  fn pub mut reset_deadline {
    @deadline = poll.NO_DEADLINE
  }
}

impl RawSocketOperations for UnixSocket {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket
  }

  fn inline raw_deadline -> Int {
    @deadline
  }
}

impl SendFile[Error] for UnixSocket {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    sys.send_file_stream(file, self)
  }
}

impl Drop for UnixSocket {
  fn mut drop {
    sys.close(@socket)
  }
}

impl Read[Error] for UnixSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    sys.read(@socket, into, size, @deadline)
  }
}

impl WriteInternal for UnixSocket {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    sys.write(@socket, data, size, @deadline)
  }
}

impl Write[Error] for UnixSocket {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    write_all_internal(bytes.pointer, bytes.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A Unix datagram socket.
type pub UnixDatagram {
  # The raw `UnixSocket` wrapped by this `UnixDatagram`.
  let pub @socket: UnixSocket

  # Creates a new Unix datagram socket bound to the given address.
  #
  # # Examples
  #
  # Creating a new Unix datagram socket:
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # UnixDatagram.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixDatagram, Error] {
    let socket = try UnixSocket.datagram

    try socket.bind(address)
    Result.Ok(UnixDatagram(socket))
  }

  # Connects `self` to the remote addres.s
  #
  # Connecting a `UnixDatagram` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UnixDatagram.receive_from` and `UnixDatagram.send_to`.
  #
  # # Examples
  #
  # Connecting a Unix datagram socket:
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket1 = UnixDatagram.new('/tmp/test1.sock'.to_path).get
  # let socket2 = UnixDatagram.new('/tmp/test2.sock'.to_path).get
  #
  # socket1.connect('/tmp/test2.sock').get
  # ```
  fn pub mut connect(address: ref Path) -> Result[Nil, Error] {
    @socket.connect(address)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `UnixSocket.send_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket = UnixDatagram.new('/tmp/test.sock'.to_path).get
  #
  # socket.send_to('hello', address: '/tmp/test.sock'.to_path).get
  # ```
  fn pub mut send_to[B: Bytes](
    bytes: ref B,
    address: ref Path,
  ) -> Result[Int, Error] {
    @socket.send_to(bytes, address)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # See the documentation of `UnixSocket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, UnixAddress), Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixDatagram, Error] {
    @socket.try_clone.map(fn (sock) { UnixDatagram(sock) })
  }
}

impl Deadline for UnixDatagram {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl RawSocketOperations for UnixDatagram {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket.socket
  }

  fn inline raw_deadline -> Int {
    @socket.deadline
  }
}

impl SendFile[Error] for UnixDatagram {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    sys.send_file_datagram(buffer, file, self)
  }
}

impl Read[Error] for UnixDatagram {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write[Error] for UnixDatagram {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    @socket.write(bytes)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A Unix stream socket connected to another Unix socket.
type pub UnixClient {
  # The raw `UnixSocket` wrapped by this `UnixClient`.
  let pub @socket: UnixSocket

  # Creates a new `UnixClient` that is connected to the given address.
  #
  # This method doesn't enforce a deadline on establishing the connection. If
  # you need to limit the amount of time spent waiting to establish the
  # connection, use `UnixClient.with_timeout` instead.
  #
  # # Examples
  #
  # Connecting a `UnixClient`:
  #
  # ```inko
  # import std.net.socket (UnixServer, UnixClient)
  #
  # let listener = UnixServer.new('/tmp/test.sock'.to_path).get
  #
  # UnixClient.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.stream

    try socket.connect(address)
    Result.Ok(UnixClient(socket))
  }

  # Creates a new `UnixClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` times out. The deadline is cleared once connected.
  #
  # See `UnixClient.new` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixClient)
  # import std.time (Duration)
  #
  # UnixClient
  #   .with_timeout(
  #     address: '/tmp/test.sock'
  #     timeout_after: Duration.from_secs(5)
  #   )
  #   .get
  # ```
  fn pub static with_timeout[T: ToInstant](
    address: ref Path,
    timeout_after: ref T,
  ) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.stream

    socket.timeout_after = timeout_after
    try socket.connect(address)
    socket.reset_deadline
    Result.Ok(UnixClient(socket))
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `UnixSocket.peer_address` for more information.
  fn pub peer_address -> Result[UnixAddress, Error] {
    @socket.peer_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixClient, Error] {
    @socket.try_clone.map(fn (sock) { UnixClient(sock) })
  }
}

impl Shutdown for UnixClient {
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }
}

impl Deadline for UnixClient {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl RawSocketOperations for UnixClient {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket.socket
  }

  fn inline raw_deadline -> Int {
    @socket.deadline
  }
}

impl SendFile[Error] for UnixClient {
  fn pub mut send_file(
    buffer: mut ByteArray,
    file: mut ReadOnlyFile,
  ) -> Result[Int, Error] {
    sys.send_file_stream(file, self)
  }
}

impl Read[Error] for UnixClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write[Error] for UnixClient {
  fn pub mut write[B: Bytes](bytes: ref B) -> Result[Nil, Error] {
    @socket.write(bytes)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A Unix socket server that can accept incoming connections.
type pub UnixServer {
  # The raw `UnixSocket` wrapped by this `UnixServer`.
  let pub @socket: UnixSocket
  let @waiter: Waiter
  let mut @notifier: Option[uni Notifier]
  let @poller: poll.Poller

  fn static from(socket: UnixSocket) -> Result[Self, Error] {
    let (not, wait) = try Notifier.new
    let poller = try poll.Poller.new

    try poller.add(socket.raw_socket, wait.as_poll)
    Result.Ok(
      Self(
        socket: socket,
        waiter: wait,
        notifier: Option.Some(not),
        poller: poller,
      ),
    )
  }

  # Creates a new `UnixServer` bound to and listening on the given address.
  #
  # # Examples
  #
  # Creating a `UnixServer`:
  #
  # ```inko
  # import std.net.socket (UnixServer)
  #
  # UnixServer.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixServer, Error] {
    let socket = try UnixSocket.stream

    try socket.bind(address)
    try socket.listen
    from(socket)
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Errors
  #
  # This method may return a `std.io.Error` error for various reasons depending
  # on the underlying platform.
  #
  # A call to this method may be interrupted using a `Notifier`, in which case
  # this method returns a `std.io.Error.Interrupted` error.
  #
  # # Interrupts
  #
  # This method may be interrupted using a `Notifier` similar to
  # `TcpServer.accept`. For more details refer to the documentation of
  # `TcpServer.accept`.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  # ```inko
  # import std.net.socket (UnixServer, UnixClient)
  #
  # let listener = UnixServer.new('/tmp/test.sock'.to_path).get
  # let client = UnixClient.new('/tmp/test.sock'.to_path).get
  #
  # client.write('ping')
  #
  # let connection = listener.accept.get
  # let buffer = ByteArray.new
  #
  # connection.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub mut accept -> Result[UnixClient, Error] {
    if @waiter.notified? { throw Error.Interrupted }

    let peer = net.raw_socket

    try sys.accept(
      @socket.raw_socket,
      mut peer,
      @socket.deadline,
      poller: Option.Some(@poller),
    )

    Result.Ok(UnixClient(UnixSocket.from(peer)))
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixServer, Error] {
    UnixServer.from(try @socket.try_clone)
  }

  # Takes ownership of the notifier in `self` and returns it, if it's still
  # present.
  #
  # For more details refer to the documentation of `TcpServer.accept`.
  fn pub mut notifier -> Option[uni Notifier] {
    @notifier := Option.None
  }
}

impl Deadline for UnixServer {
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @socket.timeout_after = deadline
  }

  fn pub mut reset_deadline {
    @socket.reset_deadline
  }
}

impl RawSocketOperations for UnixServer {
  fn inline mut raw_socket -> Pointer[poll.Poll] {
    @socket.socket
  }

  fn inline raw_deadline -> Int {
    @socket.deadline
  }
}
