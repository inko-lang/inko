# IP and Unix domain sockets.
#
# This module provides types for various socket types, such as TCP, UDP and Unix
# sockets.
#
# The types `Socket` and `UnixSocket` are low-level sockets that implement most
# of the socket logic. Types such as `TcpServer` and `TcpClient` wrap these
# sockets to make it easier to create commonly used sockets, such as a TCP
# client.
#
# # Deadlines and timeouts
#
# Socket timeouts are supported through a mechanism known as a "deadline". A
# deadline specifies the time after which socket operations must time out when
# waiting for them to complete. Deadlines represent a fixed point in time, and
# can be created from both `Duration` and `Instant` values.
#
# The use of deadlines instead of timeouts makes it easier to apply time limits
# to multiple operations. Consider the following chain of events:
#
# 1. `read()`
# 1. `write()`
# 1. `read()`
#
# Traditionally one might set a timeout such as 10 seconds. This poses a
# problem: the timeout is applied to every operation, meaning each operation is
# allowed to run up to 10 seconds, resulting in a total maximum runtime of 30
# seconds.
#
# Using deadlines one sets a deadline in the future, and no matter the amount of
# operations performed, the operations time out once we cross the deadline. In
# our above example that means we can easily limit the total runtime to 10
# seconds using a deadline that's 10 seconds in the future.
#
# Deadlines are set using `Socket.timeout_after` and
# `UnixSocket.timeout_after=`. Here's an example using deadlines to limit the
# time spent waiting for a client to connect:
#
# ```inko
# import std.net.ip (IpAddress)
# import std.net.socket (TcpServer)
# import std.time (Duration)
#
# let server = TcpServer.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9000).get
#
# server.socket.timeout_after = Duration.from_secs(3)
#
# # This times out after roughly three seconds.
# server.accept.get
# ```
#
# It's important to keep in mind that deadlines only apply when an operation
# must wait, i.e. a read is performed but no data is available. If the operation
# completes immediately (i.e. a read is performed and enough data _is_
# available), the deadline is ignored. This means that if you perform an
# operation in a loop and set a deadline, and data is always available such that
# the operation never blocks, the loop may run indefinitely; depending on what
# the loop does of course.
#
# For more information about timeouts versus deadlines, consider reading [this
# article](https://vorpus.org/blog/timeouts-and-cancellation-for-humans/).
import std.cmp (Equal)
import std.drop (Drop)
import std.fmt (Format, Formatter)
import std.fs.path (Path)
import std.io (Error, Read, Write, WriteInternal)
import std.libc
import std.net.happy
import std.net.ip (IpAddress)
import std.string (ToString)
import std.sys.net
import std.sys.unix.net (self as sys) if unix
import std.time (Duration, Instant, ToInstant)

# The maximum value valid for a listen() call.
#
# Linux and FreeBSD do not allow for values greater than this as they internally
# use an u16, so we'll limit the backlog to this value. We don't use SOMAXCONN
# because it might be hardcoded. This means that setting `net.core.somaxconn` on
# Linux (for example) would have no effect.
let MAXIMUM_LISTEN_BACKLOG = 65_535

fn pub try_ips[R, E](
  ips: ref Array[IpAddress],
  fun: fn (IpAddress) -> Result[R, E],
) -> Result[R, E] {
  let iter = ips.iter
  let mut last = Option.None

  loop {
    match iter.next {
      case Some(ip) -> {
        match fun.call(ip) {
          case Ok(v) -> return Result.Ok(v)
          case Error(e) -> last = Option.Some(e)
        }
      }
      case _ -> break
    }
  }

  Result.Error(last.or_panic('at least one IP address must be specified'))
}

trait RawSocketOperations {
  fn mut raw_socket -> Pointer[net.RawSocket]

  fn raw_deadline -> Int
}

# An IPv4 or IPv6 socket address.
type pub copy SocketAddress {
  # The IPv4/IPv6 address of this socket address.
  let pub @ip: IpAddress

  # The port number of this socket address.
  let pub @port: Int
}

impl Equal for SocketAddress {
  # Returns `true` if `self` and `other` are the same.
  fn pub inline ==(other: ref SocketAddress) -> Bool {
    @ip == other.ip and @port == other.port
  }
}

impl Format for SocketAddress {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write('${@ip}:${@port}')
  }
}

# A low-level, non-blocking IPv4 or IPv6 socket.
type pub Socket {
  let @socket: net.RawSocket

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let mut @deadline: Int

  fn static new(ipv6: Bool, kind: Int, protocol: Int) -> Result[Socket, Error] {
    let sock = net.raw_socket
    let domain = if ipv6 { libc.AF_INET6 } else { libc.AF_INET }

    try sys.init_socket(mut sock, domain, kind, protocol)
    Result.Ok(Socket(socket: sock, deadline: net.NO_DEADLINE))
  }

  # Returns a new `Socket` configured as a stream socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.stream(ipv6: false)
  # ```
  fn pub static stream(ipv6: Bool) -> Result[Socket, Error] {
    Socket.new(ipv6, libc.SOCK_STREAM, protocol: 0)
  }

  # Returns a new `Socket` configured as a datagram socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.datagram(ipv6: false)
  # ```
  fn pub static datagram(ipv6: Bool) -> Result[Socket, Error] {
    Socket.new(ipv6, libc.SOCK_DGRAM, protocol: 0)
  }

  # Returns a new `Socket` configured as a raw socket.
  #
  # The `ipv6` argument specifies if the socket is an IPv4 socket (`false`) or
  # an IPv6 socket (`true`).
  #
  # The `protocol` argument must specify a valid IANA IP protocol as defined in
  # RFC 1700.
  #
  # Note that on certain platforms (e.g. Linux, and probably most other Unix
  # systems) you'll need root privileges in order to create a raw socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  #
  # Socket.raw(ipv6: false, protocol: 1)
  # ```
  fn pub static raw(ipv6: Bool, protocol: Int) -> Result[Socket, Error] {
    Socket.new(ipv6, libc.SOCK_RAW, protocol)
  }

  # Sets the point in time after which socket operations must time out, known as
  # a "deadline".
  #
  # # Examples
  #
  # Using a `Duration` results in this method calculating the absolute time
  # after which operations time out:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.time (Duration)
  #
  # let socket = Socket.datagram(ipv6: false)
  #
  # socket.timeout_after = Duration.from_secs(5)
  # ```
  #
  # We can also use an `Instant`:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.time (Duration, Instant)
  #
  # let socket = Socket.datagram(ipv6: false)
  #
  # socket.timeout_after = Instant.new + Duration.from_secs(5)
  # ```
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  # Clears the deadline to apply to socket operations.
  fn pub mut reset_deadline {
    @deadline = net.NO_DEADLINE
  }

  # Binds this socket to the specified address.
  #
  # # Examples
  #
  # Binding a socket:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut bind(ip: ref IpAddress, port: Int) -> Result[Nil, Error] {
    sys.bind_ip(@socket.inner, ip, port)
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a socket:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let listener = Socket.stream(ipv6: false).get
  # let client = Socket.stream(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket.listen.get
  # client.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # ```
  fn pub mut connect(ip: ref IpAddress, port: Int) -> Result[Nil, Error] {
    sys.connect_ip(@socket, ip, port, @deadline)
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.stream(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket.listen.get
  # ```
  fn pub mut listen -> Result[Nil, Error] {
    sys.listen(@socket.inner, MAXIMUM_LISTEN_BACKLOG)
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let listener = Socket.stream(ipv6: false).get
  # let stream = Socket.stream(ipv6: false).get
  #
  # listener.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # listener.listen.get
  #
  # stream.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # stream.write_string('ping').get
  #
  # let client = listener.accept.get
  # let buffer = ByteArray.new
  #
  # client.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[Socket, Error] {
    let peer = net.raw_socket

    try sys.accept(@socket, mut peer, @deadline)
    Result.Ok(Socket(socket: peer, deadline: net.NO_DEADLINE))
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket
  #   .send_string_to(
  #     string: 'hello',
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    sys.send_to_ip(@socket, string.pointer, string.size, ip, port, @deadline)
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  # let bytes = 'hello'.to_byte_array
  #
  # socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # socket
  #   .send_bytes_to(
  #     bytes: bytes,
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    sys.send_to_ip(@socket, bytes.pointer, bytes.size, ip, port, @deadline)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  # ```inko
  # import std.net.socket (Socket)
  # import std.net.ip (IpAddress)
  #
  # let socket = Socket.datagram(ipv6: false).get
  # let bytes = ByteArray.new
  #
  # socket
  #   .send_string_to(
  #     'hello',
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  #
  # let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  # bytes.to_string         # => 'hello'
  # received_from.0         # => 5
  # received_from.1.address # => '0.0.0.0'
  # received_from.1.port    # => 9999
  # ```
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, SocketAddress), Error] {
    match sys.receive_from_ip(@socket, bytes, size, @deadline) {
      case Ok((read, ip, port)) -> Result.Ok((read, SocketAddress(ip, port)))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[SocketAddress, Error] {
    match sys.ip_local_address(@socket) {
      case Ok((ip, port)) -> Result.Ok(SocketAddress(ip, port))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[SocketAddress, Error] {
    match sys.ip_peer_address(@socket) {
      case Ok((ip, port)) -> Result.Ok(SocketAddress(ip, port))
      case Error(e) -> Result.Error(e)
    }
  }

  # Sets the value of the `IP_TTL` option.
  fn pub mut ttl=(value: Int) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_IP, libc.IP_TTL, value)
  }

  # Sets the value of the `IPV6_V6ONLY` option.
  fn pub mut only_ipv6=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_IPV6, libc.IPV6_V6ONLY, value.to_int)
  }

  # Sets the value of the `TCP_NODELAY` option.
  fn pub mut no_delay=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.IPPROTO_TCP, libc.TCP_NODELAY, value.to_int)
  }

  # Returns `true` if the `TCP_NODELAY` option is set.
  fn pub no_delay? -> Bool {
    get_option(libc.IPPROTO_TCP, libc.TCP_NODELAY) != 0
  }

  # Sets the value of the `SO_BROADCAST` option.
  fn pub mut broadcast=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_BROADCAST, value.to_int)
  }

  # Sets the value of the `SO_LINGER` option.
  #
  # If a `Some` is given, the linger value is set to the duration in seconds. If
  # a `None` is given, the linger value is instead reset.
  #
  # On most platforms the linger duration has a precision of whole seconds. If a
  # `Duration` is supplied that is less than one second long or contains
  # fractional seconds, the value may be truncated or rounded to the nearest
  # second.
  fn pub mut linger=(value: Option[Duration]) -> Result[Nil, Error] {
    let linger = libc.Linger(l_onoff: 0 as Int32, l_linger: 0 as Int32)

    match value {
      case Some(d) -> {
        linger.l_onoff = 1 as Int32
        linger.l_linger = d.to_secs.to_int as Int32
      }
      case _ -> {}
    }

    let res = libc.setsockopt(
      @socket.inner,
      libc.SOL_SOCKET as Int32,
      libc.SO_LINGER as Int32,
      (mut linger) as Pointer[UInt8],
      8 as Int32,
    )
      as Int

    if res == 0 { Result.Ok(nil) } else { Result.Error(Error.last_os_error) }
  }

  # Returns the value of the `SO_LINGER` option.
  fn pub linger -> Option[Duration] {
    let linger = libc.Linger(l_onoff: 0 as Int32, l_linger: 0 as Int32)
    let size = 8 as Int32
    let res = libc.getsockopt(
      @socket.inner,
      libc.SOL_SOCKET as Int32,
      libc.SO_LINGER as Int32,
      (mut linger) as Pointer[UInt8],
      mut size,
    )
      as Int

    # Similar to get_option(), this method shouldn't ever reach this point, but
    # we panic just in case we do.
    if res != 0 { sys.getsockopt_error }

    if linger.l_onoff as Int != 0 {
      Option.Some(Duration.from_secs(linger.l_linger as Int))
    } else {
      Option.None
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_RCVBUF, value.to_int)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_SNDBUF, value.to_int)
  }

  # Sets the value of the `SO_KEEPALIVE` option.
  fn pub mut keepalive=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_KEEPALIVE, value.to_int)
  }

  # Sets the value of the `SO_REUSEADDR` option.
  fn pub mut reuse_address=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_REUSEADDR, value.to_int)
  }

  # Sets the value of the `SO_REUSEPORT` option.
  #
  # Not all platforms may support this option, in which case the supplied
  # argument will be ignored.
  fn pub mut reuse_port=(value: Bool) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_REUSEPORT, value.to_int)
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: false)
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    sys.shutdown(@socket, read: false, write: true)
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: true)
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[Socket, Error] {
    let sock = net.raw_socket

    try sys.try_clone(@socket, mut sock)
    Result.Ok(Socket(socket: sock, deadline: net.NO_DEADLINE))
  }

  fn mut set_option(level: Int, option: Int, value: Int) -> Result[Nil, Error] {
    sys.set_int32_option(@socket.inner, level, option, value)
  }

  fn get_option(level: Int, option: Int) -> Int {
    sys.get_int32_option(@socket.inner, level, option)
  }
}

impl RawSocketOperations for Socket {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket
  }

  fn raw_deadline -> Int {
    @deadline
  }
}

impl Drop for Socket {
  fn mut drop {
    sys.close(@socket)
  }
}

impl Read for Socket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    sys.read(@socket, into, size, @deadline)
  }
}

impl WriteInternal for Socket {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    sys.write(@socket, data, size, @deadline)
  }
}

impl Write for Socket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    write_all_internal(bytes.pointer, bytes.size)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    write_all_internal(string.pointer, string.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A UDP socket.
#
# A `UdpSocket` can be used to easily create a bound UDP socket from an IP
# address and a port.
type pub UdpSocket {
  # The raw `Socket` wrapped by this `UdpSocket`.
  let pub @socket: Socket

  # Creates a new `UdpSocket`, bound to the given address.
  #
  # # Examples
  #
  # Creating a new bound UDP socket:
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 0).get
  # ```
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[UdpSocket, Error] {
    let socket = try Socket.datagram(ip.v6?)

    try socket.bind(ip, port)
    Result.Ok(UdpSocket(socket))
  }

  # Connects `self` to the remote address.
  #
  # Connecting a `UdpSocket` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UdpSocket.receive_from` and `UdpSocket.send_to`.
  #
  # # Examples
  #
  # Connecting a UDP socket:
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket1 =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 40_000).get
  # let socket2 =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  #
  # socket1.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 41_000).get
  # ```
  fn pub mut connect(ip: ref IpAddress, port: Int) -> Result[Nil, Error] {
    @socket.connect(ip, port)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `Socket.send_string_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  #
  # socket
  #   .send_string_to(
  #     string: 'hello',
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    @socket.send_string_to(string, ip, port)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `Socket.send_bytes_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UdpSocket)
  # import std.net.ip (IpAddress)
  #
  # let socket =
  #   UdpSocket.new(ip: IpAddress.v4(0, 0, 0, 0), port: 9999).get
  # let bytes = 'hello'.to_byte_array
  #
  # socket
  #   .send_bytes_to(
  #     bytes: bytes,
  #     ip: IpAddress.v4(0, 0, 0, 0),
  #     port: 9999
  #   )
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    ip: ref IpAddress,
    port: Int,
  ) -> Result[Int, Error] {
    @socket.send_bytes_to(bytes, ip, port)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # See the documentation of `Socket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, SocketAddress), Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UdpSocket, Error] {
    @socket.try_clone.map(fn (sock) { UdpSocket(sock) })
  }
}

impl RawSocketOperations for UdpSocket {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for UdpSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UdpSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A TCP socket connected to another TCP socket.
type pub TcpClient {
  # The raw `Socket` wrapped by this `TcpClient`.
  let pub @socket: Socket

  fn static from(socket: Socket) -> Result[TcpClient, Error] {
    try socket.no_delay = true
    Result.Ok(TcpClient(socket))
  }

  fn static connect(
    ip: IpAddress,
    port: Int,
    timeout_after: Instant,
  ) -> Result[TcpClient, Error] {
    let socket = try Socket.stream(ip.v6?)

    socket.timeout_after = timeout_after
    try socket.connect(ip, port)
    socket.reset_deadline
    from(socket)
  }

  # Creates a new `TcpClient` that's connected to an IP address and port number,
  # using a default timeout.
  #
  # This method uses a default timeout of 5 seconds. If you wish to use a
  # custom timeout/deadline, use `TcpClient.with_timeout` instead.
  #
  # For more details, refer to the documentation of `TcpClient.with_timeout`.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (TcpClient)
  # import std.net.ip (IpAddress)
  #
  # TcpClient.new([IpAddress.v4(127, 0, 0, 1)], port: 40_000).get
  # ```
  fn pub static new(
    ips: ref Array[IpAddress],
    port: Int,
  ) -> Result[TcpClient, Error] {
    with_timeout(ips, port, Duration.from_secs(5))
  }

  # Creates a new `TcpClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` system call times out. This deadline is _not_ inherited by the
  # returned `TcpClient`.
  #
  # # Connecting to multiple IP addresses
  #
  # If multiple IP addresses are given, this method attempts to connect to them
  # in accordance with [RFC 8305](https://datatracker.ietf.org/doc/html/rfc8305)
  # (also known as "Happy Eyeballs version 2"), with the following differences:
  #
  # - DNS requests are performed separately and thus not subject to the Happy
  #   Eyeballs algorithm.
  # - We always interleave IPv6 and IPv4 addresses, starting with an IPv6
  #   address (so `IPv6, IPv4, IPv6, IPv4, ...`).
  # - There's no way to configure this behavior, nor is it planned to add the
  #   ability to do so.
  #
  # # Errors
  #
  # If the connection can't be established, a `std.io.Error` error is returned.
  #
  # If `ips` contains multiple IP addresses and a connection can't be
  # established to any of the addresses, one of the following errors is
  # returned:
  #
  # - `Error.ConnectionRefused` if no connection could be established before the
  #   deadline expired
  # - `Error.TimedOut` if the deadline expired
  #
  # If `ips` is empty, an `Error.InvalidArgument` error is returned instead of
  # producing a panic. This is to allow handling of cases where one passes the
  # output of e.g. `std.net.dns.Resolver.resolve` directly to this method
  # without checking if the DNS record actually contains any IP addresses.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (TcpClient)
  # import std.net.ip (IpAddress)
  # import std.time (Duration)
  #
  # TcpClient
  #   .with_timeout(
  #     ips: [IpAddress.v4(0, 0, 0, 0)],
  #     port: 40_000,
  #     timeout_after: Duration.from_secs(5)
  #   )
  #   .get
  # ```
  fn pub static with_timeout[T: ToInstant](
    ips: ref Array[IpAddress],
    port: Int,
    timeout_after: ref T,
  ) -> Result[TcpClient, Error] {
    happy.connect(ips, port, timeout_after.to_instant)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `Socket.peer_address` for more information.
  fn pub peer_address -> Result[SocketAddress, Error] {
    @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpClient, Error] {
    @socket.try_clone.map(fn (sock) { TcpClient(sock) })
  }
}

impl RawSocketOperations for TcpClient {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for TcpClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for TcpClient {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A TCP socket server that can accept incoming connections.
type pub TcpServer {
  # The raw `Socket` wrapped by this `TcpServer`.
  let pub @socket: Socket

  # Creates a new `TcpServer` bound to and listening on the given IP address
  # and port.
  #
  # A `TcpServer` uses `SO_REUSEADDR` and `SO_REUSEPORT` to allow for fast
  # rebinding of sockets. `SO_REUSEPORT` is only used on platforms that support
  # it.
  #
  # # Examples
  #
  # ```inko
  # import std.net.ip (IpAddress)
  # import std.net.socket (TcpServer)
  #
  # TcpServer.new(IpAddress.v4(0, 0, 0, 0), port: 40_000).get
  # ```
  fn pub static new(ip: ref IpAddress, port: Int) -> Result[TcpServer, Error] {
    let socket = try Socket.stream(ip.v6?)

    try socket.no_delay = true
    try socket.reuse_address = true
    try socket.reuse_port = true
    try socket.bind(ip, port)
    try socket.listen
    Result.Ok(TcpServer(socket))
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  # ```inko
  # import std.net.socket (TcpServer, TcpClient)
  # import std.net.ip (IpAddress)
  #
  # let listener =
  #   TcpServer.new(ip: IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  # let client =
  #   TcpClient.new(ip: IpAddress.v4(127, 0, 0, 1), port: 40_000).get
  #
  # client.write_string('ping')
  #
  # let connection = listener.accept.get
  # let buffer = ByteArray.new
  #
  # connection.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[TcpClient, Error] {
    @socket.accept.then(fn (sock) { TcpClient.from(sock) })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `Socket.local_address` for more information.
  fn pub local_address -> Result[SocketAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[TcpServer, Error] {
    @socket.try_clone.map(fn (sock) { TcpServer(sock) })
  }
}

impl RawSocketOperations for TcpServer {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

# A Unix domain socket address.
type pub inline UnixAddress {
  # The path or name of the address.
  #
  # This is a `String` since using a `Path` does not make sense for abstract
  # and unnamed addresses.
  let pub @address: String

  # Returns the path of this address.
  #
  # If the address is unnamed or an abstract address, None is returned.
  fn pub to_path -> Option[Path] {
    if unnamed? or abstract? {
      Option.None
    } else {
      Option.Some(@address.to_path)
    }
  }

  # Returns `true` if `self` is an abstract address.
  #
  # # Examples
  #
  # Checking if an address is abstract:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('/tmp/test.sock'.to_path).abstract?    # => false
  # UnixAddress.new("\0example-address".to_path).abstract? # => true
  # ```
  fn pub abstract? -> Bool {
    @address.size > 0 and @address.byte(0) == 0
  }

  # Returns `true` if `self` is an unnamed address.
  #
  # # Examples
  #
  # Checking if an address is unnamed:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('/tmp/test.sock'.to_path).unnamed? # => false
  # UnixAddress.new(''.to_path).unnamed?               # => true
  # ```
  fn pub unnamed? -> Bool {
    @address.empty?
  }
}

impl Format for UnixAddress {
  fn pub fmt(formatter: mut Formatter) {
    let write = if abstract? {
      '@${@address.slice(start: 1, end: @address.size)}'
    } else if unnamed? {
      'unnamed'
    } else {
      @address
    }

    formatter.write(write)
  }
}

impl Equal for UnixAddress {
  # Returns `true` if `self` and `other` are the same socket addresses.
  #
  # # Examples
  #
  # Comparing two `UnixAddress` objects:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('a.sock'.to_path) == UnixAddress.new('a.sock'.to_path) # => true
  # UnixAddress.new('a.sock'.to_path) == UnixAddress.new('b.sock'.to_path) # => false
  # ```
  fn pub ==(other: ref UnixAddress) -> Bool {
    @address == other.address
  }
}

impl ToString for UnixAddress {
  # Returns the address name or path as a `String`.
  #
  # # Examples
  #
  # Converting a `UnixAddress` to a `String`:
  #
  # ```inko
  # import std.net.socket (UnixAddress)
  #
  # UnixAddress.new('/tmp/test.sock'.to_path).to_string # => '/tmp/test.sock'
  # UnixAddress.new("\0example".to_path).to_string      # => "\0example"
  # ```
  fn pub to_string -> String {
    @address
  }
}

# A low-level, non-blocking Unix domain socket.
type pub UnixSocket {
  let @socket: net.RawSocket

  # A point in time after which socket operations time out.
  #
  # We use an `Int` to remove the need for using `Option[Instant]`.
  let mut @deadline: Int

  fn static new(kind: Int) -> Result[UnixSocket, Error] {
    let sock = net.raw_socket

    try sys.init_socket(mut sock, libc.AF_UNIX, kind, protocol: 0)
    Result.Ok(UnixSocket(socket: sock, deadline: net.NO_DEADLINE))
  }

  # Returns a new `UnixSocket` configured as a stream socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # UnixSocket.stream
  # ```
  fn pub static stream -> Result[UnixSocket, Error] {
    UnixSocket.new(libc.SOCK_STREAM)
  }

  # Returns a new `UnixSocket` configured as a datagram socket.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # UnixSocket.datagram
  # ```
  fn pub static datagram -> Result[UnixSocket, Error] {
    UnixSocket.new(libc.SOCK_DGRAM)
  }

  # Sets the point in time after which socket operations must time out, known as
  # a "deadline".
  #
  # # Examples
  #
  # Using a `Duration` results in this method calculating the absolute time
  # after which operations time out:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  # import std.time (Duration)
  #
  # let socket = UnixSocket.datagram
  #
  # socket.timeout_after = Duration.from_secs(5)
  # ```
  #
  # We can also use an `Instant`:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  # import std.time (Duration, Instant)
  #
  # let socket = UnixSocket.datagram
  #
  # socket.timeout_after = Instant.new + Duration.from_secs(5)
  # ```
  fn pub mut timeout_after=[T: ToInstant](deadline: ref T) {
    @deadline = deadline.to_instant.to_int
  }

  # Clears the deadline to apply to socket operations.
  fn pub mut reset_deadline {
    @deadline = net.NO_DEADLINE
  }

  # Binds this socket to the specified path or abstract address.
  #
  # # Abstract sockets
  #
  # Linux supports the concept of an "abstract" socket. These are sockets that
  # don't use regular file paths, instead the path starts with a NULL byte and
  # is followed by zero or more additional (and optional) bytes. While this
  # method supports creating such sockets, this isn't portable across platforms
  # (e.g. macOS and FreeBSD don't support it).
  #
  # # Unnamed sockets
  #
  # Linux supports the concept of an "unnamed" socket. These are sockets that
  # don't specify a path to bind to, resulting in the kernel assigning them an
  # address. Such sockets are created by using an empty `Path` as the argument
  # for this method.
  #
  # On non-Linux platforms this isn't supported and providing an empty `Path`
  # will result in an `Error.InvalidArgument` error.
  #
  # # Path sizes
  #
  # Different platforms enforce different limits on the maximum size of `path`.
  # For example, on Linux the path size limit is 108 bytes (including the
  # trailing NULL byte). If the path is too long, this method returns an
  # `Error.InvalidArgument` error.
  #
  # # Examples
  #
  # Binding a Unix socket to a path:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # ```
  fn pub mut bind(path: ref Path) -> Result[Nil, Error] {
    sys.bind_unix(@socket.inner, path)
  }

  # Connects this socket to the specified address.
  #
  # # Examples
  #
  # Connecting a Unix socket:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let listener = UnixSocket.stream.get
  # let stream = UnixSocket.stream.get
  #
  # listener.bind('/tmp/test.sock'.to_path).get
  # listener.listen.get
  #
  # stream.connect('/tmp/test.sock').get
  # ```
  fn pub mut connect(path: ref Path) -> Result[Nil, Error] {
    sys.connect_unix(@socket, path, @deadline)
  }

  # Marks this socket as being ready to accept incoming connections using
  # `accept()`.
  #
  # # Examples
  #
  # Marking a socket as a listener:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.stream.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket.listen.get
  # ```
  fn pub mut listen -> Result[Nil, Error] {
    sys.listen(@socket.inner, MAXIMUM_LISTEN_BACKLOG)
  }

  # Accepts a new incoming connection from this socket.
  #
  # This method will not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a connection and reading data from the connection:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let listener = UnixSocket.stream.get
  # let stream = UnixSocket.stream.get
  #
  # listener.bind('/tmp/test.sock'.to_path).get
  # listener.listen.get
  #
  # stream.connect('/tmp/test.sock').get
  # stream.write_string('ping').get
  #
  # let client = listener.accept.get
  # let buffer = ByteArray.new
  #
  # client.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[UnixSocket, Error] {
    let peer = net.raw_socket

    try sys.accept(@socket, mut peer, @deadline)
    Result.Ok(UnixSocket(socket: peer, deadline: net.NO_DEADLINE))
  }

  # Sends a `String` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket
  #   .send_string_to(string: 'hello', address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    address: ref Path,
  ) -> Result[Int, Error] {
    sys.send_to_unix(@socket, string.pointer, string.size, address, @deadline)
  }

  # Sends a `ByteArray` to the given address.
  #
  # The return value is the number of bytes sent.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  # let bytes = 'hello'.to_byte_array
  #
  # socket.bind('/tmp/test.sock'.to_path).get
  # socket
  #   .send_bytes_to(bytes: bytes, address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    address: ref Path,
  ) -> Result[Int, Error] {
    sys.send_to_unix(@socket, bytes.pointer, bytes.size, address, @deadline)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # The message is read into the given `ByteArray`, and up to `size` bytes will
  # be read.
  #
  # # Examples
  #
  # Sending a message to ourselves and receiving it:
  #
  # ```inko
  # import std.net.socket (UnixSocket)
  #
  # let socket = UnixSocket.datagram.get
  # let bytes = ByteArray.new
  #
  # socket.send_string_to('hello', address: '/tmp/test.sock'.to_path).get
  #
  # let received_from = socket.receive_from(bytes: bytes, size: 5).get
  #
  # bytes.to_string           # => 'hello'
  # received_from.0           # => 5
  # received_from.1.to_string # => '/tmp/test.sock'
  # ```
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, UnixAddress), Error] {
    match sys.receive_from_unix(@socket, bytes, size, @deadline) {
      case Ok((read, path)) -> Result.Ok((read, UnixAddress(path)))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the local address of this socket.
  fn pub local_address -> Result[UnixAddress, Error] {
    match sys.unix_local_address(@socket) {
      case Ok(path) -> Result.Ok(UnixAddress(path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Returns the peer address of this socket.
  fn pub peer_address -> Result[UnixAddress, Error] {
    match sys.unix_peer_address(@socket) {
      case Ok(path) -> Result.Ok(UnixAddress(path))
      case Error(e) -> Result.Error(e)
    }
  }

  # Sets the value of the `SO_RCVBUF` option.
  fn pub mut receive_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_RCVBUF, value.to_int)
  }

  # Sets the value of the `SO_SNDBUF` option.
  fn pub mut send_buffer_size=(value: Int) -> Result[Nil, Error] {
    set_option(libc.SOL_SOCKET, libc.SO_SNDBUF, value.to_int)
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: false)
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    sys.shutdown(@socket, read: false, write: true)
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    sys.shutdown(@socket, read: true, write: true)
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixSocket, Error] {
    let sock = net.raw_socket

    try sys.try_clone(@socket, mut sock)
    Result.Ok(UnixSocket(socket: sock, deadline: net.NO_DEADLINE))
  }

  fn mut set_option(level: Int, option: Int, value: Int) -> Result[Nil, Error] {
    sys.set_int32_option(@socket.inner, level, option, value)
  }
}

impl RawSocketOperations for UnixSocket {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket
  }

  fn raw_deadline -> Int {
    @deadline
  }
}

impl Drop for UnixSocket {
  fn mut drop {
    sys.close(@socket)
  }
}

impl Read for UnixSocket {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    sys.read(@socket, into, size, @deadline)
  }
}

impl WriteInternal for UnixSocket {
  fn mut write_internal(data: Pointer[UInt8], size: Int) -> Result[Int, Error] {
    sys.write(@socket, data, size, @deadline)
  }
}

impl Write for UnixSocket {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    write_all_internal(bytes.pointer, bytes.size)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    write_all_internal(string.pointer, string.size)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A Unix datagram socket.
type pub UnixDatagram {
  # The raw `UnixSocket` wrapped by this `UnixDatagram`.
  let pub @socket: UnixSocket

  # Creates a new Unix datagram socket bound to the given address.
  #
  # # Examples
  #
  # Creating a new Unix datagram socket:
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # UnixDatagram.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixDatagram, Error] {
    let socket = try UnixSocket.datagram

    try socket.bind(address)
    Result.Ok(UnixDatagram(socket))
  }

  # Connects `self` to the remote addres.s
  #
  # Connecting a `UnixDatagram` allows sending and receiving data using the
  # methods from `std.io.Read` and `std.io.Write`, instead of having to use
  # `UnixDatagram.receive_from` and `UnixDatagram.send_to`.
  #
  # # Examples
  #
  # Connecting a Unix datagram socket:
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket1 = UnixDatagram.new('/tmp/test1.sock'.to_path).get
  # let socket2 = UnixDatagram.new('/tmp/test2.sock'.to_path).get
  #
  # socket1.connect('/tmp/test2.sock').get
  # ```
  fn pub mut connect(address: ref Path) -> Result[Nil, Error] {
    @socket.connect(address)
  }

  # Sends a `String` to the given address.
  #
  # See the documentation of `UnixSocket.send_string_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket = UnixDatagram.new('/tmp/test.sock'.to_path).get
  #
  # socket
  #   .send_string_to(string: 'hello', address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_string_to(
    string: String,
    address: ref Path,
  ) -> Result[Int, Error] {
    @socket.send_string_to(string, address)
  }

  # Sends a `ByteArray` to the given address.
  #
  # See the documentation of `UnixSocket.send_bytes_to` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixDatagram)
  #
  # let socket = UnixDatagram.new('/tmp/test.sock'.to_path).get
  # let bytes = 'hello'.to_byte_array
  #
  # socket
  #   .send_bytes_to(bytes: bytes, address: '/tmp/test.sock'.to_path)
  #   .get
  # ```
  fn pub mut send_bytes_to(
    bytes: ref ByteArray,
    address: ref Path,
  ) -> Result[Int, Error] {
    @socket.send_bytes_to(bytes, address)
  }

  # Receives a single datagram message on the socket, returning the size of the
  # message and the address the message was sent from.
  #
  # See the documentation of `UnixSocket.receive_from` for more information.
  fn pub mut receive_from(
    bytes: mut ByteArray,
    size: Int,
  ) -> Result[(Int, UnixAddress), Error] {
    @socket.receive_from(bytes, size)
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixDatagram, Error] {
    @socket.try_clone.map(fn (sock) { UnixDatagram(sock) })
  }
}

impl RawSocketOperations for UnixDatagram {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for UnixDatagram {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UnixDatagram {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A Unix stream socket connected to another Unix socket.
type pub UnixClient {
  # The raw `UnixSocket` wrapped by this `UnixClient`.
  let pub @socket: UnixSocket

  # Creates a new `UnixClient` that is connected to the given address.
  #
  # This method doesn't enforce a deadline on establishing the connection. If
  # you need to limit the amount of time spent waiting to establish the
  # connection, use `UnixClient.with_timeout` instead.
  #
  # # Examples
  #
  # Connecting a `UnixClient`:
  #
  # ```inko
  # import std.net.socket (UnixServer, UnixClient)
  #
  # let listener = UnixServer.new('/tmp/test.sock'.to_path).get
  #
  # UnixClient.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.stream

    try socket.connect(address)
    Result.Ok(UnixClient(socket))
  }

  # Creates a new `UnixClient` but limits the amount of time spent waiting for
  # the connection to be established.
  #
  # The `timeout_after` argument specifies the deadline after which the
  # `connect()` times out. The deadline is cleared once connected.
  #
  # See `UnixClient.new` for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.net.socket (UnixClient)
  # import std.time (Duration)
  #
  # UnixClient
  #   .with_timeout(
  #     address: '/tmp/test.sock'
  #     timeout_after: Duration.from_secs(5)
  #   )
  #   .get
  # ```
  fn pub static with_timeout[T: ToInstant](
    address: ref Path,
    timeout_after: ref T,
  ) -> Result[UnixClient, Error] {
    let socket = try UnixSocket.stream

    socket.timeout_after = timeout_after
    try socket.connect(address)
    socket.reset_deadline
    Result.Ok(UnixClient(socket))
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Returns the peer address of this socket.
  #
  # See the documentation of `UnixSocket.peer_address` for more information.
  fn pub peer_address -> Result[UnixAddress, Error] {
    @socket.peer_address
  }

  # Shuts down the reading half of this socket.
  fn pub mut shutdown_read -> Result[Nil, Error] {
    @socket.shutdown_read
  }

  # Shuts down the writing half of this socket.
  fn pub mut shutdown_write -> Result[Nil, Error] {
    @socket.shutdown_write
  }

  # Shuts down both the reading and writing half of this socket.
  fn pub mut shutdown -> Result[Nil, Error] {
    @socket.shutdown
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixClient, Error] {
    @socket.try_clone.map(fn (sock) { UnixClient(sock) })
  }
}

impl RawSocketOperations for UnixClient {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}

impl Read for UnixClient {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Error] {
    @socket.read(into, size)
  }
}

impl Write for UnixClient {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Nil, Error] {
    @socket.write_bytes(bytes)
  }

  fn pub mut write_string(string: String) -> Result[Nil, Error] {
    @socket.write_string(string)
  }

  fn pub mut flush -> Result[Nil, Error] {
    Result.Ok(nil)
  }
}

# A Unix socket server that can accept incoming connections.
type pub UnixServer {
  # The raw `UnixSocket` wrapped by this `UnixServer`.
  let pub @socket: UnixSocket

  # Creates a new `UnixServer` bound to and listening on the given address.
  #
  # The `backlog` argument can be used to set the listen backlog.
  #
  # # Examples
  #
  # Creating a `UnixServer`:
  #
  # ```inko
  # import std.net.socket (UnixServer)
  #
  # UnixServer.new('/tmp/test.sock'.to_path).get
  # ```
  fn pub static new(address: ref Path) -> Result[UnixServer, Error] {
    let socket = try UnixSocket.stream

    try socket.bind(address)
    try socket.listen
    Result.Ok(UnixServer(socket))
  }

  # Accepts a new incoming connection from `self`.
  #
  # This method does not return until a connection is available.
  #
  # # Examples
  #
  # Accepting a new connection:
  #
  # ```inko
  # import std.net.socket (UnixServer, UnixClient)
  #
  # let listener = UnixServer.new('/tmp/test.sock'.to_path).get
  # let client = UnixClient.new('/tmp/test.sock'.to_path).get
  #
  # client.write_string('ping')
  #
  # let connection = listener.accept.get
  # let buffer = ByteArray.new
  #
  # connection.read(into: buffer, size: 4).get
  #
  # buffer.to_string # => 'ping'
  # ```
  fn pub accept -> Result[UnixClient, Error] {
    @socket.accept.map(fn (sock) { UnixClient(sock) })
  }

  # Returns the local address of this socket.
  #
  # See the documentation of `UnixSocket.local_address` for more information.
  fn pub local_address -> Result[UnixAddress, Error] {
    @socket.local_address
  }

  # Attempts to clone the socket.
  #
  # Cloning a socket may fail, such as when the program has too many open file
  # descriptors.
  fn pub try_clone -> Result[UnixServer, Error] {
    @socket.try_clone.map(fn (sock) { UnixServer(sock) })
  }
}

impl RawSocketOperations for UnixServer {
  fn mut raw_socket -> Pointer[net.RawSocket] {
    @socket.socket
  }

  fn raw_deadline -> Int {
    @socket.deadline
  }
}
