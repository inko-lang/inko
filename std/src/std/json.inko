# Parsing and generating of JSON.
#
# # Parsing JSON
#
# This module provides support for parsing and generating JSON, conforming to
# RFC 8259 (<https://www.rfc-editor.org/rfc/rfc8259>). Tests were performed
# against the test corpus provided by the article
# <https://seriot.ch/projects/parsing_json.html>. Extensions such as parsing
# `NaN`, `Infinity`, and comments are not supported.
#
# The easiest way to parse JSON is using `Json.parse`:
#
# ```inko
# import std.io (buffer)
# import std.json (Json)
#
# Json.parse(Buffer.new('[10]')).get # => Json.Array([Json.Int(10)])
# ```
#
# The parser enforces limits on the number of nested objects and the size of
# strings. These limits can be adjusted by using the `Parser` type directly like
# so:
#
# ```inko
# import std.io (Buffer)
# import std.json (Parser)
#
# let parser = Parser.new(Buffer.new('[10]'))
#
# parser.max_depth = 4
# parser.max_string_size = 128
# parser.parse
# ```
#
# # Generating JSON
#
# Generating JSON strings is done using `Json.to_string` and
# `Json.to_pretty_string`:
#
# ```inko
# import std.json (Json)
#
# Json.Array([Json.Int(1), Json.Int(2)]).to_string # => '[1, 2]'
# ```
#
# When using `to_pretty_string`, the default indentation is two spaces per
# indentation level. You can change this value by using the `Generator` type
# directly:
#
# ```inko
# import std.json (Generator, Json)
#
# let val = Json.Array([Json.Int(1), Json.Int(2)])
# let gen = Generator.new(indent: 4)
#
# gen.generate(val)
# ```
#
# This would then produce the following JSON:
#
# ```inko
# [
#     1,
#     2
# ]
# ```
#
# # Performance
#
# The implementation provided by this module isn't optimised for maximum
# performance or optimal memory usage. Instead this module aims to provide an
# implementation that's good enough for most cases.
import std.bytes.parsers (digit?)
import std.cmp (Equal)
import std.fmt (Format as FormatTrait, Formatter)
import std.int (Format)
import std.io (BufferedReader, Error as IoError, Read)
import std.string (StringBuffer, ToString)
import std.utf8

let BRACKET_OPEN = 0x5B
let BRACKET_CLOSE = 0x5D
let CURLY_OPEN = 0x7B
let CURLY_CLOSE = 0x7D
let DQUOTE = 0x22
let COMMA = 0x2C
let MINUS = 0x2D
let PLUS = 0x2B
let DOT = 0x2E
let COLON = 0x3A
let SLASH = 0x2F
let BSLASH = 0x5C
let SPACE = 0x20
let BS = 0x8
let TAB = 0x9
let LF = 0xA
let CR = 0xD
let FF = 0xC
let ZERO = 0x30
let NINE = 0x39
let LOWER_A = 0x61
let UPPER_A = 0x41
let LOWER_E = 0x65
let UPPER_E = 0x45
let UPPER_F = 0x5a
let LOWER_T = 0x74
let LOWER_F = 0x66
let LOWER_N = 0x6E
let LOWER_B = 0x62
let LOWER_R = 0x72
let LOWER_U = 0x75

# A table mapping bytes that follow a "\", and the types to replace the sequence
# with. A value of `-1` means there's no replacement.
let ESCAPE_TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, DQUOTE, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, SLASH, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, BSLASH,
  -1, -1, -1, -1, -1, BS, -1, -1, -1, FF, -1, -1, -1, -1, -1, -1, -1, LF, -1,
  -1, -1, CR, -1, TAB, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1,
]

# The default amount of spaces to use for indentation when pretty-printing JSON
# objects.
let DEFAULT_PRETTY_INDENT = 2

fn exponent?(byte: Int) -> Bool {
  byte == LOWER_E or byte == UPPER_E
}

fn char(byte: Int) -> String {
  ByteArray.from_array([byte]).into_string
}

# A type describing the different possible errors.
#
# End users don't really care about the difference between
# RecursionLimitExceeded and InvalidSurrogate(...), nor can they really act
# differently based on the kind of error.
type pub inline enum ErrorKind {
  # The maximum recursion limit is exceeded.
  case RecursionLimitExceeded(Int)

  # An invalid UTF-16 surrogate pair is encountered.
  case InvalidSurrogate(String)

  # A generic error with a custom message.
  case Generic(String)

  # An error occurred while reading from the input stream.
  case Read(IoError)
}

impl Equal for ErrorKind {
  fn pub ==(other: ref ErrorKind) -> Bool {
    match (self, other) {
      case (RecursionLimitExceeded(a), RecursionLimitExceeded(b)) -> a == b
      case (InvalidSurrogate(a), InvalidSurrogate(b)) -> a == b
      case (Read(a), Read(b)) -> a == b
      case (Generic(a), Generic(b)) -> a == b
      case _ -> false
    }
  }
}

impl FormatTrait for ErrorKind {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case RecursionLimitExceeded(v) -> {
        formatter.tuple('RecursionLimitExceeded').field(v).finish
      }
      case InvalidSurrogate(v) -> {
        formatter.tuple('InvalidSurrogate').field(v).finish
      }
      case Read(v) -> formatter.tuple('Read').field(v).finish
      case Generic(v) -> formatter.tuple('Generic').field(v).finish
    }
  }
}

impl ToString for ErrorKind {
  fn pub to_string -> String {
    match self {
      case RecursionLimitExceeded(v) -> {
        'the maximum recursion depth of ${v} is exceeded'
      }
      case InvalidSurrogate(v) -> "${v} isn't a valid UTF-16 surrogate pair"
      case Read(v) -> v.to_string
      case Generic(v) -> v.to_string
    }
  }
}

# A type describing an error produced while parsing a JSON document.
type pub inline Error {
  # A value describing the kind of error.
  let pub @kind: ErrorKind

  # The byte offset in the input string at which the error starts.
  #
  # Managing column counts is tricky, as this involves maintaining a grapheme
  # cluster counter, which is complicated and expensive. Instead we report a
  # byte offset (relative to the start of the input), as we need to maintain
  # this anyway.
  #
  # The article at https://www.foonathan.net/2021/02/column/ contains additional
  # information regarding this topic.
  let pub @offset: Int

  # Returns a generic error with the given message and offset.
  fn pub static generic(message: String, offset: Int) -> Error {
    Error(kind: ErrorKind.Generic(message), offset: offset)
  }
}

impl Equal for Error {
  fn pub ==(other: ref Error) -> Bool {
    @kind == other.kind and @offset == other.offset
  }
}

impl FormatTrait for Error {
  fn pub fmt(formatter: mut Formatter) {
    formatter
      .object('Error')
      .field('kind', @kind)
      .field('offset', @offset)
      .finish
  }
}

impl ToString for Error {
  fn pub to_string -> String {
    '${@kind}, at byte offset ${@offset}'
  }
}

# A type used to query/fetch data from a JSON value.
#
# Manually extracting values from JSON objects can be cumbersome. Take the
# following JSON for example:
#
# ```inko
# {
#   "name": "Alice",
#   "address": {
#     "street": "Sesame Street"
#   }
# }
# ```
#
# If we want to get the value of the `street` key, we'd have to write the
# following:
#
# ```inko
# match json {
#   case Object(root) -> match root.get('address') {
#     case Ok(Object(addr)) -> match addr.get('street') {
#       case Ok(String(v)) -> Option.Some(v)
#       case _ -> Option.None
#     }
#     case _ -> Option.None
#   }
#   case _ -> Option.None
# }
# ```
#
# In contrast, using the `Query` type we can instead write the following:
#
# ```inko
# json.query.key('address').key('street').as_string
# ```
#
# Querying is done using the methods `Query.key` to get an object key's value,
# and `Query.index` to get the value of an array index. Methods such as
# `Query.as_string` and `Query.as_int` are used to extract the final value as a
# certain type, if such a value is present.
type pub inline Query {
  let @value: Option[ref Json]

  # Returns a `Query` that matches the value assigned to the object key `name`,
  # if the current value the query matches against is an object.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # let map = Map.new
  #
  # map.set('name', 'Alice')
  # Json.Object(map).query.key('name').as_string # => Option.Some('alice')
  # Json.Int(42).query.key('name').as_string     # => Option.None
  # ```
  fn pub move key(name: String) -> Query {
    let val = match ref @value {
      case Some(Object(v)) -> v.get(name).ok
      case _ -> Option.None
    }

    Query(val)
  }

  # Returns a `Query` that matches the value assigned to the array index
  # `index`, if the current value the query matches against is an array.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Array([Json.Int(10)]).query.index(0).as_int # => Option.Some(10)
  # Json.Int(42).query.index(0).as_int               # => Option.None
  # ```
  fn pub move index(index: Int) -> Query {
    let val = match ref @value {
      case Some(Array(v)) -> v.get(index).ok
      case _ -> Option.None
    }

    Query(val)
  }

  # Returns the value `self` matches against if it's a `Bool`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.String('test').query.as_bool # => Option.None
  # Json.Bool(true).query.as_bool     # => Option.Some(true)
  # ```
  fn pub move as_bool -> Option[Bool] {
    match @value {
      case Some(Bool(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's a `String`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).query.as_string        # => Option.None
  # Json.String('test').query.as_string # => Option.Some('test')
  # ```
  fn pub move as_string -> Option[String] {
    match @value {
      case Some(String(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Int`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.String('test').query.as_int # => Option.None
  # Json.Int(42).query.as_int        # => Option.Some(42)
  # ```
  fn pub move as_int -> Option[Int] {
    match @value {
      case Some(Int(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's a `Float`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.String('test').query.as_float # => Option.None
  # Json.Float(42.0).query.as_float    # => Option.Some(42.0)
  # ```
  fn pub move as_float -> Option[Float] {
    match @value {
      case Some(Float(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Object`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # let map = Map.new
  #
  # map.set('name', 'Alice')
  # Json.Object(map).query.as_object # => Option.Some(...)
  # Json.Int(42).query.as_object     # => Option.None
  # ```
  fn pub move as_object -> Option[ref Map[String, Json]] {
    match @value {
      case Some(Object(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Array`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Array([Json.Int(42)]).query.as_array # => Option.Some(...)
  # Json.Int(42).query.as_array               # => Option.None
  # ```
  fn pub move as_array -> Option[ref Array[Json]] {
    match @value {
      case Some(Array(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }
}

# A JSON value, such as `true` or an array.
type pub inline enum Json {
  case Int(Int)
  case Float(Float)
  case String(String)
  case Array(Array[Json])
  case Object(Map[String, Json])
  case Bool(Bool)
  case Null

  # Parses a `Read` type into a JSON object.
  #
  # # Examples
  #
  # Parsing a `String`:
  #
  # ```inko
  # import std.json (Json)
  # import std.io (Buffer)
  #
  # Json.parse(Buffer.new('[10]')) # => Result.Ok(Json.Array([Json.Int(10)]))
  # ```
  #
  # Parsing a `ByteArray`:
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (Json)
  #
  # Json.parse(Buffer.new('[10]'.to_byte_array)) # => Result.Ok(Json.Array([Json.Int(10)]))
  # ```
  fn pub static parse[T: mut + Read](bytes: T) -> Result[Json, Error] {
    Parser.new(bytes).parse
  }

  # Formats `self` as a JSON string using indentation for nested objects.
  #
  # This method uses two spaces per indentation. To customise the amount of
  # spaces you'll need to use the `Generator` type directly.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).to_pretty_string               # => '42'
  # Json.Array([Json.Int(42)]).to_pretty_string # => "[\n  42\n]"
  # ```
  fn pub to_pretty_string -> String {
    Generator.new(DEFAULT_PRETTY_INDENT).generate(self)
  }

  # Returns a new `Query` that starts at `self`.
  #
  # See the documentation of the `Query` type for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).query.as_int # => Option.Some(42)
  # ```
  fn pub query -> Query {
    Query(Option.Some(self))
  }
}

impl ToString for Json {
  # Formats `self` as a JSON string.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).to_string               # => '42'
  # Json.Array([Json.Int(42)]).to_string # => '[42]'
  # ```
  fn pub to_string -> String {
    Generator.new(0).generate(self)
  }
}

impl FormatTrait for Json {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Int(val) -> formatter.tuple('Int').field(val).finish
      case Float(val) -> formatter.tuple('Float').field(val).finish
      case String(val) -> formatter.tuple('String').field(val).finish
      case Array(val) -> formatter.tuple('Array').field(val).finish
      case Object(val) -> formatter.tuple('Object').field(val).finish
      case Bool(val) -> formatter.tuple('Bool').field(val).finish
      case Null -> formatter.tuple('Null').finish
    }
  }
}

impl Equal for Json {
  fn pub ==(other: ref Json) -> Bool {
    match (self, other) {
      case (Int(a), Int(b)) -> a == b
      case (Float(a), Float(b)) -> a == b
      case (String(a), String(b)) -> a == b
      case (Bool(a), Bool(b)) -> a == b
      case (Array(a), Array(b)) -> a == b
      case (Object(a), Object(b)) -> a == b
      case (Null, Null) -> true
      case _ -> false
    }
  }
}

# A numeric value that's either an `Int` or a `Float`.
type pub copy enum Number {
  case Int(Int)
  case Float(Float)
}

impl Equal for Number {
  fn pub ==(other: ref Number) -> Bool {
    match (self, other) {
      case (Int(a), Int(b)) -> a == b
      case (Float(a), Float(b)) -> a == b
      case _ -> false
    }
  }
}

impl FormatTrait for Number {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Int(v) -> formatter.tuple('Int').field(v).finish
      case Float(v) -> formatter.tuple('Float').field(v).finish
    }
  }
}

# A type describing what kind of value is located at the current position in an
# input stream.
type pub copy enum Type {
  case Array
  case Bool
  case Null
  case Number
  case Object
  case String
}

impl Equal for Type {
  fn pub ==(other: ref Type) -> Bool {
    match (self, other) {
      case (Array, Array) -> true
      case (Bool, Bool) -> true
      case (Null, Null) -> true
      case (Number, Number) -> true
      case (Object, Object) -> true
      case (String, String) -> true
      case _ -> false
    }
  }
}

impl FormatTrait for Type {
  fn pub fmt(formatter: mut Formatter) {
    let name = match self {
      case Array -> 'Array'
      case Bool -> 'Bool'
      case Null -> 'Null'
      case Number -> 'Number'
      case Object -> 'Object'
      case String -> 'String'
    }

    formatter.tuple(name).finish
  }
}

# A pull parser for turning a stream of bytes into JSON values.
#
# Using a `PullParser` you can parse a JSON document into a desired set of
# values, without the need for any intermediate `Json` values. For example,
# parsing an array of integers is done as follows:
#
# ```inko
# import std.io (Buffer)
# import std.json (PullParser)
#
# let parser = PullParser.new(Buffer.new('[10, 20]'))
# let values = []
#
# parser.values(fn { Result.Ok(values.push(try parser.int)) }).get
# values # => [10, 20]
# ```
#
# For objects one _can_ use the low-level method `PullParser.keys`, but it's
# recommended to use `PullParser.object` when the names of the keys are known at
# compile-time. For example:
#
# ```inko
# import std.io (Buffer)
# import std.json (PullParser)
#
# type Person {
#   let @name: String
#   let @age: Int
# }
#
# let parser = PullParser.new(Buffer.new('{ "name": "Alice", "age": 42 }'))
# let person = Person(name: '', age: 0)
#
# parser
#   .object
#   .string('name', fn (v) { person.name = name })
#   .int('age', fn (v) { person.age = v })
#   .parse
#   .get
# ```
type pub PullParser[T: mut + Read] {
  let @input: BufferedReader[T]
  let mut @offset: Int
  let @buffer: ByteArray

  # Returns a new parser that parses the given `Read` type.
  fn pub static new(input: T) -> PullParser[T] {
    PullParser(
      input: BufferedReader.new(input),
      offset: -1,
      buffer: ByteArray.new,
    )
  }

  # Returns the current byte offset in the input stream.
  fn pub offset -> Int {
    @offset
  }

  # Returns the byte offset of the start of the next non-whitespace value.
  #
  # This method is useful when you want to obtain the start of some value and
  # use it when reporting an error when parsing said value, such as when you
  # want to parse a JSON string into a Markdown document.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('  10'))
  #
  # parser.start_of_next_value # => Result.Ok(2)
  # ```
  fn pub mut start_of_next_value -> Result[Int, Error] {
    try skip_whitespace
    Result.Ok(@offset + 1)
  }

  # Returns a `Type` describing what type of value is located at the current
  # offset.
  fn pub mut value_type -> Result[Type, Error] {
    let typ = match try peek {
      case Some(MINUS) -> Type.Number
      case Some(BRACKET_OPEN) -> Type.Array
      case Some(CURLY_OPEN) -> Type.Object
      case Some(LOWER_T or LOWER_F) -> Type.Bool
      case Some(LOWER_N) -> Type.Null
      case Some(DQUOTE) -> Type.String
      case Some(byte) if digit?(byte) -> Type.Number
      # This is to take care of any random garbage that may be included in the
      # JSON document, including Unicode BOMs. This also saves us from having to
      # explicitly check for all the different BOMs.
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    Result.Ok(typ)
  }

  # Recursively parses but ignores the current value.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('[10, 20]')).skip # => Result.Ok(nil)
  # ```
  fn pub mut skip -> Result[Nil, Error] {
    match value_type {
      case Ok(Number) -> {
        try number
        nil
      }
      case Ok(Array) -> try values(fn { skip })
      case Ok(Object) -> try keys(fn (_pos, _key) { skip })
      case Ok(String) -> try string
      case Ok(Null) -> try null
      case Ok(Bool) -> try bool
      case Error(e) -> throw e
    }

    Result.Ok(nil)
  }

  # Parses an array, calling the `value` closure for every value in the array.
  #
  # It's expected that the `value` closure advances the parser by parsing the
  # value in it's desired format.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('[10, 20]'))
  # let values = []
  #
  # parser
  #   .values(fn {
  #     values.push(parser.int.get)
  #     Result.Ok(nil)
  #   })
  #   .get
  #
  # values # => [10, 20]
  # ```
  fn pub mut values(value: fn -> Result[Nil, Error]) -> Result[Nil, Error] {
    try expect(BRACKET_OPEN, skip_whitespace: true)

    loop {
      match try peek {
        case Some(BRACKET_CLOSE) -> {
          try advance
          break
        }
        case Some(_) -> {
          try value.call
          try separator(BRACKET_CLOSE)
        }
        case _ -> throw missing_input
      }
    }

    Result.Ok(nil)
  }

  # Parses an object, calling `value` for each key and passing it the position
  # and name of the key.
  #
  # It's expected that the `value` closure advances the parser by parsing the
  # value in it's desired format.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # type Person {
  #   let @name: String
  #   let @age: Int
  # }
  #
  # let parser = PullParser.new(Buffer.new('{ "name": "Alice", "age": 42 }'))
  # let person = Person(name: '', age: 0)
  #
  # parser
  #   .keys(fn (pos, key) {
  #     match key {
  #       case 'name' -> person.name = parser.string.get
  #       case 'age' -> person.age = parser.int.get
  #       case _ -> {}
  #     }
  #
  #     Result.Ok(nil)
  #   })
  #   .get
  #
  # person.name # => 'Alice'
  # person.age  # => 42
  # ```
  fn pub mut keys(
    value: fn (Int, String) -> Result[Nil, Error],
  ) -> Result[Nil, Error] {
    try expect(CURLY_OPEN, skip_whitespace: true)

    loop {
      match try peek {
        case Some(CURLY_CLOSE) -> {
          let _ = advance

          break
        }
        case Some(DQUOTE) -> {
          let pos = @offset + 1
          let key = try string

          try expect(COLON, skip_whitespace: true)
          try value.call(pos, key)
          try separator(CURLY_CLOSE)
        }
        case Some(byte) -> throw unexpected(byte)
        case _ -> throw missing_input
      }
    }

    Result.Ok(nil)
  }

  # Creates a new `ObjectParser` and passes it to the provided closure, which is
  # used to define the parsing rules. Upon returning from the closure, the
  # `ObjectParser` is used to parse the data at the current byte offset.
  #
  # For more information, refer to the documentation of the `ObjectParser` type.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # type Person {
  #   let @name: String
  # }
  #
  # let parser = PullParser.new(Buffer.new('{ "name": "String" }'))
  # let person = Person(name: '')
  #
  # parser
  #   .object(fn (o) { o.string('name', fn (v) { person.name = v }) })
  #   .or_panic_with('failed to parse the JSON')
  # ```
  fn pub mut object(rules: fn (mut ObjectParser[T])) -> Result[Nil, Error] {
    let obj = ObjectParser.new

    rules.call(obj)
    obj.parse(self)
  }

  # Parses the boolean value `true` or `false`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('true')).bool # => Result.Ok(true)
  # ```
  fn pub mut bool -> Result[Bool, Error] {
    match try peek {
      case Some(LOWER_T) -> {
        let _ = advance

        identifier('rue').map(fn (_) { true })
      }
      case Some(LOWER_F) -> {
        let _ = advance

        identifier('alse').map(fn (_) { false })
      }
      case Some(v) -> throw unexpected(v)
      case _ -> throw missing_input
    }
  }

  # Parses a `null` value.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('null')).null # => Result.Ok(nil)
  # ```
  fn pub mut null -> Result[Nil, Error] {
    identifier('null')
  }

  # Parses a string.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('"hello"')).string # => Result.Ok('hello')
  # ```
  fn pub mut string -> Result[String, Error] {
    match try peek {
      case Some(DQUOTE) -> try advance
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    loop {
      match try advance {
        case Some(BSLASH) -> {
          match try advance {
            case Some(LOWER_U) -> try escaped_unicode
            case Some(byte) -> {
              match ESCAPE_TABLE.get(byte).or_panic {
                case -1 -> throw unexpected(byte)
                case val -> @buffer.push(val)
              }
            }
            case _ -> throw missing_input
          }
        }
        case Some(DQUOTE) -> break
        case Some(val) if val >= 0x0 and val <= 0x001F -> {
          throw generic_error(
            'control characters in the range 0x0..0x001F must be escaped',
          )
        }
        case Some(byte) -> @buffer.push(byte)
        case _ -> throw missing_input
      }
    }

    Result.Ok(@buffer.drain_to_string)
  }

  fn mut escaped_unicode -> Result[Nil, Error] {
    let high = try codepoint

    if utf8.encode_scalar(high, @buffer) > 0 { return Result.Ok(nil) }

    # At this point the codepoint is either straight up invalid (e.g. "\uZZZZ"),
    # or it's a UTF-16 surrogate.
    if utf8.surrogate?(high).false? {
      throw error(ErrorKind.InvalidSurrogate(high.format(Format.Hex)))
    }

    try expect(BSLASH, skip_whitespace: false)
    try expect(LOWER_U, skip_whitespace: false)

    let low = try codepoint

    if utf8.surrogate?(low) {
      let codepoint = utf8.codepoint_from_surrogates(high, low)

      # The encoding may fail for pairs such as "\uDFFF\uDFFF".
      if utf8.encode_scalar(codepoint, @buffer) > 0 { return Result.Ok(nil) }
    }

    let pair = '\\u${high.format(Format.Hex)}\\u${low.format(Format.Hex)}'

    throw error(ErrorKind.InvalidSurrogate(pair))
  }

  fn mut codepoint -> Result[Int, Error] {
    let mut num = 0
    let mut idx = 0

    while idx < 4 {
      let digit = match try advance {
        case Some(byte) -> {
          if byte >= ZERO and byte <= NINE {
            byte - ZERO
          } else if byte >= LOWER_A and byte <= LOWER_F {
            byte - LOWER_A + 10
          } else if byte >= UPPER_A and byte <= UPPER_F {
            byte - UPPER_A + 10
          } else {
            throw unexpected(byte)
          }
        }
        case _ -> throw missing_input
      }

      num = num * 16 + digit
      idx += 1
    }

    Result.Ok(num)
  }

  # Parses a number as an `Int`.
  #
  # If the value in the input stream is in fact a float (e.g. `1.2` instead of
  # just `1`), it's first pased as a `Float` and then cast to an `Int`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # Parser.new(Buffer.new('10')).int  # => Result.Ok(10)
  # Parser.new(Buffer.new('1.2')).int # => Result.Ok(1)
  # ```
  fn pub mut int -> Result[Int, Error] {
    match number {
      case Ok(Int(v)) -> Result.Ok(v)
      case Ok(Float(v)) -> Result.Ok(v.to_int)
      case Error(e) -> Result.Error(e)
    }
  }

  # Parses a number as a `Float`.
  #
  # If the value in the input stream is in fact an integer (e.g. `1` instead of
  # `1.0` or `1.2`), the value is first parsed as an `Int` and then cast to a
  # `Float`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # Parser.new(Buffer.new('1.2')).float # => Result.Ok(1.2)
  # Parser.new(Buffer.new('1')).float   # => Result.Ok(1.0)
  # ```
  fn pub mut float -> Result[Float, Error] {
    match number {
      case Ok(Int(v)) -> Result.Ok(v.to_float)
      case Ok(Float(v)) -> Result.Ok(v)
      case Error(e) -> Result.Error(e)
    }
  }

  # Parses a number into a `Number` value.
  #
  # A `Number` is a wrapper enum around either a `Float` or an `Int`. If you
  # only care about numbers in a particular format (e.g. integers), use
  # `PullParser.int` or `PullParser.float` instead.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # Parser.new(Buffer.new('1.2')).number # => Result.Ok(Number.Float(1.2))
  # Parser.new(Buffer.new('1')).number   # => Result.Ok(Number.Int(1))
  # ```
  fn pub mut number -> Result[Number, Error] {
    match try peek {
      case Some(MINUS) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> {}
          case Some(byte) -> throw unexpected(byte)
          case _ -> throw missing_input
        }
      }
      case Some(byte) if digit?(byte) -> {}
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    # Numbers such as 001, 010, 01.0, etc are invalid.
    match try peek_next {
      case Some(ZERO) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> throw unexpected(byte)
          case _ -> {}
        }
      }
      case _ -> {}
    }

    try buffer_digits

    match try peek_next {
      # Examples: 1.2, 1.2e1, 1.2e+1
      case Some(DOT) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> {}
          case Some(byte) -> throw unexpected(byte)
          case _ -> throw missing_input
        }

        try buffer_digits

        match try peek_next {
          case Some(byte) if exponent?(byte) -> try exponent
          case _ -> {}
        }
      }
      # Example: 1E4
      case Some(byte) if exponent?(byte) -> try exponent
      # Example: 123
      #
      # If the number is too big to fit in an Int, we'll promote it to a Float.
      case _ -> {
        match Int.parse(@buffer, Format.Decimal) {
          case Some(val) -> {
            @buffer.clear
            return Result.Ok(Number.Int(val))
          }
          case _ -> {}
        }
      }
    }

    # At this point we've already validated the input format, and it's
    # compatible with the underlying float parser, so no extra checks are
    # needed.
    let res = Result.Ok(Number.Float(Float.parse(@buffer).get))

    @buffer.clear
    res
  }

  fn mut exponent -> Result[Nil, Error] {
    try advance_and_buffer

    match try peek_next {
      case Some(MINUS or PLUS) -> {
        try advance_and_buffer
        nil
      }
      case _ -> {}
    }

    match try peek_next {
      case Some(byte) if digit?(byte) -> {}
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    try buffer_digits
    Result.Ok(nil)
  }

  fn mut buffer_digits -> Result[Nil, Error] {
    loop {
      match try peek_next {
        case Some(byte) if digit?(byte) -> {
          try advance
          @buffer.push(byte)
        }
        case _ -> return Result.Ok(nil)
      }
    }
  }

  fn mut advance_and_buffer -> Result[Option[Int], Error] {
    match try advance {
      case Some(val) -> {
        @buffer.push(val)
        Result.Ok(Option.Some(val))
      }
      case _ -> Result.Ok(Option.None)
    }
  }

  fn mut advance -> Result[Option[Int], Error] {
    match @input.read_byte {
      case Ok(Some(v)) -> {
        @offset += 1
        Result.Ok(Option.Some(v))
      }
      case Ok(None) -> Result.Ok(Option.None)
      case Error(e) -> Result.Error(error(ErrorKind.Read(e)))
    }
  }

  fn mut expect(byte: Int, skip_whitespace: Bool) -> Result[Nil, Error] {
    if skip_whitespace { try self.skip_whitespace }

    match try advance {
      case Some(val) if val == byte -> Result.Ok(nil)
      case Some(val) -> {
        let exp = char(byte)
        let got = char(val)

        throw generic_error(
          "the character '${exp}' is expected but '${got}' was found instead",
        )
      }
      case _ -> throw missing_input
    }
  }

  fn mut peek_next -> Result[Option[Int], Error] {
    match @input.peek {
      case Ok(Some(v)) -> Result.Ok(Option.Some(v))
      case Ok(None) -> Result.Ok(Option.None)
      case Error(e) -> Result.Error(error(ErrorKind.Read(e)))
    }
  }

  fn mut peek -> Result[Option[Int], Error] {
    loop {
      match peek_next {
        case Ok(Some(SPACE or CR or TAB or LF)) -> advance
        case Ok(Some(byte)) -> return Result.Ok(Option.Some(byte))
        case Ok(None) -> return Result.Ok(Option.None)
        case Error(e) -> throw e
      }
    }
  }

  fn mut identifier(name: String) -> Result[Nil, Error] {
    try skip_whitespace

    let mut index = 0
    let max = name.size

    while index < max {
      try expect(name.get(index := index + 1).or_panic, skip_whitespace: false)
    }

    Result.Ok(nil)
  }

  fn mut skip_whitespace -> Result[Nil, Error] {
    loop {
      match try peek_next {
        case Some(SPACE or CR or TAB or LF) -> try advance
        case _ -> return Result.Ok(nil)
      }
    }
  }

  fn mut separator(closing: Int) -> Result[Nil, Error] {
    match try peek {
      case Some(byte) if byte == closing -> return Result.Ok(nil)
      case Some(COMMA) -> try advance
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw missing_input
    }

    match try peek {
      case Some(byte) if byte == closing -> throw unexpected(byte)
      case _ -> Result.Ok(nil)
    }
  }

  fn unexpected(byte: Int) -> Error {
    generic_error("the character '${char(byte)}' is unexpected")
  }

  fn missing_input -> Error {
    generic_error('all input is consumed but more input is expected')
  }

  fn generic_error(message: String) -> Error {
    Error.generic(message, @offset)
  }

  fn error(kind: ErrorKind) -> Error {
    Error(kind, offset: @offset)
  }
}

# A parsing rule defined for an `ObjectParser`.
type pub Rule[T: mut + Read] {
  let @id: Int
  let @parser: fn (mut PullParser[T]) -> Result[Nil, Error]
  let mut @required: Bool

  # Marks this rule as an optional rule.
  fn pub mut optional {
    @required = false
  }
}

# A type for parsing an object with a known set of keys.
#
# # Required vs optional keys
#
# By default all keys defined using this type are required. A key can be made
# optional using `Rule.optional`. For example:
#
# ```inko
# import std.io (Buffer)
# import std.json (ObjectParser, PullParser)
#
# let parser = PullParser.new(Buffer.new('{ "a": 10 }'))
# let obj = ObjectParser.new
# let nums = []
#
# obj.int('a', fn (v) { nums.push(v) })
# obj.int('b', fn (v) { nums.push(v) }).optional
# obj.parse(parser).or_panic_with('failed to parse the JSON')
# ```
type pub inline ObjectParser[T: mut + Read] {
  # The keys to parse along with the closures that parse their values.
  let @rules: Map[String, Rule[T]]

  # Returns a new, empty `ObjectParser`.
  fn static new -> ObjectParser[T] {
    ObjectParser(Map.new)
  }

  # Parses the key `name` as a custom value.
  #
  # It's expected that the `value` closure parses the value, advancing the
  # parser in the process.
  fn pub mut key(
    name: String,
    value: fn (mut PullParser[T]) -> Result[Nil, Error],
  ) -> mut Rule[T] {
    add(name, value)
  }

  # Parses the key `name` as a `String`, passing the parsed value to the `value`
  # closure.
  fn pub mut string(name: String, value: fn (String)) -> mut Rule[T] {
    add(name, fn move (p) { p.string.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as an `Int`, passing the parsed value to the `value`
  # closure.
  fn pub mut int(name: String, value: fn (Int)) -> mut Rule[T] {
    add(name, fn move (p) { p.int.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as a `Float`, passing the parsed value to the `value`
  # closure.
  fn pub mut float(name: String, value: fn (Float)) -> mut Rule[T] {
    add(name, fn move (p) { p.float.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as a `Bool`, passing the parsed value to the `value`
  # closure.
  fn pub mut bool(name: String, value: fn (Bool)) -> mut Rule[T] {
    add(name, fn move (p) { p.bool.map(fn (v) { value.call(v) }) })
  }

  # Parses the key `name` as an object without a known structure, passing each
  # key to the `value` closure.
  #
  # For more information, refer to the documentation of `PullParser.keys`.
  fn pub mut keys(
    name: String,
    value: fn (mut PullParser[T], Int, String) -> Result[Nil, Error],
  ) -> mut Rule[T] {
    add(name, fn move (p) { p.keys(fn (pos, key) { value.call(p, pos, key) }) })
  }

  # Parses the key `name` as an array of arbitrary values, using the `value`
  # closure to parse the values and advance the parser.
  #
  # For more information, refer to the documentation of `PullParser.values`.
  fn pub mut values(
    name: String,
    value: fn (mut PullParser[T]) -> Result[Nil, Error],
  ) -> mut Rule[T] {
    add(name, fn move (p) { p.values(fn { value.call(p) }) })
  }

  # Parses the current object according to the rules in `self`.
  fn pub mut parse(parser: mut PullParser[T]) -> Result[Nil, Error] {
    let found = Array.filled(with: false, times: @rules.size)
    let start = try parser.start_of_next_value

    try parser.keys(fn (_pos, key) {
      match @rules.get_mut(key) {
        case Ok(rule) -> {
          found.set(rule.id, true)
          rule.parser.call(parser)
        }
        case _ -> parser.skip
      }
    })

    for entry in @rules.iter {
      if
        entry.value.required.true? and found.get(entry.value.id).or_panic.false?
      {
        throw Error.generic('the key "${entry.key}" is required', start)
      }
    }

    Result.Ok(nil)
  }

  fn mut add(
    name: String,
    parser: fn (mut PullParser[T]) -> Result[Nil, Error],
  ) -> mut Rule[T] {
    let rule = Rule(id: @rules.size, parser: parser, required: true)
    let ret = mut rule

    @rules.set(name, rule)
    ret
  }
}

# A DOM parser for turning a stream of bytes into a JSON document.
#
# This parser only supports parsing `ByteArray` values as input. If you need to
# parse very large documents, it's best to separate the objects on a per line
# basis, then parse the document one line at a time.
#
# # Nested arrays and objects
#
# This parser enforces a limit on the number of nested arrays and objects. The
# default is sufficiently large that most documents won't result in an error
# being thrown. This limit is controlled by the field `Parser.max_depth`.
type pub Parser[T: mut + Read] {
  let @pull: PullParser[T]
  let mut @depth: Int

  # The maximum number of nested values.
  #
  # When parsing an array or object that exceeds this depth, an error is thrown.
  let pub mut @max_depth: Int

  # Returns a new parser that will parse the given `Read` type.
  fn pub static new(input: T) -> Parser[T] {
    Parser(PullParser.new(input), depth: 0, max_depth: 100)
  }

  # Parses the input into a JSON object.
  #
  # If the input is invalid JSON, this method throws an `Error`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (Parser)
  #
  # let parser = Parser.new(Buffer.new('[10, 20]'))
  #
  # parser.parse.get # => Json.Array([Json.Int(10), Json.Int(20)])
  # ```
  fn pub move parse -> Result[Json, Error] {
    let result = try value

    # Only trailing whitespace is allowed.
    match try @pull.peek {
      case Some(val) -> throw @pull.unexpected(val)
      case _ -> {}
    }

    Result.Ok(result)
  }

  fn mut value -> Result[Json, Error] {
    match try @pull.value_type {
      case Number -> number
      case Array -> array
      case Object -> object
      case Bool -> bool
      case Null -> null
      case String -> string
    }
  }

  fn mut string -> Result[Json, Error] {
    @pull.string.map(fn (val) { Json.String(val) })
  }

  fn mut bool -> Result[Json, Error] {
    @pull.bool.map(fn (v) { Json.Bool(v) })
  }

  fn mut null -> Result[Json, Error] {
    @pull.null.map(fn (_) { Json.Null })
  }

  fn mut array -> Result[Json, Error] {
    try check_depth

    let values = []

    @depth += 1
    try @pull.values(fn { Result.Ok(values.push(try value)) })
    @depth -= 1
    Result.Ok(Json.Array(values))
  }

  fn mut object -> Result[Json, Error] {
    try check_depth

    let map = Map.new

    @depth += 1
    try @pull.keys(fn (_pos, k) {
      map.set(k, try value)
      Result.Ok(nil)
    })
    @depth -= 1
    Result.Ok(Json.Object(map))
  }

  fn mut number -> Result[Json, Error] {
    match @pull.number {
      case Ok(Int(v)) -> Result.Ok(Json.Int(v))
      case Ok(Float(v)) -> Result.Ok(Json.Float(v))
      case Error(e) -> Result.Error(e)
    }
  }

  fn check_depth -> Result[Nil, Error] {
    if @depth < @max_depth {
      Result.Ok(nil)
    } else {
      Result.Error(@pull.error(ErrorKind.RecursionLimitExceeded(@max_depth)))
    }
  }
}

# A type for turning a `Json` value into a JSON string.
#
# This type is used by `Json.to_string` and `Json.to_pretty_string`. Unless you
# want to use custom indentation, it's recommended to use these methods instead
# of using `Generator` directly.
type pub Generator {
  let @pretty: Bool
  let @spaces: String
  let mut @depth: Int
  let @buffer: StringBuffer

  # Returns a new `Generator` using the given indentation level.
  #
  # The `indent` argument specifies the number of spaces to use per indentation
  # level. If this value is less than or equal to zero, no indentation is
  # applied.
  fn pub static new(indent: Int) -> Generator {
    Generator(
      pretty: indent > 0,
      spaces: ' '.repeat(indent),
      depth: 0,
      buffer: StringBuffer.new,
    )
  }

  # Generates a JSON string for the given `Json` value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Generator)
  #
  # Generator.new(indent: 2).generate(Json.Array([Json.Int(1)])) # => '[1]'
  # ```
  fn pub mut generate(value: ref Json) -> String {
    generate_value(value)
    @buffer.to_string
  }

  fn mut generate_value(value: ref Json) {
    match value {
      case Int(val) -> @buffer.push(val.to_string)
      case Float(val) -> @buffer.push(val.to_string)
      case String(val) -> {
        @buffer.push('"')
        @buffer.push(val.escaped)
        @buffer.push('"')
      }
      case Array(vals) -> {
        @buffer.push('[')

        if vals.size > 0 {
          enter(fn {
            for (index, val) in vals.iter.with_index {
              if index > 0 { separator }

              indent
              generate_value(val)
            }
          })
        }

        indent
        @buffer.push(']')
      }
      case Object(vals) -> {
        @buffer.push('{')

        if vals.size > 0 {
          enter(fn {
            for (index, pair) in vals.iter.with_index {
              if index > 0 { separator }

              indent
              @buffer.push('"')
              @buffer.push(pair.key.escaped)
              @buffer.push('": ')
              generate_value(pair.value)
            }
          })
        }

        indent
        @buffer.push('}')
      }
      case Bool(val) -> @buffer.push(val.to_string)
      case Null -> @buffer.push('null')
    }
  }

  fn mut enter(block: fn) {
    newline
    @depth += 1
    block.call
    @depth -= 1
    newline
  }

  fn mut indent {
    if @pretty { @depth.times(fn (_) { @buffer.push(@spaces) }) }
  }

  fn mut newline {
    if @pretty { @buffer.push('\n') }
  }

  fn mut separator {
    @buffer.push(if @pretty { ',\n' } else { ', ' })
  }
}
