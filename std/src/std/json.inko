# Parsing and generating of JSON.
#
# # Parsing JSON
#
# This module provides support for parsing and generating JSON, conforming to
# RFC 8259 (<https://www.rfc-editor.org/rfc/rfc8259>). Tests were performed
# against the test corpus provided by the article
# <https://seriot.ch/projects/parsing_json.html>. Extensions such as parsing
# `NaN`, `Infinity`, and comments are not supported.
#
# The easiest way to parse JSON is using `Json.parse`:
#
# ```inko
# import std.io (buffer)
# import std.json (Json)
#
# Json.parse(Buffer.new('[10]')).get # => Json.Array([Json.Int(10)])
# ```
#
# The parser enforces limits on the number of nested objects and the size of
# strings. These limits can be adjusted by using the `Parser` type directly like
# so:
#
# ```inko
# import std.io (Buffer)
# import std.json (Parser)
#
# let parser = Parser.new(Buffer.new('[10]'))
#
# parser.max_depth = 4
# parser.max_string_size = 128
# parser.parse
# ```
#
# # Generating JSON
#
# Generating JSON strings is done using `Json.to_string` and
# `Json.to_pretty_string`:
#
# ```inko
# import std.json (Json)
#
# Json.Array([Json.Int(1), Json.Int(2)]).to_string # => '[1, 2]'
# ```
#
# When using `to_pretty_string`, the default indentation is two spaces per
# indentation level. You can change this value by using the `Generator` type
# directly:
#
# ```inko
# import std.json (Generator, Json)
#
# let val = Json.Array([Json.Int(1), Json.Int(2)])
# let gen = Generator.new(indent: 4)
#
# gen.generate(val)
# ```
#
# This would then produce the following JSON:
#
# ```inko
# [
#     1,
#     2
# ]
# ```
#
# # Performance
#
# The implementation provided by this module isn't optimised for maximum
# performance or optimal memory usage. Instead this module aims to provide an
# implementation that's good enough for most cases.
import std.bytes.parsers (digit?)
import std.cmp (Equal)
import std.fmt (Format as FormatTrait, Formatter)
import std.int (Format)
import std.io (BufferedReader, Read)
import std.string (IntoString, StringBuffer, ToString)
import std.utf8

let BRACKET_OPEN = 0x5B
let BRACKET_CLOSE = 0x5D
let CURLY_OPEN = 0x7B
let CURLY_CLOSE = 0x7D
let DQUOTE = 0x22
let COMMA = 0x2C
let MINUS = 0x2D
let PLUS = 0x2B
let DOT = 0x2E
let COLON = 0x3A
let SLASH = 0x2F
let BSLASH = 0x5C
let SPACE = 0x20
let BS = 0x8
let TAB = 0x9
let LF = 0xA
let CR = 0xD
let FF = 0xC
let ZERO = 0x30
let NINE = 0x39
let LOWER_A = 0x61
let UPPER_A = 0x41
let LOWER_E = 0x65
let UPPER_E = 0x45
let UPPER_F = 0x5a
let LOWER_T = 0x74
let LOWER_F = 0x66
let LOWER_N = 0x6E
let LOWER_B = 0x62
let LOWER_R = 0x72
let LOWER_U = 0x75

# A table mapping bytes that follow a "\", and the types to replace the sequence
# with. A value of `-1` means there's no replacement.
let ESCAPE_TABLE = [
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, DQUOTE, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, SLASH, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, BSLASH,
  -1, -1, -1, -1, -1, BS, -1, -1, -1, FF, -1, -1, -1, -1, -1, -1, -1, LF, -1,
  -1, -1, CR, -1, TAB, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
  -1, -1,
]

# The default amount of spaces to use for indentation when pretty-printing JSON
# objects.
let DEFAULT_PRETTY_INDENT = 2

fn exponent?(byte: Int) -> Bool {
  byte == LOWER_E or byte == UPPER_E
}

fn char(byte: Int) -> String {
  ByteArray.from_array([byte]).into_string
}

# A type describing the different possible errors.
type pub inline enum ErrorKind[E] {
  # The maximum recursion limit is exceeded.
  case RecursionLimitExceeded(Int)

  # An invalid UTF-16 surrogate pair is encountered.
  case InvalidSurrogate

  # An invalid control character is encountered.
  case InvalidControl

  # More input is required.
  case EndOfInput

  # An invalid character is found.
  case Unexpected(String)

  # An error occurred while reading from the input stream.
  case Read(E)
}

impl Equal for ErrorKind if E: Equal {
  fn pub ==(other: ref ErrorKind[E]) -> Bool {
    match (self, other) {
      case (RecursionLimitExceeded(a), RecursionLimitExceeded(b)) -> a == b
      case (InvalidSurrogate, InvalidSurrogate) -> true
      case (Unexpected(a), Unexpected(b)) -> a == b
      case (Read(a), Read(b)) -> a == b
      case (EndOfInput, EndOfInput) -> true
      case (InvalidControl, InvalidControl) -> true
      case _ -> false
    }
  }
}

impl FormatTrait for ErrorKind if E: FormatTrait {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case RecursionLimitExceeded(v) -> {
        formatter.tuple('RecursionLimitExceeded').field(v).finish
      }
      case InvalidSurrogate -> formatter.tuple('InvalidSurrogate').finish
      case Unexpected(v) -> formatter.tuple('Unexpected').field(v).finish
      case Read(v) -> formatter.tuple('Read').field(v).finish
      case EndOfInput -> formatter.tuple('EndOfInput').finish
      case InvalidControl -> formatter.tuple('InvalidControl').finish
    }
  }
}

impl ToString for ErrorKind if E: ToString {
  fn pub to_string -> String {
    match self {
      case RecursionLimitExceeded(v) -> {
        'the maximum recursion depth of ${v} is exceeded'
      }
      case InvalidSurrogate -> 'the UTF-16 surrogate pair is invalid'
      case Unexpected(v) -> "the character '${v}' is unexpected"
      case Read(v) -> v.to_string
      case EndOfInput -> {
        'the end of the input stream is reached, but more input is required'
      }
      case InvalidControl -> {
        'control characters in the range 0x0..0x001F must be escaped'
      }
    }
  }
}

# A type describing an error produced while parsing a JSON document.
type pub inline Error[E] {
  # A value describing the kind of error.
  let pub @kind: ErrorKind[E]

  # The byte offset in the input string at which the error starts.
  #
  # Managing column counts is tricky, as this involves maintaining a grapheme
  # cluster counter, which is complicated and expensive. Instead we report a
  # byte offset (relative to the start of the input), as we need to maintain
  # this anyway.
  #
  # The article at https://www.foonathan.net/2021/02/column/ contains additional
  # information regarding this topic.
  let pub @offset: Int
}

impl Equal for Error if E: Equal {
  fn pub ==(other: ref Error[E]) -> Bool {
    @kind == other.kind and @offset == other.offset
  }
}

impl FormatTrait for Error if E: FormatTrait {
  fn pub fmt(formatter: mut Formatter) {
    formatter
      .object('Error')
      .field('kind', @kind)
      .field('offset', @offset)
      .finish
  }
}

impl ToString for Error if E: ToString {
  fn pub to_string -> String {
    '${@kind}, at byte offset ${@offset}'
  }
}

# A type used to query/fetch data from a JSON value.
#
# Manually extracting values from JSON objects can be cumbersome. Take the
# following JSON for example:
#
# ```inko
# {
#   "name": "Alice",
#   "address": {
#     "street": "Sesame Street"
#   }
# }
# ```
#
# If we want to get the value of the `street` key, we'd have to write the
# following:
#
# ```inko
# match json {
#   case Object(root) -> match root.get('address') {
#     case Ok(Object(addr)) -> match addr.get('street') {
#       case Ok(String(v)) -> Option.Some(v)
#       case _ -> Option.None
#     }
#     case _ -> Option.None
#   }
#   case _ -> Option.None
# }
# ```
#
# In contrast, using the `Query` type we can instead write the following:
#
# ```inko
# json.query.key('address').key('street').as_string
# ```
#
# Querying is done using the methods `Query.key` to get an object key's value,
# and `Query.index` to get the value of an array index. Methods such as
# `Query.as_string` and `Query.as_int` are used to extract the final value as a
# certain type, if such a value is present.
type pub inline Query {
  let @value: Option[ref Json]

  # Returns a `Query` that matches the value assigned to the object key `name`,
  # if the current value the query matches against is an object.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # let map = Map.new
  #
  # map.set('name', 'Alice')
  # Json.Object(map).query.key('name').as_string # => Option.Some('alice')
  # Json.Int(42).query.key('name').as_string     # => Option.None
  # ```
  fn pub move key(name: String) -> Query {
    let val = match ref @value {
      case Some(Object(v)) -> v.get(name).ok
      case _ -> Option.None
    }

    Query(val)
  }

  # Returns a `Query` that matches the value assigned to the array index
  # `index`, if the current value the query matches against is an array.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Array([Json.Int(10)]).query.index(0).as_int # => Option.Some(10)
  # Json.Int(42).query.index(0).as_int               # => Option.None
  # ```
  fn pub move index(index: Int) -> Query {
    let val = match ref @value {
      case Some(Array(v)) -> v.get(index).ok
      case _ -> Option.None
    }

    Query(val)
  }

  # Returns the value `self` matches against if it's a `Bool`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.String('test').query.as_bool # => Option.None
  # Json.Bool(true).query.as_bool     # => Option.Some(true)
  # ```
  fn pub move as_bool -> Option[Bool] {
    match @value {
      case Some(Bool(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's a `String`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).query.as_string        # => Option.None
  # Json.String('test').query.as_string # => Option.Some('test')
  # ```
  fn pub move as_string -> Option[String] {
    match @value {
      case Some(String(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Int`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.String('test').query.as_int # => Option.None
  # Json.Int(42).query.as_int        # => Option.Some(42)
  # ```
  fn pub move as_int -> Option[Int] {
    match @value {
      case Some(Int(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's a `Float`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.String('test').query.as_float # => Option.None
  # Json.Float(42.0).query.as_float    # => Option.Some(42.0)
  # ```
  fn pub move as_float -> Option[Float] {
    match @value {
      case Some(Float(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Object`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # let map = Map.new
  #
  # map.set('name', 'Alice')
  # Json.Object(map).query.as_object # => Option.Some(...)
  # Json.Int(42).query.as_object     # => Option.None
  # ```
  fn pub move as_object -> Option[ref Map[String, Json]] {
    match @value {
      case Some(Object(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }

  # Returns the value `self` matches against if it's an `Array`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Array([Json.Int(42)]).query.as_array # => Option.Some(...)
  # Json.Int(42).query.as_array               # => Option.None
  # ```
  fn pub move as_array -> Option[ref Array[Json]] {
    match @value {
      case Some(Array(v)) -> Option.Some(v)
      case _ -> Option.None
    }
  }
}

# A JSON value, such as `true` or an array.
type pub inline enum Json {
  case Int(Int)
  case Float(Float)
  case String(String)
  case Array(Array[Json])
  case Object(Map[String, Json])
  case Bool(Bool)
  case Null

  # Returns an `ObjectBuilder` for building a JSON object.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.object.string('name', 'Alice').int('age', 42).into_string
  # # => '{"name": "Alice"}'
  # ```
  fn pub static object -> ObjectBuilder {
    ObjectBuilder(Map.new)
  }

  # Returns an `ArrayBuilder` for building a JSON array.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.int(10).int(20).into_string # => '[10,20]'
  # ```
  fn pub static array -> ArrayBuilder {
    ArrayBuilder([])
  }

  # Parses a `Read` type into a JSON object.
  #
  # # Examples
  #
  # Parsing a `String`:
  #
  # ```inko
  # import std.json (Json)
  # import std.io (Buffer)
  #
  # Json.parse(Buffer.new('[10]')) # => Result.Ok(Json.Array([Json.Int(10)]))
  # ```
  #
  # Parsing a `ByteArray`:
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (Json)
  #
  # Json.parse(Buffer.new('[10]'.to_byte_array)) # => Result.Ok(Json.Array([Json.Int(10)]))
  # ```
  fn pub static parse[T: mut + Read[E], E](bytes: T) -> Result[Json, Error[E]] {
    Parser.new(bytes).parse
  }

  # Formats `self` as a JSON string using indentation for nested objects.
  #
  # This method uses two spaces per indentation. To customise the amount of
  # spaces you'll need to use the `Generator` type directly.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).to_pretty_string               # => '42'
  # Json.Array([Json.Int(42)]).to_pretty_string # => "[\n  42\n]"
  # ```
  fn pub to_pretty_string -> String {
    Generator.new(DEFAULT_PRETTY_INDENT).generate(self)
  }

  # Returns a new `Query` that starts at `self`.
  #
  # See the documentation of the `Query` type for more information.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).query.as_int # => Option.Some(42)
  # ```
  fn pub query -> Query {
    Query(Option.Some(self))
  }
}

impl ToString for Json {
  # Formats `self` as a JSON string.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.Int(42).to_string               # => '42'
  # Json.Array([Json.Int(42)]).to_string # => '[42]'
  # ```
  fn pub to_string -> String {
    Generator.new(0).generate(self)
  }
}

impl FormatTrait for Json {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Int(val) -> formatter.tuple('Int').field(val).finish
      case Float(val) -> formatter.tuple('Float').field(val).finish
      case String(val) -> formatter.tuple('String').field(val).finish
      case Array(val) -> formatter.tuple('Array').field(val).finish
      case Object(val) -> formatter.tuple('Object').field(val).finish
      case Bool(val) -> formatter.tuple('Bool').field(val).finish
      case Null -> formatter.tuple('Null').finish
    }
  }
}

impl Equal for Json {
  fn pub ==(other: ref Json) -> Bool {
    match (self, other) {
      case (Int(a), Int(b)) -> a == b
      case (Float(a), Float(b)) -> a == b
      case (String(a), String(b)) -> a == b
      case (Bool(a), Bool(b)) -> a == b
      case (Array(a), Array(b)) -> a == b
      case (Object(a), Object(b)) -> a == b
      case (Null, Null) -> true
      case _ -> false
    }
  }
}

# A type for building a JSON object.
#
# An `ObjectBuilder` is created using the `Json.object` method and makes it
# easier to construct a JSON object using a fluent/builder API. Once an object
# is built it's converted to a `String` using `ObjectBuilder.into_string` or
# `ObjectBuilder.into_pretty_string`.
type pub inline ObjectBuilder {
  let @map: Map[String, Json]

  # Adds a key with its value set to a JSON string.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.object.string('key', 'value').into_string # => '{"key":"value"}'
  # ```
  fn pub move string(key: String, value: String) -> Self {
    @map.set(key, Json.String(value))
    self
  }

  # Adds a key with its value set to a JSON integer.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.object.int('key', 42).into_string # => '{"key":42}'
  # ```
  fn pub move int(key: String, value: Int) -> Self {
    @map.set(key, Json.Int(value))
    self
  }

  # Adds a key with its value set to a JSON float.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.object.float('key', 42.0).into_string # => '{"key":42.0}'
  # ```
  fn pub move float(key: String, value: Float) -> Self {
    @map.set(key, Json.Float(value))
    self
  }

  # Adds a key with its value set to a JSON boolean.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.object.bool('key', true).into_string # => '{"key":true}'
  # ```
  fn pub move bool(key: String, value: Bool) -> Self {
    @map.set(key, Json.Bool(value))
    self
  }

  # Adds a key with its value set to the JSON null value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.object.null('key').into_string # => '{"key":null}'
  # ```
  fn pub move null(key: String) -> Self {
    @map.set(key, Json.Null)
    self
  }

  # Adds a key with its value set to a JSON object created using another
  # `ObjectBuilder`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json
  #   .object
  #   .object('address', Json.object.string('city', 'Amsterdam'))
  #   .into_string
  # # => '{"address":{"city":"Amsterdam"}}'
  # ```
  fn pub move object(key: String, value: ObjectBuilder) -> Self {
    let { @map = other } = value

    @map.set(key, Json.Object(other))
    self
  }

  # Adds a key with its value set to a JSON array created using a
  # `ArrayBuilder`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json
  #   .object
  #   .array('numbers', Json.array.int(10).int(20))
  #   .into_string
  # # => '{"numbers":[10,20]}'
  # ```
  fn pub move array(key: String, value: ArrayBuilder) -> Self {
    let { @values = other } = value

    @map.set(key, Json.Array(other))
    self
  }

  # Converts `self` into a JSON string using indendation for nested values.
  #
  # Refer to the documentation of `Json.to_pretty_string` for more details.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.object.string('key', 'value').into_pretty_string
  # # => '{\n  "key": "value"\n}'
  # ```
  fn pub move into_pretty_string -> String {
    Json.Object(@map).to_pretty_string
  }
}

impl IntoString for ObjectBuilder {
  fn pub move into_string -> String {
    Json.Object(@map).to_string
  }
}

# A type for building a JSON array.
#
# An `ArrayBuilder` is created using the `Json.array` method and makes it easier
# to construct a JSON array using a fluent/builder API. Once an array is built
# it's converted to a `String` using `ArrayBuilder.into_string` or
# `ArrayBuilder.into_pretty_string`.
type pub inline ArrayBuilder {
  let @values: Array[Json]

  # Adds a JSON string value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.string('value').into_string # => '["value"]'
  # ```
  fn pub move string(value: String) -> Self {
    @values.push(Json.String(value))
    self
  }

  # Adds a JSON int value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.int(42).into_string # => '[42]'
  # ```
  fn pub move int(value: Int) -> Self {
    @values.push(Json.Int(value))
    self
  }

  # Adds a JSON float value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.float(42.0).into_string # => '[42.0]'
  # ```
  fn pub move float(value: Float) -> Self {
    @values.push(Json.Float(value))
    self
  }

  # Adds a JSON boolean value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.bool(true).into_string # => '[true]'
  # ```
  fn pub move bool(value: Bool) -> Self {
    @values.push(Json.Bool(value))
    self
  }

  # Adds a JSON null value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.null.into_string # => '[null]'
  # ```
  fn pub move null -> Self {
    @values.push(Json.Null)
    self
  }

  # Adds a JSON object created using an `ObjectBuilder`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.object(Json.object.string('key', 'value')).into_string
  # # => '[{"key":"value"}]'
  # ```
  fn pub move object(value: ObjectBuilder) -> Self {
    let { @map = other } = value

    @values.push(Json.Object(other))
    self
  }

  # Adds a JSON array created using another `ArrayBuilder`.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.array(Json.array.int(10)).into_string
  # # => '[[10]]'
  # ```
  fn pub move array(value: ArrayBuilder) -> Self {
    let { @values = other } = value

    @values.push(Json.Array(other))
    self
  }

  # Converts `self` into a JSON string using indendation for nested values.
  #
  # Refer to the documentation of `Json.to_pretty_string` for more details.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Json)
  #
  # Json.array.int(10).into_pretty_string
  # # => '[\n  10\n]'
  # ```
  fn pub move into_pretty_string -> String {
    Json.Array(@values).to_pretty_string
  }
}

impl IntoString for ArrayBuilder {
  fn pub move into_string -> String {
    Json.Array(@values).to_string
  }
}

# A numeric value that's either an `Int` or a `Float`.
type pub copy enum Number {
  case Int(Int)
  case Float(Float)
}

impl Equal for Number {
  fn pub ==(other: Number) -> Bool {
    match (self, other) {
      case (Int(a), Int(b)) -> a == b
      case (Float(a), Float(b)) -> a == b
      case _ -> false
    }
  }
}

impl FormatTrait for Number {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Int(v) -> formatter.tuple('Int').field(v).finish
      case Float(v) -> formatter.tuple('Float').field(v).finish
    }
  }
}

# A type describing what kind of value is located at the current position in an
# input stream.
type pub copy enum Type {
  case Array
  case Bool
  case Null
  case Number
  case Object
  case String
}

impl Equal for Type {
  fn pub ==(other: Type) -> Bool {
    match (self, other) {
      case (Array, Array) -> true
      case (Bool, Bool) -> true
      case (Null, Null) -> true
      case (Number, Number) -> true
      case (Object, Object) -> true
      case (String, String) -> true
      case _ -> false
    }
  }
}

impl FormatTrait for Type {
  fn pub fmt(formatter: mut Formatter) {
    let name = match self {
      case Array -> 'Array'
      case Bool -> 'Bool'
      case Null -> 'Null'
      case Number -> 'Number'
      case Object -> 'Object'
      case String -> 'String'
    }

    formatter.tuple(name).finish
  }
}

# A pull parser for turning a stream of bytes into JSON values.
#
# Using a `PullParser` you can parse a JSON document into a desired set of
# values, without the need for any intermediate `Json` values.
#
# # Examples
#
# Parsing an array:
#
# ```inko
# import std.io (Buffer)
# import std.json (PullParser)
#
# let parser = PullParser.new(Buffer.new('[10, 20]'))
# let values = []
#
# parser.array.or_panic
#
# while parser.array_value?.or_panic {
#   values.push(parser.int.or_panic)
#   parser.next_value.or_panic
# }
#
# values # => [10, 20]
# ```
#
# Parsing an object:
#
# ```inko
# import std.io (Buffer)
# import std.json (PullParser)
#
# let parser = PullParser.new(Buffer.new('{ "name": "Alice" }'))
# let map = Map.new
#
# parser.object.or_panic
#
# while parser.key?.or_panic {
#   map.set(parser.key.or_panic, parser.string.or_panic)
#   parser.next_key.or_panic
# }
#
# map.get('name').or_panic # => 'Alice'
# ```
type pub PullParser[T: mut + Read[E], E] {
  # The input stream to parse
  let @input: BufferedReader[T, E]

  # The offset into the input stream, used for error reporting.
  let mut @offset: Int

  # A buffer to use for parsing certain values such as integers.
  let @buffer: ByteArray

  # Returns a new `PullParser` that parses the given `Read` type.
  fn pub static new(input: T) -> Self {
    Self(input: BufferedReader.new(input), offset: 0, buffer: ByteArray.new)
  }

  # Parses the opening tag of an object (`{`).
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('{ "name": "Alice" }'))
  #
  # parser.object # => Result.Ok(nil)
  # ```
  fn pub mut object -> Result[Nil, Error[E]] {
    try expect(CURLY_OPEN, skip_whitespace: true)

    match peek {
      case Ok(Some(COMMA)) -> throw unexpected(COMMA)
      case Ok(Some(_)) -> Result.Ok(nil)
      case Ok(_) -> throw end_of_input
      case Error(e) -> throw e
    }
  }

  # Returns a `Bool` indicating if the current value is a key or the end of an
  # object.
  #
  # If the current value is the start of a key (= `"`), this method returns
  # `Result.Ok(true)`. If the current value is instead `}` then
  # `Result.Ok(false)` is returned.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('{ "name": "Alice" }'))
  #
  # parser.object # => Result.Ok(nil)
  # parser.key?   # => Result.Ok(true)
  # ```
  fn pub mut key? -> Result[Bool, Error[E]] {
    try skip_whitespace

    match peek {
      case Ok(Some(CURLY_CLOSE)) -> {
        try advance
        Result.Ok(false)
      }
      case Ok(Some(DQUOTE)) -> Result.Ok(true)
      case Ok(Some(v)) -> throw unexpected(v)
      case Ok(_) -> throw end_of_input
      case Error(e) -> throw e
    }
  }

  # Parses the key-value pair separator (`,`) and advances to the next value, or
  # the end of the object.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('{ "a": 10, "b": 20 }'))
  #
  # parser.object   # => Result.Ok(nil)
  # parser.key      # => Result.Ok('a')
  # parser.int      # => Result.Ok(10)
  # parser.next_key # => Result.Ok(nil)
  # parser.key      # => Result.Ok('b')
  # ```
  fn pub mut next_key -> Result[Nil, Error[E]] {
    try skip_whitespace

    match peek {
      case Ok(Some(CURLY_CLOSE)) -> Result.Ok(nil)
      case Ok(Some(COMMA)) -> {
        try advance
        try skip_whitespace

        match peek {
          case Ok(Some(COMMA or CURLY_CLOSE)) -> throw unexpected(peek.get.get)
          case Ok(Some(_)) -> Result.Ok(nil)
          case Ok(_) -> throw end_of_input
          case Error(e) -> throw e
        }
      }
      case Ok(Some(v)) -> throw unexpected(v)
      case Ok(_) -> throw end_of_input
      case Error(e) -> throw e
    }
  }

  # Parses the key of an object and returns its name.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('{ "name": "Alice" }'))
  #
  # parser.object # => Result.Ok(nil)
  # parser.key    # => Result.Ok('name')
  # ```
  fn pub mut key -> Result[String, Error[E]] {
    let key = try string

    try expect(COLON, skip_whitespace: true)
    Result.Ok(key)
  }

  # Parses the opening tag of an array (`[`).
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('[ 10 ]'))
  #
  # parser.array # => Result.Ok(nil)
  # ```
  fn pub mut array -> Result[Nil, Error[E]] {
    try expect(BRACKET_OPEN, skip_whitespace: true)

    match peek {
      case Ok(Some(COMMA)) -> throw unexpected(COMMA)
      case Ok(Some(_)) -> Result.Ok(nil)
      case Ok(_) -> throw end_of_input
      case Error(e) -> throw e
    }
  }

  # Returns a `Bool` indicating if the current value is an array value or the
  # end of an array.
  #
  # If the current value is the start of an array value, this method returns
  # `Result.Ok(true)`. If the current value is instead `]` then
  # `Result.Ok(false)` is returned.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('[10]'))
  #
  # parser.array        # => Result.Ok(nil)
  # parser.array_value? # => Result.Ok(true)
  # ```
  fn pub mut array_value? -> Result[Bool, Error[E]] {
    try skip_whitespace

    match peek {
      case Ok(Some(BRACKET_CLOSE)) -> {
        try advance
        Result.Ok(false)
      }
      case Ok(Some(_)) -> Result.Ok(true)
      case Ok(_) -> throw end_of_input
      case Error(e) -> throw e
    }
  }

  # Parses the array value separator (`,`) and advances to the next value, or
  # the end of the array.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # let parser = PullParser.new(Buffer.new('[10, 20]'))
  #
  # parser.array      # => Result.Ok(nil)
  # parser.int        # => Result.Ok(10)
  # parser.next_value # => Result.Ok(nil)
  # parser.int        # => Result.Ok(20)
  # ```
  fn pub mut next_value -> Result[Nil, Error[E]] {
    try skip_whitespace

    match peek {
      case Ok(Some(BRACKET_CLOSE)) -> Result.Ok(nil)
      case Ok(Some(COMMA)) -> {
        try advance
        try skip_whitespace

        match peek {
          case Ok(Some(COMMA or BRACKET_CLOSE)) -> {
            throw unexpected(peek.get.get)
          }
          case Ok(Some(_)) -> Result.Ok(nil)
          case Ok(_) -> throw end_of_input
          case Error(e) -> throw e
        }
      }
      case Ok(Some(v)) -> throw unexpected(v)
      case Ok(_) -> throw end_of_input
      case Error(e) -> throw e
    }
  }

  # Parses a string.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('"name"')).string # => Result.Ok('name')
  # ```
  fn pub mut string -> Result[String, Error[E]] {
    try skip_whitespace

    match try advance {
      case Some(DQUOTE) -> {}
      case Some(byte) -> throw was_unexpected(byte)
      case _ -> throw end_of_input
    }

    loop {
      match try advance {
        case Some(BSLASH) -> {
          match try advance {
            case Some(LOWER_U) -> try escaped_unicode
            case Some(byte) -> {
              match ESCAPE_TABLE.get(byte).or_panic {
                case -1 -> throw was_unexpected(byte)
                case val -> @buffer.push(val)
              }
            }
            case _ -> throw end_of_input
          }
        }
        case Some(DQUOTE) -> break
        case Some(val) if val >= 0x0 and val <= 0x001F -> {
          throw Error(ErrorKind.InvalidControl, previous_offset)
        }
        case Some(byte) -> @buffer.push(byte)
        case _ -> throw end_of_input
      }
    }

    Result.Ok(@buffer.drain_to_string)
  }

  # Parses a number as an `Int`.
  #
  # If the value in the input stream is in fact a float (e.g. `1.2` instead of
  # just `1`), it's first parsed as a `Float` then cast to an `Int`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # Parser.new(Buffer.new('10')).int  # => Result.Ok(10)
  # Parser.new(Buffer.new('1.2')).int # => Result.Ok(1)
  # ```
  fn pub mut int -> Result[Int, Error[E]] {
    match number {
      case Ok(Int(v)) -> Result.Ok(v)
      case Ok(Float(v)) -> Result.Ok(v.to_int)
      case Error(e) -> Result.Error(e)
    }
  }

  # Parses a number as a `Float`.
  #
  # If the value in the input stream is in fact an integer (e.g. `1` instead of
  # `1.0` or `1.2`), the value is first parsed as an `Int` then cast to a
  # `Float`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # Parser.new(Buffer.new('1.2')).float # => Result.Ok(1.2)
  # Parser.new(Buffer.new('1')).float   # => Result.Ok(1.0)
  # ```
  fn pub mut float -> Result[Float, Error[E]] {
    match number {
      case Ok(Int(v)) -> Result.Ok(v.to_float)
      case Ok(Float(v)) -> Result.Ok(v)
      case Error(e) -> Result.Error(e)
    }
  }

  # Parses a number into a `Number` value.
  #
  # A `Number` is an enum storing either a `Float` or an `Int`. If you only care
  # about numbers in a particular format (e.g. integers), use `PullParser.int`
  # or `PullParser.float` instead.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # Parser.new(Buffer.new('1.2')).number # => Result.Ok(Number.Float(1.2))
  # Parser.new(Buffer.new('1')).number   # => Result.Ok(Number.Int(1))
  # ```
  fn pub mut number -> Result[Number, Error[E]] {
    match try peek {
      case Some(MINUS) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> {}
          case Some(byte) -> throw unexpected(byte)
          case _ -> throw end_of_input
        }
      }
      case Some(byte) if digit?(byte) -> {}
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw end_of_input
    }

    # Numbers such as 001, 010, 01.0, etc are invalid.
    match try peek_next {
      case Some(ZERO) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> throw unexpected(byte)
          case _ -> {}
        }
      }
      case _ -> {}
    }

    try buffer_digits

    match try peek_next {
      # Examples: 1.2, 1.2e1, 1.2e+1
      case Some(DOT) -> {
        try advance_and_buffer

        match try peek_next {
          case Some(byte) if digit?(byte) -> {}
          case Some(byte) -> throw unexpected(byte)
          case _ -> throw end_of_input
        }

        try buffer_digits

        match try peek_next {
          case Some(byte) if exponent?(byte) -> try exponent
          case _ -> {}
        }
      }
      # Example: 1E4
      case Some(byte) if exponent?(byte) -> try exponent
      # Example: 123
      #
      # If the number is too big to fit in an Int, we'll promote it to a Float.
      case _ -> {
        match Int.parse(@buffer, Format.Decimal) {
          case Some(val) -> {
            @buffer.clear
            return Result.Ok(Number.Int(val))
          }
          case _ -> {}
        }
      }
    }

    # At this point we've already validated the input format, and it's
    # compatible with the underlying float parser, so no extra checks are
    # needed.
    let res = Result.Ok(Number.Float(Float.parse(@buffer).get))

    @buffer.clear
    res
  }

  # Parses a `null` value.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('null')).null # => Result.Ok(nil)
  # ```
  fn pub mut null -> Result[Nil, Error[E]] {
    identifier('null')
  }

  # Parses the boolean value `true` or `false`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('true')).bool  # => Result.Ok(true)
  # PullParser.new(Buffer.new('false')).bool # => Result.Ok(false)
  # ```
  fn pub mut bool -> Result[Bool, Error[E]] {
    match try peek {
      case Some(LOWER_T) -> {
        let _ = advance

        try identifier('rue')
        Result.Ok(true)
      }
      case Some(LOWER_F) -> {
        let _ = advance

        try identifier('alse')
        Result.Ok(false)
      }
      case Some(v) -> throw unexpected(v)
      case _ -> throw end_of_input
    }
  }

  # Returns a `Type` describing what type of value is located at the current
  # offset.
  #
  # # Examples
  #
  # ```inko
  # import std.stdio (Buffer)
  # import std.json (PullParser)
  #
  # Parser.new(Buffer.new('10')).value_type # => Result.Ok(Type.Number)
  # ```
  fn pub mut value_type -> Result[Type, Error[E]] {
    let typ = match try peek {
      case Some(MINUS) -> Type.Number
      case Some(BRACKET_OPEN) -> Type.Array
      case Some(CURLY_OPEN) -> Type.Object
      case Some(LOWER_T or LOWER_F) -> Type.Bool
      case Some(LOWER_N) -> Type.Null
      case Some(DQUOTE) -> Type.String
      case Some(byte) if digit?(byte) -> Type.Number
      # This is to take care of any random garbage that may be included in the
      # JSON document, including Unicode BOMs. This also saves us from having to
      # explicitly check for all the different BOMs.
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw end_of_input
    }

    Result.Ok(typ)
  }

  # Returns the byte offset of the start of the next non-whitespace value.
  #
  # This method is useful when you want to obtain the start of some value and
  # use it when reporting an error when parsing said value, such as when you
  # want to parse a JSON string into a Markdown document.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (PullParser)
  #
  # PullParser.new(Buffer.new('  10')).start_of_next_value # => Result.Ok(2)
  # ```
  fn pub mut start_of_next_value -> Result[Int, Error[E]] {
    try skip_whitespace
    Result.Ok(@offset)
  }

  fn mut escaped_unicode -> Result[Nil, Error[E]] {
    let start = @offset - 2
    let high = try codepoint

    if utf8.encode_scalar(high, @buffer) > 0 { return Result.Ok(nil) }

    # At this point the codepoint is either straight up invalid (e.g. "\uZZZZ"),
    # or it's a UTF-16 surrogate.
    if !utf8.surrogate?(high) { throw Error(ErrorKind.InvalidSurrogate, start) }

    try expect(BSLASH, skip_whitespace: false)
    try expect(LOWER_U, skip_whitespace: false)

    let low = try codepoint

    if utf8.surrogate?(low) {
      let codepoint = utf8.codepoint_from_surrogates(high, low)

      # The encoding may fail for pairs such as "\uDFFF\uDFFF".
      if utf8.encode_scalar(codepoint, @buffer) > 0 { return Result.Ok(nil) }
    }

    throw Error(ErrorKind.InvalidSurrogate, start)
  }

  fn mut codepoint -> Result[Int, Error[E]] {
    let mut num = 0
    let mut idx = 0

    while idx < 4 {
      let digit = match try advance {
        case Some(byte) -> {
          if byte >= ZERO and byte <= NINE {
            byte - ZERO
          } else if byte >= LOWER_A and byte <= LOWER_F {
            byte - LOWER_A + 10
          } else if byte >= UPPER_A and byte <= UPPER_F {
            byte - UPPER_A + 10
          } else {
            throw was_unexpected(byte)
          }
        }
        case _ -> throw end_of_input
      }

      num = num * 16 + digit
      idx += 1
    }

    Result.Ok(num)
  }

  fn mut identifier(name: String) -> Result[Nil, Error[E]] {
    try skip_whitespace

    let mut index = 0
    let max = name.size

    while index < max {
      try expect(name.get(index := index + 1).or_panic, skip_whitespace: false)
    }

    Result.Ok(nil)
  }

  fn mut expect(byte: Int, skip_whitespace: Bool) -> Result[Nil, Error[E]] {
    if skip_whitespace { try self.skip_whitespace }

    match try advance {
      case Some(val) if val == byte -> Result.Ok(nil)
      case Some(val) -> throw was_unexpected(val)
      case _ -> throw end_of_input
    }
  }

  fn mut skip_whitespace -> Result[Nil, Error[E]] {
    loop {
      match try peek_next {
        case Some(SPACE or CR or TAB or LF) -> try advance
        case _ -> return Result.Ok(nil)
      }
    }
  }

  fn mut advance_and_buffer -> Result[Option[Int], Error[E]] {
    match try advance {
      case Some(val) -> {
        @buffer.push(val)
        Result.Ok(Option.Some(val))
      }
      case _ -> Result.Ok(Option.None)
    }
  }

  fn mut exponent -> Result[Nil, Error[E]] {
    try advance_and_buffer

    match try peek_next {
      case Some(MINUS or PLUS) -> {
        try advance_and_buffer
        nil
      }
      case _ -> {}
    }

    match try peek_next {
      case Some(byte) if digit?(byte) -> {}
      case Some(byte) -> throw unexpected(byte)
      case _ -> throw end_of_input
    }

    try buffer_digits
    Result.Ok(nil)
  }

  fn mut buffer_digits -> Result[Nil, Error[E]] {
    loop {
      match try peek_next {
        case Some(byte) if digit?(byte) -> {
          try advance
          @buffer.push(byte)
        }
        case _ -> return Result.Ok(nil)
      }
    }
  }

  fn mut advance -> Result[Option[Int], Error[E]] {
    match @input.read_byte {
      case Ok(Some(v)) -> {
        @offset += 1
        Result.Ok(Option.Some(v))
      }
      case Ok(None) -> Result.Ok(Option.None)
      case Error(e) -> Result.Error(error(ErrorKind.Read(e)))
    }
  }

  fn mut peek -> Result[Option[Int], Error[E]] {
    loop {
      match peek_next {
        case Ok(Some(SPACE or CR or TAB or LF)) -> advance
        case Ok(Some(byte)) -> return Result.Ok(Option.Some(byte))
        case Ok(None) -> return Result.Ok(Option.None)
        case Error(e) -> throw e
      }
    }
  }

  fn mut peek_next -> Result[Option[Int], Error[E]] {
    match @input.peek {
      case Ok(Some(v)) -> Result.Ok(Option.Some(v))
      case Ok(None) -> Result.Ok(Option.None)
      case Error(e) -> Result.Error(error(ErrorKind.Read(e)))
    }
  }

  fn unexpected(byte: Int) -> Error[E] {
    error(ErrorKind.Unexpected(char(byte)))
  }

  fn end_of_input -> Error[E] {
    error(ErrorKind.EndOfInput)
  }

  fn was_unexpected(byte: Int) -> Error[E] {
    Error(ErrorKind.Unexpected(char(byte)), previous_offset)
  }

  fn error(kind: ErrorKind[E]) -> Error[E] {
    Error(kind, offset: @offset)
  }

  fn previous_offset -> Int {
    if @offset == 0 { 0 } else { @offset - 1 }
  }
}

# A DOM parser for turning a stream of bytes into a JSON document.
#
# This parser only supports parsing `ByteArray` values as input. If you need to
# parse very large documents, it's best to separate the objects on a per line
# basis, then parse the document one line at a time.
#
# # Nested arrays and objects
#
# This parser enforces a limit on the number of nested arrays and objects. The
# default is sufficiently large that most documents won't result in an error
# being thrown. This limit is controlled by the field `Parser.max_depth`.
type pub Parser[T: mut + Read[E], E] {
  let @pull: PullParser[T, E]
  let mut @depth: Int

  # The maximum number of nested values.
  #
  # When parsing an array or object that exceeds this depth, an error is thrown.
  let pub mut @max_depth: Int

  # Returns a new parser that will parse the given `Read` type.
  fn pub static new(input: T) -> Parser[T, E] {
    Parser(PullParser.new(input), depth: 0, max_depth: 100)
  }

  # Parses the input into a JSON object.
  #
  # If the input is invalid JSON, this method throws an `Error`.
  #
  # # Examples
  #
  # ```inko
  # import std.io (Buffer)
  # import std.json (Parser)
  #
  # let parser = Parser.new(Buffer.new('[10, 20]'))
  #
  # parser.parse.get # => Json.Array([Json.Int(10), Json.Int(20)])
  # ```
  fn pub move parse -> Result[Json, Error[E]] {
    let result = try value

    # Only trailing whitespace is allowed.
    match try @pull.peek {
      case Some(val) -> throw @pull.unexpected(val)
      case _ -> {}
    }

    Result.Ok(result)
  }

  fn mut value -> Result[Json, Error[E]] {
    match try @pull.value_type {
      case Number -> number
      case Array -> array
      case Object -> object
      case Bool -> bool
      case Null -> null
      case String -> string
    }
  }

  fn mut string -> Result[Json, Error[E]] {
    Result.Ok(Json.String(try @pull.string))
  }

  fn mut bool -> Result[Json, Error[E]] {
    Result.Ok(Json.Bool(try @pull.bool))
  }

  fn mut null -> Result[Json, Error[E]] {
    try @pull.null
    Result.Ok(Json.Null)
  }

  fn mut array -> Result[Json, Error[E]] {
    try check_depth

    let values = []

    @depth += 1

    try @pull.array

    while try @pull.array_value? {
      values.push(try value)
      try @pull.next_value
    }

    @depth -= 1
    Result.Ok(Json.Array(values))
  }

  fn mut object -> Result[Json, Error[E]] {
    let map = Map.new

    try check_depth
    @depth += 1
    try @pull.object

    while try @pull.key? {
      map.set(try @pull.key, try value)
      try @pull.next_key
    }

    @depth -= 1
    Result.Ok(Json.Object(map))
  }

  fn mut number -> Result[Json, Error[E]] {
    match @pull.number {
      case Ok(Int(v)) -> Result.Ok(Json.Int(v))
      case Ok(Float(v)) -> Result.Ok(Json.Float(v))
      case Error(e) -> Result.Error(e)
    }
  }

  fn check_depth -> Result[Nil, Error[E]] {
    if @depth < @max_depth {
      Result.Ok(nil)
    } else {
      Result.Error(@pull.error(ErrorKind.RecursionLimitExceeded(@max_depth)))
    }
  }
}

# A type for turning a `Json` value into a JSON string.
#
# This type is used by `Json.to_string` and `Json.to_pretty_string`. Unless you
# want to use custom indentation, it's recommended to use these methods instead
# of using `Generator` directly.
type pub Generator {
  let @pretty: Bool
  let @spaces: String
  let mut @depth: Int
  let @buffer: StringBuffer

  # Returns a new `Generator` using the given indentation level.
  #
  # The `indent` argument specifies the number of spaces to use per indentation
  # level. If this value is less than or equal to zero, no indentation is
  # applied.
  fn pub static new(indent: Int) -> Generator {
    Generator(
      pretty: indent > 0,
      spaces: ' '.repeat(indent),
      depth: 0,
      buffer: StringBuffer.new,
    )
  }

  # Generates a JSON string for the given `Json` value.
  #
  # # Examples
  #
  # ```inko
  # import std.json (Generator)
  #
  # Generator.new(indent: 2).generate(Json.Array([Json.Int(1)])) # => '[1]'
  # ```
  fn pub move generate(value: ref Json) -> String {
    generate_value(value)
    @buffer.into_string
  }

  fn mut generate_value(value: ref Json) {
    match value {
      case Int(val) -> @buffer.push(val.to_string)
      case Float(val) -> @buffer.push(val.to_string)
      case String(val) -> {
        @buffer.push('"')
        @buffer.push(val.escaped)
        @buffer.push('"')
      }
      case Array(vals) -> {
        @buffer.push('[')

        if vals.size > 0 {
          enter(fn {
            for (index, val) in vals.iter.with_index {
              if index > 0 { separator }

              indent
              generate_value(val)
            }
          })

          indent
        }

        @buffer.push(']')
      }
      case Object(vals) -> {
        @buffer.push('{')

        if vals.size > 0 {
          enter(fn {
            for (index, (k, v)) in vals.iter.with_index {
              if index > 0 { separator }

              indent
              @buffer.push('"')
              @buffer.push(k.escaped)
              @buffer.push('": ')
              generate_value(v)
            }
          })

          indent
        }

        @buffer.push('}')
      }
      case Bool(val) -> @buffer.push(val.to_string)
      case Null -> @buffer.push('null')
    }
  }

  fn mut enter(block: fn) {
    newline
    @depth += 1
    block.call
    @depth -= 1
    newline
  }

  fn mut indent {
    if @pretty { @depth.times(fn (_) { @buffer.push(@spaces) }) }
  }

  fn mut newline {
    if @pretty { @buffer.push('\n') }
  }

  fn mut separator {
    @buffer.push(if @pretty { ',\n' } else { ', ' })
  }
}
