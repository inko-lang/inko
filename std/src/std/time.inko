# Types and methods for dealing with time.
import std.bytes (Bytes)
import std.bytes.parsers (digits, four_digits, name_index_at, two_digits)
import std.clone (Clone)
import std.cmp (Compare, Equal, Ordering)
import std.float (ToFloat)
import std.fmt (Format, Formatter)
import std.int (ToInt)
import std.locale (Locale)
import std.locale.en (Locale as English)
import std.ops (Add, Divide, Multiply, Subtract)
import std.sys.unix.time (self as sys) if unix

let SECS_PER_MIN = 60
let SECS_PER_HOUR = 3600
let SECS_PER_DAY = 86_400
let DAYS_PER_WEEK = 7
let NANOS_PER_SEC = 1_000_000_000.0
let MICROS_PER_SEC = 1_000_000
let MILLIS_PER_SEC = 1_000

# The number of days since the start of the year for each month, for a leap
# year.
let LEAP_DAYS = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 205, 335]

# The number of days since the start of the year for each month, for a regular
# year.
let NORMAL_DAYS = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 204, 334]

let COLON = 58
let DOT = 46
let LOWER_A = 97
let LOWER_B = 98
let LOWER_D = 100
let LOWER_F = 102
let LOWER_M = 109
let LOWER_Y = 121
let LOWER_Z = 122
let MINUS = 45
let NINE = 57
let PERCENT = 37
let PLUS = 43
let UPPER_A = 65
let UPPER_B = 66
let UPPER_H = 72
let UPPER_M = 77
let UPPER_S = 83
let UPPER_Y = 89
let UPPER_Z = 90
let ZERO = 48

let RFC_2822_ZONES = ['GMT', 'UT']

fn parse_offset[T: Bytes](input: ref T, start: Int) -> Option[(Int, Int)] {
  let mut inp_idx = start

  let pos = match input.get(inp_idx := inp_idx + 1) {
    case Ok(PLUS) -> true
    case Ok(MINUS) -> false
    case _ -> return Option.None
  }

  let hour = try two_digits(input, inp_idx)

  inp_idx += 2

  if input.get(inp_idx).or(-1) == COLON { inp_idx += 1 }

  let min = match input.get(inp_idx) {
    case Ok(byte) if byte >= ZERO and byte <= NINE -> {
      try two_digits(input, inp_idx)
    }
    case _ -> return Option.None
  }

  inp_idx += 2

  let secs = (hour * 3600) + (min * 60)

  Option.Some((if pos { secs } else { 0 - secs }, inp_idx))
}

fn format_digits(bytes: mut ByteArray, value: Int, amount: Int) {
  let alphabet = '0123456789'
  let mut int = value.absolute
  let mut pushed = 0

  while int > 0 {
    bytes.push(alphabet.get(int % 10).or_panic)
    int /= 10
    pushed += 1
  }

  while pushed < amount {
    bytes.push(ZERO)
    pushed += 1
  }

  if value < 0 {
    bytes.push(0x2D)
    pushed += 1
  }

  bytes.reverse_at(bytes.size - pushed)
}

fn format_offset(bytes: mut ByteArray, offset: Int) {
  let abs = offset.absolute
  let hh = (abs / SECS_PER_HOUR)
  let mm = (abs % SECS_PER_HOUR / SECS_PER_MIN)

  bytes.push(if offset >= 0 { PLUS } else { MINUS })
  format_digits(bytes, hh, amount: 2)
  bytes.push(COLON)
  format_digits(bytes, mm, amount: 2)
}

fn negative_time_error(time: Int) -> Never {
  panic("Instant can't represent a negative time (${time})")
}

# A span of time measured in nanoseconds.
#
# A `Duration` can be used to measure the span of time without having to worry
# about casting the time to different scales yourself. A `Duration` can be
# created using various scales such as seconds and milliseconds.
#
# `Duration` measures a time duration in nanoseconds, limiting it to durations
# of up to 292 years. Operations producing values greater than this range will
# panic.
#
# `Duration` objects can represent negative durations such as "-5 seconds". This
# is useful when performing arithmetic on `Duration` objects, as you won't have
# to worry about overflows. It also lets you represent a duration that goes back
# in time, i.e. "something that happened 5 seconds ago".
type pub copy Duration {
  let @nanos: Int

  # Creates a new `Duration` from the given number of seconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_secs(10.5)
  # ```
  fn pub inline static from_secs[T: ToFloat](secs: ref T) -> Duration {
    Duration((secs.to_float * NANOS_PER_SEC).to_int)
  }

  # Creates a new `Duration` from the given number of milliseconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_millis(10)
  # ```
  fn pub inline static from_millis[T: ToInt](millis: ref T) -> Duration {
    Duration(millis.to_int * MICROS_PER_SEC)
  }

  # Creates a new `Duration` from the given number of microseconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_micros(10)
  # ```
  fn pub inline static from_micros[T: ToInt](micros: ref T) -> Duration {
    Duration(micros.to_int * MILLIS_PER_SEC)
  }

  # Creates a new `Duration` from the given number of nanoseconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_nanos(10)
  # ```
  fn pub inline static from_nanos[T: ToInt](nanos: ref T) -> Duration {
    Duration(nanos.to_int)
  }

  # Returns the duration in seconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_secs(5).to_secs # => 5.0
  # ```
  fn pub inline to_secs -> Float {
    @nanos.to_float / NANOS_PER_SEC
  }

  # Returns the duration in milliseconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_secs(5).to_millis # => 5000
  # ```
  fn pub inline to_millis -> Int {
    @nanos / MICROS_PER_SEC
  }

  # Returns the duration in microseconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_secs(5).to_micros # => 5000000
  # ```
  fn pub inline to_micros -> Int {
    @nanos / MILLIS_PER_SEC
  }

  # Returns the duration in nanoseconds.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_secs(5).to_nanos # => 5000000000
  # ```
  fn pub inline to_nanos -> Int {
    @nanos
  }

  # Returns `true` if `self` is greater than zero.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_secs(1).positive? # => true
  # Duration.from_secs(0).positive? # => false
  # ```
  fn pub inline positive? -> Bool {
    @nanos > 0
  }

  # Returns `true` if `self` is zero.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration)
  #
  # Duration.from_secs(1).zero? # => false
  # Duration.from_secs(0).zero? # => true
  # ```
  fn pub inline zero? -> Bool {
    @nanos == 0
  }
}

impl ToInstant for Duration {
  # Adds `self` to the current monotonic time, returning a new `Instant`
  # representing the resulting point in time.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration, Instant)
  #
  # let duration = Duration.from_secs(5)
  #
  # duration.to_instant.remaining <= duration # => true
  # ```
  #
  # # Panics
  #
  # This method panics if the resulting `Instant` is invalid, such as when it's
  # a negative time.
  fn pub inline to_instant -> Instant {
    Instant.new + self
  }
}

impl Clone for Duration {
  fn pub inline clone -> Duration {
    Duration(@nanos)
  }
}

impl Add[Duration, Duration] for Duration {
  fn pub inline +(other: Duration) -> Duration {
    Duration(
      @nanos.checked_add(other.nanos).or_panic_with(
        'Duration + Duration overflowed',
      ),
    )
  }
}

impl Subtract[Duration, Duration] for Duration {
  fn pub inline -(other: Duration) -> Duration {
    Duration(
      @nanos.checked_sub(other.nanos).or_panic_with(
        'Duration - Duration overflowed',
      ),
    )
  }
}

impl Multiply[Int, Duration] for Duration {
  fn pub inline *(other: Int) -> Duration {
    Duration(
      @nanos.checked_mul(other).or_panic_with('Duration * Int overflowed'),
    )
  }
}

impl Divide[Int, Duration] for Duration {
  fn pub inline /(other: Int) -> Duration {
    Duration(@nanos / other)
  }
}

impl Compare for Duration {
  fn pub inline cmp(other: Duration) -> Ordering {
    @nanos.cmp(other.nanos)
  }
}

impl Equal for Duration {
  fn pub inline ==(other: Duration) -> Bool {
    @nanos == other.nanos
  }
}

impl Format for Duration {
  fn pub fmt(formatter: mut Formatter) {
    let abs = @nanos.absolute
    let write = if abs >= 1_000_000_000 {
      '${to_secs} sec'
    } else if abs >= 1_000_000 {
      '${to_millis} msec'
    } else if abs >= 1_000 {
      '${to_micros} µsec'
    } else {
      '${@nanos} nsec'
    }

    formatter.write(write)
  }
}

# A type representing a date in the Gregorian calendar, without a time and
# timezone.
type pub copy Date {
  # The year, month and day packed into a single set of bits.
  #
  # The layout is as follows (starting with the least significant bits):
  #
  # 1. 5 bits for the day
  # 1. 4 bits for the month
  # 1. Up to 32 bits for the year
  #
  # For example, the date 1992-08-21 is encoded as follows:
  #
  #     11111001000 1000 10101
  let @bits: Int

  # Returns a new `Date`, provided the given components are valid.
  #
  # The arguments must be values in the following ranges:
  #
  # - `year`: -2147483648 up to and including 2147483647
  # - `month`: 1 up to and including 12
  # - `day`: 1 up to and including 31
  #
  # If any of the arguments are out of bounds, an `Option.None` is returned.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Date)
  #
  # let date = Date
  #   .new(year: 2024, month: 12, day: 17)
  #   .or_panic_with('the Date is invalid')
  #
  # date.year # => 2024
  # ```
  fn pub inline static new(year: Int, month: Int, day: Int) -> Option[Date] {
    if
      year >= -2147483648
        and year <= 2147483647
        and month >= 1
        and month <= 12
        and day >= 1
        and day <= 31
    {
      Option.Some(new_unchecked(year, month, day))
    } else {
      Option.None
    }
  }

  fn inline static new_unchecked(year: Int, month: Int, day: Int) -> Date {
    Date((year << 9) | (month << 5) | day)
  }

  # Returns the year.
  fn pub inline year -> Int {
    @bits >> 9
  }

  # Returns the month in the range `1` to `12`.
  fn pub inline month -> Int {
    @bits >> 5 & 0xF
  }

  # Returns the day in the range `1` to `31`.
  fn pub inline day -> Int {
    @bits & 0x1F
  }

  # Returns the number of days between `self` and the Unix epoch.
  #
  # The returned `Int` is negative if `self` is before the Unix epoch, and
  # positive for a value that is on or after the Unix epoch.
  fn pub days_since_unix_epoch -> Int {
    let year = if month <= 2 { year - 1 } else { year }
    let month = month
    let era = if year >= 0 { year } else { year - 399 } / 400
    let yoe = year - (era * 400)
    let doy = (((153 * if month > 2 { month - 3 } else { month + 9 }) + 2) / 5)
      + day
      - 1
    let doe = (yoe * 365) + (yoe / 4) - (yoe / 100) + doy

    (era * 146_097) + doe - 719_468
  }

  # Returns the day of the week from 1 to 7.
  #
  # Per ISO 8601 the first day of the week starts on Monday, not Sunday.
  fn pub day_of_week -> Int {
    # January 1st, 1970 (our anchor date) was on a Thursday. We add 3 so that
    # Monday (3 days before Thursday) becomes the anchor date.
    #
    # We later on add 1 since the % operator will return 0 for Monday (since its
    # the first value in the range), but week days range from 1 to 7; not 0 to
    # 6.
    #
    # The following table should help illustrate this:
    #
    # | Date       | Day of week | days_since_unix_epoch
    # |:-----------|:------------|:----------------------
    # | 1969-12-29 | Monday      | -3
    # | 1969-12-30 | Tuesday     | -2
    # | 1969-12-31 | Wednesday   | -1
    # | 1970-01-01 | Thursday    | 0
    # | 1970-01-02 | Friday      | 1
    # | 1970-01-03 | Saturday    | 2
    # | 1970-01-04 | Sunday      | 3
    #
    # For these dates, the calculations would be as follows:
    #
    # | Date       | Calculation        | Simplified  | Return value
    # |:-----------|:-------------------|:------------|:------------
    # | 1969-12-29 | ((-3 + 3) % 7) + 1 | (0 % 7) + 1 | 1
    # | 1969-12-30 | ((-2 + 3) % 7) + 1 | (1 % 7) + 1 | 2
    # | 1969-12-31 | ((-1 + 3) % 7) + 1 | (2 % 7) + 1 | 3
    # | 1970-01-01 | ((0 + 3) % 7) + 1  | (3 % 7) + 1 | 4
    # | 1970-01-02 | ((1 + 3) % 7) + 1  | (4 % 7) + 1 | 5
    # | 1970-01-03 | ((2 + 3) % 7) + 1  | (5 % 7) + 1 | 6
    # | 1970-01-04 | ((3 + 3) % 7) + 1  | (6 % 7) + 1 | 7
    days_since_unix_epoch + 3 % DAYS_PER_WEEK + 1
  }

  # Returns the day of the year from 1 to 366 for leap years, and from 1 to 365
  # for regular years.
  fn pub day_of_year -> Int {
    let days = if leap_year? { LEAP_DAYS } else { NORMAL_DAYS }

    days.get(month - 1).or_panic + day
  }

  # Returns `true` if the current year is a leap year.
  fn pub leap_year? -> Bool {
    let year = year

    (year % 4) == 0 and ((year % 100) > 0 or (year % 400) == 0)
  }
}

impl Equal for Date {
  fn pub ==(other: Date) -> Bool {
    @bits == other.bits
  }
}

impl Format for Date {
  fn pub fmt(formatter: mut Formatter) {
    let year = year.to_string.pad_start(with: '0', chars: 4)
    let month = month.to_string.pad_start(with: '0', chars: 2)
    let day = day.to_string.pad_start(with: '0', chars: 2)

    formatter.write('${year}-${month}-${day}')
  }
}

# A type that represents a point in time (hours, minutes and seconds) without a
# specific associated date.
type pub copy Time {
  # The hour, minute, second and sub seconds packed into a single set of bits.
  #
  # The layout is as follows (starting with the least significant bits):
  #
  # 1. 6 bits for the seconds
  # 1. 6 bits for the minutes
  # 1. 5 bits for the hour
  # 1. 30 bits for the sub seconds (as nanoseconds).
  #
  # For example, the time 12:45:30.23 is encoded as follows:
  #
  #     1101101101011000010110000000 1100 101101 011110
  let @bits: Int

  # Returns a new `Time`, provided the given components are valid.
  #
  # The arguments must be values in the following ranges:
  #
  # - `hour`: 0 up to and including 23
  # - `minute`: 0 up to and including 59
  # - `second`: 0 up to and including 60
  # - `nanosecond`: 0 up to but excluding 1 000 000 000
  #
  # If any of the arguments are out of bounds, an `Option.None` is returned.
  #
  # The `nanosecond` argument specifies the number of nanoseconds past the
  # second.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Time)
  #
  # let time = Time
  #   .new(hour: 12, minute: 30, second: 0, nanosecond: 0)
  #   .or_panic_with('the Time is invalid')
  #
  # time.hour # => 12
  # ```
  fn pub inline static new(
    hour: Int,
    minute: Int,
    second: Int,
    nanosecond: Int,
  ) -> Option[Time] {
    if
      hour >= 0
        and hour <= 23
        and minute >= 0
        and minute <= 59
        and second >= 0
        and second <= 60
        and nanosecond >= 0
        and nanosecond < 1_000_000_000
    {
      Option.Some(new_unchecked(hour, minute, second, nanosecond))
    } else {
      Option.None
    }
  }

  fn inline static new_unchecked(
    hour: Int,
    minute: Int,
    second: Int,
    nanosecond: Int,
  ) -> Time {
    Time(bits: (nanosecond << 17) | (hour << 12) | (minute << 6) | second)
  }

  # Returns the hour of the day in the range `0` to `23`.
  fn pub inline hour -> Int {
    @bits >> 12 & 0x1F
  }

  # Returns the minute of the hour in the range `0` to `59`.
  fn pub inline minute -> Int {
    @bits >> 6 & 0x3F
  }

  # Returns the number of seconds in the range `0` to `59`.
  fn pub inline second -> Int {
    @bits & 0x3F
  }

  # Returns the number of nanoseconds after the second.
  fn pub inline nanosecond -> Int {
    @bits >> 17
  }
}

impl Equal for Time {
  fn pub ==(other: Time) -> Bool {
    @bits == other.bits
  }
}

impl Format for Time {
  fn pub fmt(formatter: mut Formatter) {
    let hour = hour.to_string.pad_start(with: '0', chars: 2)
    let min = minute.to_string.pad_start(with: '0', chars: 2)
    let secs = second.to_string.pad_start(with: '0', chars: 2)
    let sub = nanosecond

    formatter.write('${hour}:${min}:${secs}')

    if sub > 0 {
      formatter.write('.')
      (sub / MICROS_PER_SEC).fmt(formatter)
    }
  }
}

# A date and time based on the Gregorian calendar.
#
# Internally the time is represented as the number of seconds since the Unix
# epoch, excluding leap seconds.
#
# `DateTime` is based on the Gregorian calendar, and doesn't support additional
# calendars such as the Julian calendar.
#
# If you want to measure the duration between two events, it's best to use the
# `Instant` type, as it's not affected by external factors such as clock
# adjustments and leap seconds.
type pub copy DateTime {
  let @date: Date
  let @time: Time
  let @utc_offset: Int

  # Returns a new `DateTime` using the given components.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Date, DateTime, Time)
  #
  # let date = Date.new(year: 1992, month: 8, day: 21).get
  # let time = Time.new(hour: 12, minute: 15, second: 30, nanosecond: 0).get
  #
  # DateTime.new(date, time, utc_offset: 3600)
  # ```
  fn pub inline static new(
    date: Date,
    time: Time,
    utc_offset: Int,
  ) -> DateTime {
    DateTime(date: date, time: time, utc_offset: utc_offset)
  }

  # Returns a new `DateTime` representing the current time using the system's
  # local time.
  #
  # # Examples
  #
  # ```inko
  # import std.time (DateTime)
  #
  # DateTime.local
  # ```
  fn pub static local -> DateTime {
    let raw = sys.local_time

    DateTime(
      date: Date.new_unchecked(raw.year, raw.month, raw.day),
      time: Time.new_unchecked(raw.hour, raw.minute, raw.second, raw.nanos),
      utc_offset: raw.offset,
    )
  }

  # Returns a new `DateTime` representing the current system time using UTC as
  # the timezone.
  #
  # # Examples
  #
  # ```inko
  # import std.time (DateTime)
  #
  # DateTime.utc
  # ```
  fn pub static utc -> DateTime {
    let raw = sys.utc_time

    DateTime(
      date: Date.new_unchecked(raw.year, raw.month, raw.day),
      time: Time.new_unchecked(raw.hour, raw.minute, raw.second, raw.nanos),
      utc_offset: 0,
    )
  }

  # Returns a new `DateTime` from a Unix timestamp and UTC offset.
  #
  # The `time` argument is the number of seconds since or before the Unix epoch.
  #
  # If the timestamp is invalid, an `Option.None` is returned.
  #
  # # Example
  #
  # ```inko
  # import std.time (DateTime)
  #
  # DateTime.from_timestamp(time: 1661546853, utc_offset: 0).year # => 2022
  # ```
  fn pub static from_timestamp[T: ToFloat](
    time: ref T,
    utc_offset: Int,
  ) -> Option[DateTime] {
    # This implementation is based on the algorithms as described on
    # http://howardhinnant.github.io/date_algorithms.html, specifically the
    # `civil_from_days()` algorithm.
    #
    # To be truly honest, at the time of writing I didn't fully understand the
    # algorithm, and reading through the linked article made my head spin. But
    # it works, so ship it!
    #
    # Important note: this algorithm works because Inko implements integer
    # divisions as floored divisions (like e.g. Python and Ruby), instead of
    # rounding towards zero (like Rust and C).
    let time = time.to_float
    let epoch_secs = time.to_int + utc_offset
    let epoch_days = (epoch_secs / SECS_PER_DAY) + 719_468
    let era = if epoch_days >= 0 { epoch_days } else { epoch_days - 146_096 }
      / 146_097
    let doe = epoch_days - (era * 146_097)
    let yoe = (doe - (doe / 1460) + (doe / 36_524) - (doe / 146_096)) / 365
    let doy = doe - ((365 * yoe) + (yoe / 4) - (yoe / 100))
    let mp = ((5 * doy) + 2) / 153
    let day = doy - ((153 * mp) + 2 / 5) + 1
    let month = if mp < 10 { mp + 3 } else { mp - 9 }
    let mut year = yoe + (era * 400)

    if month <= 2 { year += 1 }

    # The number of seconds since the start of the day.
    let mut day_secs = epoch_secs - ((epoch_secs / SECS_PER_DAY) * SECS_PER_DAY)
    let second = day_secs % 60
    let minute = (day_secs % SECS_PER_HOUR) / 60
    let hour = day_secs / SECS_PER_HOUR
    let nsec = (time.fractional * NANOS_PER_SEC).to_int

    Option.Some(
      DateTime(
        date: try Date.new(year, month, day),
        time: try Time.new(hour, minute, second, nsec),
        utc_offset: utc_offset,
      ),
    )
  }

  # Parses a `DateTime` according to a format string loosely based on the
  # `strftime(2)` format strings.
  #
  # The input is any type that implements `std.string.Bytes`, such as the
  # `String` and `ByteArray` types.
  #
  # The `locale` argument is a type that implements `std.locale.Locale` and is
  # used for locale-aware parsing, such as when parsing the names of the months.
  #
  # # Format sequences
  #
  # The `format` argument contains a "format string" that specifies how the
  # input is to be parsed. This `String` can contain both regular characters to
  # parse as-is, and special format sequences. These sequences start with `%`
  # followed by one or more characters and determine how the input is to be
  # parsed. The following sequences are supported:
  #
  # |=
  # | Sequence
  # | Examples
  # | Description
  # |-
  # | `%Y`
  # | -1234, 0001, 1970, 2024
  # | The year, zero-padded to four digits, optionally starting with a `-` to
  #   signal a year before year zero.
  # |-
  # | `%y`
  # | 05, 10, 25
  # | The year, zero-padded to two digits. For values between 69 and 99, the
  #   year is interpreted as a year in the 19th century (e.g. 85 is 1985). For
  #   values between 0 and 69 the year is interpreted as a year in the 20th
  #   century.
  # |-
  # | `%m`
  # | 01, 12
  # | The month of the year (01-12), zero-padded to two digits.
  # |-
  # | `%d`
  # | 01, 31
  # | The day of the month (01-31), zero-padded to two digits.
  # |-
  # | `%H`
  # | 01, 12, 23
  # | The hour of the day (00-23), zero-padded to two digits.
  # |-
  # | `%M`
  # | 01, 12, 59
  # | The minute of the hour (00-59), zero-padded to two digits.
  # |-
  # | `%S`
  # | 01, 12, 59, 60
  # | The second of the hour (00-60), zero-padded to two digits. A value of 60
  #   is supported to account for leap seconds.
  # |-
  # | `%f`
  # | .123
  # | A dot followed by up to three digits representing the number of
  #   milliseconds past the second. This value is not padded.
  # |-
  # | `%z`
  # | +0200, +02:30, -0200, -02:00, Z
  # | The UTC offset in the format `[SIGN][HH]:[MM]`, `[SIGN][HH][MM]` or a
  #   literal `Z` where `[SIGN]` is either `+` or `-`, `[HH]` the amount of
  #   hours and `[MM]` the amount of minutes. Both the hours and minutes are
  #   zero-padded to two digits.
  # |-
  # | `%Z`
  # | +0200, +02:30, -0200, -02:00, UT, GMT
  # | The same as `%z` but supports `UT` and `GMT` instead of `Z` for UTC
  #   offsets of zero.
  # |-
  # | `%b`
  # | Jan
  # | The locale-aware abbreviated name of the month. For locales that don't use
  #   abbreviated names, this is an alias for `%B`.
  # |-
  # | `%B`
  # | January
  # | The locale-aware full name of the month.
  # |-
  # | `%a`
  # | Mon
  # | The abbreviated name of the day of the week. Parsed values don't affect
  #   the resulting `DateTime`.
  # |-
  # | `%A`
  # | Monday
  # | The full name of the day of the week. Parsed values don't affect the
  #   resulting `DateTime`.
  # |-
  # | `%%`
  # | %
  # | A literal `%`.
  #
  # Certain sequences such as `%a` don't influence/affect the resulting date, as
  # it's not possible to derive a meaningful value from them (e.g. what date is
  # "Monday, December 2024"?). Instead, these sequences are meant for skipping
  # over values in the input stream when those values aren't statically known
  # (e.g. the day of the week).
  #
  # Sequences that match locale-aware data such as `%b` and `%A` are all case
  # sensitive.
  #
  # # Examples
  #
  # Parsing an ISO 8601 date:
  #
  # ```inko
  # import std.time (DateTime)
  # import std.locale.en (Locale)
  #
  # let dt = DateTime
  #   .parse(
  #     input: '2024-11-04 12:45:12 -02:45',
  #     format: '%Y-%m-%d %H:%M:%S %z',
  #     locale: Locale.new,
  #   )
  #   .or_panic_with('the input is invalid')
  #
  # dt.year   # => 2024
  # dt.month  # => 11
  # dt.hour   # => 12
  # dt.second # => 45
  # ```
  #
  # Parsing a date in Japanese:
  #
  # ```inko
  # import std.time (DateTime)
  # import std.locale.ja (Locale)
  #
  # let dt = DateTime
  #   .parse(
  #     input: '2023年12月31日',
  #     format: '%Y年%B%d日',
  #     locale: Locale.new,
  #   )
  #   .or_panic_with('the input is invalid')
  #
  # dt.year  # => 2023
  # dt.month # => 12
  # dt.day   # => 31
  # ```
  fn pub static parse[T: Bytes, L: Locale](
    input: ref T,
    format: String,
    locale: ref L,
  ) -> Option[DateTime] {
    if input.size == 0 or format.size == 0 { return Option.None }

    let mut inp_idx = 0
    let mut fmt_idx = 0
    let mut year = 0
    let mut mon = 1
    let mut day = 1
    let mut hour = 0
    let mut min = 0
    let mut sec = 0
    let mut nsec = 0
    let mut off = 0

    loop {
      match format.get(fmt_idx) {
        case Ok(PERCENT) -> {
          fmt_idx += 1

          match format.get(fmt_idx) {
            case Ok(PERCENT) if input.get(inp_idx).or(-1) == PERCENT -> {
              fmt_idx += 1
              inp_idx += 1
            }
            case Ok(PERCENT) -> return Option.None
            case Ok(what) -> {
              fmt_idx += 1
              inp_idx += match what {
                case UPPER_Y -> {
                  let neg = match input.get(inp_idx) {
                    case Ok(MINUS) -> {
                      inp_idx += 1
                      true
                    }
                    case _ -> false
                  }

                  match try four_digits(input, inp_idx) {
                    case v if neg -> year = v.opposite
                    case v -> year = v
                  }

                  4
                }
                case LOWER_Y -> {
                  match try two_digits(input, inp_idx) {
                    case v if v <= 69 -> year = 2000 + v
                    case v -> year = 1900 + v
                  }

                  2
                }
                case LOWER_M -> {
                  mon = try two_digits(input, inp_idx)
                  2
                }
                case LOWER_D -> {
                  day = try two_digits(input, inp_idx)
                  2
                }
                case UPPER_H -> {
                  hour = try two_digits(input, inp_idx)
                  2
                }
                case UPPER_M -> {
                  min = try two_digits(input, inp_idx)
                  2
                }
                case UPPER_S -> {
                  sec = try two_digits(input, inp_idx)
                  2
                }
                case LOWER_B -> {
                  let idx_len = try locale.parse_short_month(input, inp_idx)

                  mon = idx_len.0 + 1
                  idx_len.1
                }
                case UPPER_B -> {
                  let idx_len = try locale.parse_full_month(input, inp_idx)

                  mon = idx_len.0 + 1
                  idx_len.1
                }
                case LOWER_A -> {
                  match try locale.parse_short_day_of_week(input, inp_idx) {
                    case (_, len) -> len
                  }
                }
                case UPPER_A -> {
                  match try locale.parse_full_day_of_week(input, inp_idx) {
                    case (_, len) -> len
                  }
                }
                case LOWER_F -> {
                  match input.get(inp_idx := inp_idx + 1) {
                    case Ok(DOT) -> {}
                    case _ -> return Option.None
                  }

                  match try digits(input, start: inp_idx, limit: 3) {
                    case (num, len) -> {
                      nsec = num * MICROS_PER_SEC
                      len
                    }
                  }
                }
                case LOWER_Z -> {
                  match input.get(inp_idx) {
                    case Ok(UPPER_Z) -> {
                      inp_idx += 1
                      next
                    }
                    case _ -> {}
                  }

                  let off_idx = try parse_offset(input, inp_idx)

                  off = off_idx.0
                  inp_idx = off_idx.1
                  2
                }
                case UPPER_Z -> {
                  match name_index_at(input, inp_idx, RFC_2822_ZONES) {
                    case Some((_, len)) -> {
                      inp_idx += len
                      next
                    }
                    case _ -> {}
                  }

                  let off_idx = try parse_offset(input, inp_idx)

                  off = off_idx.0
                  inp_idx = off_idx.1
                  2
                }
                case _ -> return Option.None
              }
            }
            case _ -> return Option.None
          }
        }
        case Ok(f) -> {
          match input.get(inp_idx) {
            case Ok(i) if f == i -> {
              fmt_idx += 1
              inp_idx += 1
            }
            case _ -> return Option.None
          }
        }
        case _ -> break
      }
    }

    Option.Some(
      DateTime.new(
        date: try Date.new(year, mon, day),
        time: try Time.new(hour, min, sec, nsec),
        utc_offset: off,
      ),
    )
  }

  # Returns the `Date` component of `self`.
  fn pub inline date -> Date {
    @date
  }

  # Returns the `Time` component of `self`.
  fn pub inline time -> Time {
    @time
  }

  # Returns the UTC offset in seconds.
  fn pub inline utc_offset -> Int {
    @utc_offset
  }

  # Returns `true` if UTC is used as the timezone.
  fn pub inline utc? -> Bool {
    @utc_offset == 0
  }

  # Returns the year.
  #
  # Refer to the documentation of `Date.year` for more details.
  fn pub inline year -> Int {
    @date.year
  }

  # Returns the month.
  #
  # Refer to the documentation of `Date.month` for more details.
  fn pub inline month -> Int {
    @date.month
  }

  # Returns the day.
  #
  # Refer to the documentation of `Date.day` for more details.
  fn pub inline day -> Int {
    @date.day
  }

  # Returns the hour of the day.
  #
  # Refer to the documentation of `Time.hour` for more details.
  fn pub inline hour -> Int {
    @time.hour
  }

  # Returns the minute of the hour.
  #
  # Refer to the documentation of `Time.minute` for more details.
  fn pub inline minute -> Int {
    @time.minute
  }

  # Returns the number of seconds.
  #
  # Refer to the documentation of `Time.second` for more details.
  fn pub inline second -> Int {
    @time.second
  }

  # Returns the number nanoseconds past the second.
  #
  # Refer to the documentation of `Time.sub_second` for more details.
  fn pub inline nanosecond -> Int {
    @time.nanosecond
  }

  # Returns the number of days between `self` and the Unix epoch.
  #
  # Refer to the documentation of `Date.days_since_unix_epoch` for more details.
  fn pub days_since_unix_epoch -> Int {
    @date.days_since_unix_epoch
  }

  # Returns the day of the week from 1 to 7.
  #
  # Refer to the documentation of `Date.day_of_week` for more details.
  fn pub day_of_week -> Int {
    @date.day_of_week
  }

  # Returns the day of the year.
  #
  # Refer to the documentation of `Date.day_of_year` for more details.
  fn pub day_of_year -> Int {
    @date.day_of_year
  }

  # Returns `true` if the current year is a leap year.
  #
  # Refer to the documentation of `Date.leap_year?` for more details.
  fn pub leap_year? -> Bool {
    @date.leap_year?
  }

  # Converts the `DateTime` to another `DateTime` that uses UTC as the
  # timezone.
  fn pub to_utc -> DateTime {
    # Since our input is already valid at this point, this can never fail.
    DateTime.from_timestamp(time: to_float, utc_offset: 0).get
  }

  # Formats `self` as a `String` according to a formatting string.
  #
  # The `how` argument specifies the format sequences to use to format `self`.
  #
  # The `locale` argument is the locale to use for locale-aware formatting, such
  # as the names of the months.
  #
  # # Format sequences
  #
  # The supported sequences are the same as those supported by `DateTime.parse`,
  # with the following notes:
  #
  # - `%z` produces `Z` if the UTC offset is zero, otherwise it produces an
  #   offset in the format `[SIGN][HH]:[MM]`.
  # - `%Z` always produces `GMT` if the UTC offset is zero.
  #
  # If an unsupported sequence is found, it's treated as a literal string.
  #
  # # Examples
  #
  # ```inko
  # import std.locale.en (Locale)
  # import std.time (DateTime)
  #
  # let en = Locale.new
  # let dt = DateTime.new(
  #   date: Date.new(2024, 12, 21).get,
  #   time: Time.new(21, 47, 30, 123_000_000).get,
  #   utc_offset: 3600,
  # )
  #
  # dt.format('%Y-%m-%d %H:%M:%S%f %z', en) # => '2024-12-21 21:47:30.123 +0100'
  # ```
  fn pub format[L: Locale](how: String, locale: ref L) -> String {
    let buf = ByteArray.new
    let mut i = 0
    let max = how.size

    while i < max {
      match how.get(i := i + 1).or_panic {
        case PERCENT -> {
          match how.get(i := i + 1) {
            case Ok(PERCENT) -> buf.push(PERCENT)
            case Ok(UPPER_Y) -> format_digits(buf, year, amount: 4)
            case Ok(LOWER_M) -> format_digits(buf, month, amount: 2)
            case Ok(LOWER_D) -> format_digits(buf, day, amount: 2)
            case Ok(UPPER_H) -> format_digits(buf, hour, amount: 2)
            case Ok(UPPER_M) -> format_digits(buf, minute, amount: 2)
            case Ok(UPPER_S) -> format_digits(buf, second, amount: 2)
            case Ok(LOWER_B) -> buf.append(locale.short_month(month - 1))
            case Ok(UPPER_B) -> buf.append(locale.full_month(month - 1))
            case Ok(LOWER_A) -> {
              buf.append(locale.short_day_of_week(day_of_week - 1))
            }
            case Ok(UPPER_A) -> {
              buf.append(locale.full_day_of_week(day_of_week - 1))
            }
            case Ok(LOWER_F) -> {
              buf.push(DOT)
              format_digits(buf, nanosecond / MICROS_PER_SEC, amount: 1)
            }
            case Ok(LOWER_Z) -> {
              if utc_offset == 0 {
                buf.push(UPPER_Z)
              } else {
                format_offset(buf, utc_offset)
              }
            }
            case Ok(UPPER_Z) -> {
              if utc_offset == 0 {
                buf.append('GMT')
              } else {
                format_offset(buf, utc_offset)
              }
            }
            case Ok(byte) -> {
              buf.push(PERCENT)
              buf.push(byte)
            }
            case _ -> buf.push(PERCENT)
          }
        }
        case byte -> buf.push(byte)
      }
    }

    buf.into_string
  }

  # Formats `self` as an ISO 8601 date and time `String`.
  #
  # This method always uses the English locale.
  #
  # # Examples
  #
  # ```inko
  # import std.time (DateTime)
  #
  # let dt = DateTime.new(
  #   date: Date.new(2024, 12, 21).get,
  #   time: Time.new(21, 47, 30, 123_000_000).get,
  #   utc_offset: 3600,
  # )
  #
  # dt.to_iso8601 # => '2024-12-21T21:47:30.123+01:00'
  # ```
  fn pub to_iso8601 -> String {
    format('%Y-%m-%dT%H:%M:%S%f%z', English.new)
  }

  # Formats `self` as an RFC 2822 date and time `String`.
  #
  # This method always uses the English locale.
  #
  # # Examples
  #
  # ```inko
  # import std.time (DateTime)
  #
  # let dt = DateTime.new(
  #   date: Date.new(2024, 12, 21).get,
  #   time: Time.new(21, 47, 30, 123_000_000).get,
  #   utc_offset: 3600,
  # )
  #
  # dt.to_rfc2822 # => 'Sat, 21 Dec 2024 21:47:30 +01:00'
  # ```
  fn pub to_rfc2822 -> String {
    format('%a, %d %b %Y %H:%M:%S %Z', English.new)
  }

  # Returns the `Duration` since the given `DateTime` relative to `self`.
  #
  # If `earlier` is a time _after_ `self` then the returned `Duration` is a
  # negative value.
  #
  # Note that `DateTime` is not a monotonic time and thus subject to clock
  # adjustments. For measuring the time elapsed (e.g. as part of a benchmark),
  # use `Instant` instead.
  #
  # # Examples
  #
  # ```inko
  # import std.time (DateTime, Duration)
  #
  # let t1 = DateTime.utc
  # let t2 = t1 + Duration.from_secs(2)
  #
  # t2.duration_since(t1) # => Duration.from_secs(2)
  # t1.duration_since(t2) # => Duration.from_secs(-2)
  # ```
  fn pub duration_since(earlier: DateTime) -> Duration {
    Duration.from_secs(to_int - earlier.to_int)
  }
}

impl Clone for DateTime {
  fn pub inline clone -> DateTime {
    self
  }
}

impl Format for DateTime {
  fn pub fmt(formatter: mut Formatter) {
    let offset = if @utc_offset == 0 {
      ' UTC'
    } else {
      let sign = if @utc_offset > 0 { '+' } else { '-' }
      let off = @utc_offset.absolute
      let hh = (off / SECS_PER_HOUR).to_string.pad_start(with: '0', chars: 2)
      let mm = (off % SECS_PER_HOUR / SECS_PER_MIN).to_string.pad_start(
        with: '0',
        chars: 2,
      )

      ' ${sign}${hh}${mm}'
    }

    @date.fmt(formatter)
    formatter.write(' ')
    @time.fmt(formatter)
    formatter.write(offset)
  }
}

impl ToInt for DateTime {
  # Returns the number of seconds since the Unix epoch in UTC.
  #
  # This value will be negative if `self` is a `DateTime` before the Unix
  # epoch.
  fn pub to_int -> Int {
    let days = days_since_unix_epoch
    let days_sec = days.absolute * SECS_PER_DAY
    let time_sec = (@time.hour * SECS_PER_HOUR)
      + (@time.minute * SECS_PER_MIN)
      + @time.second
    let timestamp = if days < 0 {
      0 - (days_sec - time_sec)
    } else {
      days_sec + time_sec
    }

    # Timestamps are always in UTC, not in the local time.
    timestamp - @utc_offset
  }
}

impl ToFloat for DateTime {
  # Returns the timestamp since the Unix epoch, the including fractional
  # seconds.
  fn pub to_float -> Float {
    to_int.to_float + (nanosecond.to_float / NANOS_PER_SEC)
  }
}

impl Add[Duration, DateTime] for DateTime {
  # Adds the given `Duration` to `self`, returning the result as a new
  # `DateTime`.
  #
  # # Panics
  #
  # This method may panic if the result can't be expressed as a `DateTime` (e.g.
  # the year is too great).
  fn pub +(other: Duration) -> DateTime {
    let timestamp = to_float + other.to_secs

    DateTime.from_timestamp(timestamp, utc_offset: @utc_offset).get
  }
}

impl Subtract[Duration, DateTime] for DateTime {
  # Subtracts the given `Duration` from `self`, returning the result as a new
  # `DateTime`.
  #
  # # Panics
  #
  # This method may panic if the result can't be expressed as a `DateTime` (e.g.
  # the year is too great).
  fn pub -(other: Duration) -> DateTime {
    let timestamp = to_float - other.to_secs

    DateTime.from_timestamp(timestamp, utc_offset: @utc_offset).get
  }
}

impl Compare for DateTime {
  fn pub cmp(other: ref DateTime) -> Ordering {
    to_float.cmp(other.to_float)
  }
}

impl Equal for DateTime {
  fn pub inline ==(other: ref DateTime) -> Bool {
    @date == other.date
      and @time == other.time
      and @utc_offset == other.utc_offset
  }
}

# A type which can be converted to an `Instant`
#
# This is useful when you want create a deadline that supports both `Instant`
# and `Duration` as an input.
trait pub ToInstant {
  # Converts `self` into an `Instant`.
  fn pub to_instant -> Instant
}

# A monotonically increasing clock.
#
# The clock is measured in nanoseconds since an unspecified point in time. This
# means the maximum time span we can represent is roughly 292 years. Operations
# producing values greater than this range will panic.
#
# Unlike a system clock a monotonic clock never decreases, making it useful for
# tasks such as measuring the execution time of a block of code.
#
# The clock used for `Instant` values _doesn't_ continue ticking when the system
# is suspended.
#
# An `Instant` can never represent a negative time (e.g. -5).
type pub copy Instant {
  let @nanos: Int

  # Returns a new `Instant` representing the current time.
  fn pub inline static new -> Instant {
    Instant(sys.monotonic_time)
  }

  # Returns a `Duration` measuring the time elapsed since the point in time
  # that `self` represents.
  #
  # # Panics
  #
  # This method panics if the duration can't be expressed in nanoseconds.
  #
  # # Examples
  #
  # Obtaining the time elapsed:
  #
  # ```inko
  # import std.process
  # import std.time (Duration, Instant)
  #
  # let start = Instant.new
  #
  # process.sleep(Duration.from_secs(1))
  #
  # start.elapsed.to_secs >= 1.0 # => true
  # ```
  fn pub inline elapsed -> Duration {
    Duration(sys.monotonic_time - @nanos)
  }

  # Returns a `Duration` measuring the time remaining until reaching `self`.
  #
  # If `self` is in the past, the `Duration` represents a negative duration.
  #
  # # Examples
  #
  # ```inko
  # import std.time (Duration, Instant)
  #
  # let time = Instant.new + Duration.from_secs(5)
  #
  # time.remaining # => Duration.from_secs(5)
  # ```
  fn pub inline remaining -> Duration {
    Duration(@nanos - sys.monotonic_time)
  }
}

impl ToInstant for Instant {
  fn pub inline to_instant -> Instant {
    clone
  }
}

impl Clone for Instant {
  fn pub inline clone -> Instant {
    Instant(@nanos)
  }
}

impl ToInt for Instant {
  fn pub inline to_int -> Int {
    @nanos.to_int
  }
}

impl ToFloat for Instant {
  fn pub inline to_float -> Float {
    @nanos.to_float
  }
}

impl Add[Duration, Instant] for Instant {
  fn pub inline +(other: Duration) -> Instant {
    let nanos = @nanos + other.nanos

    if nanos < 0 { negative_time_error(nanos) }

    Instant(nanos)
  }
}

impl Subtract[Duration, Instant] for Instant {
  fn pub inline -(other: Duration) -> Instant {
    let nanos = @nanos - other.nanos

    if nanos < 0 { negative_time_error(nanos) }

    Instant(nanos)
  }
}

impl Compare for Instant {
  fn pub inline cmp(other: ref Instant) -> Ordering {
    @nanos.cmp(other.nanos)
  }
}

impl Equal for Instant {
  fn pub inline ==(other: ref Instant) -> Bool {
    @nanos == other.nanos
  }
}

impl Format for Instant {
  fn pub fmt(formatter: mut Formatter) {
    formatter.write('+${@nanos}')
  }
}
