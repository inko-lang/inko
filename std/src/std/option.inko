# Optional values.
#
# The `Optional` value represents an optional value. An `Option` is either a
# `Some`, indicating the presence of a value, or a `None`, indicating the lack
# of a value.
#
# Optional values differ from nullable/nilable types in that they can be nested.
# That is, `Option[Option[T]]` and `Option[T]` are two different types, but
# `T | null` and `T | null | null` are the same.
import std::clone::Clone
import std::cmp::Equal
import std::fmt::(Format, Formatter)
import std::process::(panic)

# An optional value.
#
# An `Option` is is either a `Some` containing a value, or a `None` that doesn't
# contain a value.
class pub enum Option[T] {
  # A value of type `T`.
  case Some(T)

  # The lack of a value.
  case None

  # Returns an optional immutable reference to the wrapped value.
  #
  # # Examples
  #
  #     Option.Some(10).as_ref # => Option.Some(ref 10)
  #     Option.None.as_ref     # => Option.None
  fn pub as_ref -> Option[ref T] {
    match self {
      case Some(v) -> Option.Some(v)
      case None -> Option.None
    }
  }

  # Returns the wrapped value.
  #
  # This method panics when used with a `None`.
  #
  # # Examples
  #
  #     Option.Some(10).unwrap # => 10
  fn pub move unwrap -> T {
    match self {
      case Some(v) -> v
      case _ -> panic("Option.unwrap can't unwrap a None")
    }
  }

  # Returns the wrapped value, triggering a panic with a custom message for a
  # `None`.
  #
  # # Examples
  #
  #     Option.Some(10).expect('a number must be present') # => 10
  fn pub move expect(message: String) -> T {
    match self {
      case Some(v) -> v
      case _ -> panic(message)
    }
  }

  # Returns the wrapped value for a `Some`, or the argument for a `None`.
  #
  # # Examples
  #
  #     Option.Some(10).unwrap_or(0) # => 10
  #     Option.None.unwrap_or(0)     # => 0
  fn pub move unwrap_or(default: T) -> T {
    match self {
      case Some(v) -> v
      case None -> default
    }
  }

  # Returns the wrapped value for a `Some`, or calls the closure and returns its
  # value.
  #
  # # Examples
  #
  #     Option.Some(10).unwrap_or_else fn { 0 } # => 10
  #     Option.None.unwrap_or_else fn { 0 }     # => 0
  fn pub move unwrap_or_else(block: fn -> T) -> T {
    match self {
      case Some(v) -> v
      case None -> block.call
    }
  }

  # Maps an `Option[T]` to an `Option[R]` by wrapping the value returned by
  # the provided closure.
  #
  # The closure is to return a value to be wrapped in a Some. If used on a
  # `None`, `None` itself is returned.
  #
  # # Examples
  #
  # Mapping an Option to a new Option:
  #
  #     Option.Some(10).map fn (num) { num * 2 } # => Option.Some(20)
  #
  # Mapping a None:
  #
  #     Option.None.map fn (x) { x * 2 } # => Option.None
  fn pub move map[R](block: fn (T) -> R) -> Option[R] {
    match self {
      case Some(v) -> Option.Some(block.call(v))
      case None -> Option.None
    }
  }

  # Maps an `Option[T]` to an `Option[R]` using the `Option` returned by the
  # provided closure.
  #
  # The closure is to return a new `Option`. If used on a `None`, `None` itself
  # is returned.
  #
  # This process is sometimes referred to as a "flat map". Inko uses the name
  # "then" because this reads more nicely when chaining multiple instances of
  # this method together.
  fn pub move then[R](block: fn (T) -> Option[R]) -> Option[R] {
    match self {
      case Some(v) -> block.call(v)
      case None -> Option.None
    }
  }

  # Calls the supplied block if `self` is a None, returning the Option provided
  # by the `block` argument.
  #
  # If `self` is a Some, the Some itself is returned.
  fn pub move else(block: fn -> Option[T]) -> Option[T] {
    if some? { self } else { block.call }
  }

  # Zips `self` with another `Option`.
  #
  # If both `Option` values are a `Some`, this method returns a `Some`
  # containing a tuple of both values. If either is a `None`, `None` is
  # returned.
  fn pub move zip[O](other: Option[O]) -> Option[(T, O)] {
    match self {
      case Some(ours) -> match other {
        case Some(theirs) -> Option.Some((ours, theirs))
        case _ -> Option.None
      }
      case _ -> Option.None
    }
  }

  # Returns `true` for a Some, `false` otherwise.
  #
  # # Examples
  #
  #     Option.Some(10).some? # => true
  #     Option.None.some?     # => false
  fn pub some? -> Bool {
    match self {
      case Some(_) -> true
      case None -> false
    }
  }

  # Returns `true` for a `None`, `false` otherwise.
  #
  # # Examples
  #
  #     Option.Some(10).none? # => false
  #     Option.None.none?     # => true
  fn pub none? -> Bool {
    match self {
      case Some(_) -> false
      case None -> true
    }
  }
}

impl Option if T: mut {
  # Returns an optional mutable reference to the wrapped value.
  #
  # # Examples
  #
  #     Option.Some([10]).as_mut # => Option.Some(mut [10])
  fn pub mut as_mut -> Option[mut T] {
    match self {
      case Some(v) -> Option.Some(v)
      case None -> Option.None
    }
  }
}

impl Equal[Option[T]] for Option if T: Equal[T] {
  # Returns `true` if `self` and the given `Option` are equal.
  #
  # Two options are considered equal to each other if:
  #
  # 1. They are both None
  # 2. They are both some, and the wrapped values are equal to each other
  #
  # # Examples
  #
  # Comparing two Some values:
  #
  #     Option.Some(10) == Option.Some(10) # => true
  #     Option.Some(10) == Option.Some(20) # => false
  #
  # Comparing a Some and a None:
  #
  #     Option.Some(10) == Option.None # => false
  #
  # Comparing two None values:
  #
  #     Option.None == Option.None # => true
  fn pub ==(other: ref Option[T]) -> Bool {
    match self {
      case Some(ours) -> match other {
        case Some(theirs) -> ours == theirs
        case _ -> false
      }
      case None -> match other {
        case None -> true
        case _ -> false
      }
    }
  }
}

impl Clone[Option[T]] for Option if T: Clone[T] {
  fn pub clone -> Option[T] {
    match self {
      case Some(v) -> Option.Some(v.clone)
      case None -> Option.None
    }
  }
}

impl Format for Option if T: Format {
  fn pub fmt(formatter: mut Formatter) {
    match self {
      case Some(v) -> {
        formatter.write('Some(')
        v.fmt(formatter)
        formatter.write(')')
      }
      case None -> formatter.write('None')
    }
  }
}
