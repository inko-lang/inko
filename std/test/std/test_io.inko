import helpers::(fmt)
import std::io::(Error, Read, Write)
import std::sys::bsd::errors if bsd
import std::sys::linux::errors if linux
import std::sys::mac::errors if mac
import std::test::Tests

class Reader {
  let @index: Int
  let @bytes: ByteArray

  fn static new -> Reader {
    Reader { @index = 0, @bytes = ByteArray.from_array([1, 2, 3]) }
  }
}

impl Read for Reader {
  fn pub mut read(into: mut ByteArray, size: Int) -> Result[Int, Never] {
    let start = @index
    let mut max = @index + size

    if max > @bytes.length { max = @bytes.length }

    while @index < max {
      into.push(@bytes.get(@index))

      @index += 1
    }

    Result.Ok(@index - start)
  }
}

class Writer {
  let @buffer: ByteArray

  fn static new -> Writer {
    Writer { @buffer = ByteArray.new }
  }
}

impl Write for Writer {
  fn pub mut write_bytes(bytes: ref ByteArray) -> Result[Int, Never] {
    bytes.iter.each fn (byte) { @buffer.push(byte) }
    Result.Ok(bytes.length)
  }

  fn pub mut write_string(string: String) -> Result[Int, Never] {
    string.to_byte_array.iter.each fn (byte) { @buffer.push(byte) }
    Result.Ok(string.size)
  }

  fn pub mut flush -> Result[Nil, Never] {
    Result.Ok(nil)
  }
}

fn pub tests(t: mut Tests) {
  t.test('Error.from_os_error') fn (t) {
    t.equal(Error.from_os_error(errors::EPERM), Error.PermissionDenied)
    t.equal(Error.from_os_error(errors::ENOENT), Error.NotFound)
    t.equal(Error.from_os_error(errors::EINTR), Error.Interrupted)
    t.equal(Error.from_os_error(errors::EAGAIN), Error.WouldBlock)
    t.equal(Error.from_os_error(errors::ENOMEM), Error.OutOfMemory)
    t.equal(Error.from_os_error(errors::EACCES), Error.PermissionDenied)
    t.equal(Error.from_os_error(errors::EBUSY), Error.ResourceBusy)
    t.equal(Error.from_os_error(errors::EEXIST), Error.AlreadyExists)
    t.equal(Error.from_os_error(errors::ENOTDIR), Error.NotADirectory)
    t.equal(Error.from_os_error(errors::EISDIR), Error.IsADirectory)
    t.equal(Error.from_os_error(errors::EINVAL), Error.InvalidArgument)
    t.equal(Error.from_os_error(errors::EFBIG), Error.FileTooLarge)
    t.equal(Error.from_os_error(errors::ENOSPC), Error.StorageFull)
    t.equal(Error.from_os_error(errors::ESPIPE), Error.InvalidSeek)
    t.equal(Error.from_os_error(errors::EROFS), Error.ReadOnlyFilesystem)
    t.equal(Error.from_os_error(errors::EPIPE), Error.BrokenPipe)
    t.equal(Error.from_os_error(errors::EDEADLK), Error.Deadlock)
    t.equal(Error.from_os_error(errors::ENAMETOOLONG), Error.InvalidFileName)
    t.equal(Error.from_os_error(errors::ENOTEMPTY), Error.DirectoryNotEmpty)
    t.equal(Error.from_os_error(errors::ETIME), Error.TimedOut)
    t.equal(Error.from_os_error(errors::EADDRINUSE), Error.AddressInUse)
    t.equal(Error.from_os_error(errors::EADDRNOTAVAIL), Error.AddressUnavailable)
    t.equal(Error.from_os_error(errors::ENETDOWN), Error.NetworkDown)
    t.equal(Error.from_os_error(errors::ENETUNREACH), Error.NetworkUnreachable)
    t.equal(Error.from_os_error(errors::ECONNABORTED), Error.ConnectionAborted)
    t.equal(Error.from_os_error(errors::ECONNRESET), Error.ConnectionReset)
    t.equal(Error.from_os_error(errors::EISCONN), Error.AlreadyConnected)
    t.equal(Error.from_os_error(errors::ENOTCONN), Error.NotConnected)
    t.equal(Error.from_os_error(errors::ETIMEDOUT), Error.TimedOut)
    t.equal(Error.from_os_error(errors::ECONNREFUSED), Error.ConnectionRefused)
    t.equal(Error.from_os_error(errors::EHOSTUNREACH), Error.HostUnreachable)
    t.equal(Error.from_os_error(errors::EINPROGRESS), Error.InProgress)
    t.equal(Error.from_os_error(999), Error.Other(999))
  }

  t.test('Error.fmt') fn (t) {
    t.equal(fmt(Error.AddressInUse), 'AddressInUse')
    t.equal(fmt(Error.AddressUnavailable), 'AddressUnavailable')
    t.equal(fmt(Error.AlreadyConnected), 'AlreadyConnected')
    t.equal(fmt(Error.AlreadyExists), 'AlreadyExists')
    t.equal(fmt(Error.BrokenPipe), 'BrokenPipe')
    t.equal(fmt(Error.ConnectionAborted), 'ConnectionAborted')
    t.equal(fmt(Error.ConnectionRefused), 'ConnectionRefused')
    t.equal(fmt(Error.ConnectionReset), 'ConnectionReset')
    t.equal(fmt(Error.Deadlock), 'Deadlock')
    t.equal(fmt(Error.DirectoryNotEmpty), 'DirectoryNotEmpty')
    t.equal(fmt(Error.FileTooLarge), 'FileTooLarge')
    t.equal(fmt(Error.HostUnreachable), 'HostUnreachable')
    t.equal(fmt(Error.InProgress), 'InProgress')
    t.equal(fmt(Error.Interrupted), 'Interrupted')
    t.equal(fmt(Error.InvalidArgument), 'InvalidArgument')
    t.equal(fmt(Error.InvalidFileName), 'InvalidFileName')
    t.equal(fmt(Error.InvalidSeek), 'InvalidSeek')
    t.equal(fmt(Error.IsADirectory), 'IsADirectory')
    t.equal(fmt(Error.NetworkDown), 'NetworkDown')
    t.equal(fmt(Error.NetworkUnreachable), 'NetworkUnreachable')
    t.equal(fmt(Error.NotADirectory), 'NotADirectory')
    t.equal(fmt(Error.NotConnected), 'NotConnected')
    t.equal(fmt(Error.NotFound), 'NotFound')
    t.equal(fmt(Error.OutOfMemory), 'OutOfMemory')
    t.equal(fmt(Error.PermissionDenied), 'PermissionDenied')
    t.equal(fmt(Error.ReadOnlyFilesystem), 'ReadOnlyFilesystem')
    t.equal(fmt(Error.ResourceBusy), 'ResourceBusy')
    t.equal(fmt(Error.StorageFull), 'StorageFull')
    t.equal(fmt(Error.TimedOut), 'TimedOut')
    t.equal(fmt(Error.WouldBlock), 'WouldBlock')
    t.equal(fmt(Error.Other(999)), 'Other(999)')
  }

  t.test('Read.read_all') fn (t) {
    let reader = Reader.new
    let bytes = ByteArray.new
    let size = reader.read_all(bytes).unwrap

    t.equal(size, 3)
    t.equal(bytes, ByteArray.from_array([1, 2, 3]))
  }

  t.test('Write.print') fn (t) {
    let writer = Writer.new

    writer.print('foo').unwrap

    t.equal(writer.buffer, "foo\n".to_byte_array)
  }
}
