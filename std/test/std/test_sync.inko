import std.drop (drop)
import std.fmt (fmt)
import std.process (sleep)
import std.sync (AtomicBool, AtomicInt, Channel, Future, Promise)
import std.test (Tests)
import std.time (Duration)

type async AsyncWriter {
  fn async write(writer: uni Promise[Int]) {
    # This doesn't strictly guarantee the reader is in fact waiting, but it's
    # the closest we can get to that.
    sleep(Duration.from_millis(10))
    writer.set(42)
  }
}

fn int_future -> (uni Future[Int], uni Promise[Int]) {
  Future.new
}

fn pub tests(t: mut Tests) {
  t.test('Future.get', fn (t) {
    match Future.new {
      case (r, w) -> {
        t.true(w.set(42).none?)
        t.equal(r.get, 42)
      }
    }
  })

  t.test('Future.get_until', fn (t) {
    match int_future {
      case (r, _w) -> t.equal(r.get_until(Duration.from_millis(1)), Option.None)
    }

    match int_future {
      case (r, w) -> {
        t.true(w.set(42).none?)
        t.equal(r.get_until(Duration.from_millis(1)), Option.Some(42))
      }
    }
  })

  t.ok('Future.try_get', fn (t) {
    match int_future {
      case (r, w) -> {
        let r = match r.try_get {
          case Ok(_) -> throw 'expected an Error'
          case Error(r) -> r
        }

        t.true(w.set(42).none?)
        t.equal(r.try_get.ok, Option.Some(42))
      }
    }

    Result.Ok(nil)
  })

  t.test('Future.get_until with a dropped Promise', fn (t) {
    match int_future {
      case (r, w) -> {
        drop(w)
        t.true(r.get_until(Duration.from_millis(1)).none?)
      }
    }
  })

  t.test('Future.try_get with a dropped Promise', fn (t) {
    match int_future {
      case (r, w) -> {
        drop(w)
        t.true(r.try_get.error?)
      }
    }
  })

  t.test('Promise.set', fn (t) {
    match int_future {
      case (r, w) -> {
        t.equal(w.set(42), Option.None)
        t.equal(r.get, 42)
      }
    }
  })

  t.test('Promise.set with a dropped Future', fn (t) {
    match int_future {
      case (r, w) -> {
        drop(r)
        t.equal(w.set(42), Option.Some(42))
      }
    }
  })

  t.test('Promise.set wakes up a Future', fn (t) {
    match int_future {
      case (r, w) -> {
        AsyncWriter().write(w)
        t.equal(r.get, 42)
      }
    }
  })

  t.test('Channel.receive', fn (t) {
    let chan = Channel.new

    chan.send(10)
    chan.send(20)

    t.equal(chan.receive, 10)
    t.equal(chan.receive, 20)
  })

  t.test('Channel.receive_until', fn (t) {
    let chan = Channel.new
    let deadline = Duration.from_millis(5)

    chan.send(10)
    chan.send(20)

    t.equal(chan.receive_until(deadline), Option.Some(10))
    t.equal(chan.receive_until(deadline), Option.Some(20))
    t.equal(chan.receive_until(deadline), Option.None)
  })

  t.test('Channel.receive_until after a previous receive timed out', fn (t) {
    let chan: Channel[Int] = Channel.new

    t.equal(chan.receive_until(Duration.from_millis(5)), Option.None)
    chan.send(10)
    chan.send(20)
    t.equal(chan.receive_until(Duration.from_millis(5)), Option.Some(10))
    t.equal(chan.receive_until(Duration.from_millis(5)), Option.Some(20))
  })

  t.test('Channel.receive after a previous receive timed out', fn (t) {
    let chan: Channel[Int] = Channel.new

    t.equal(chan.receive_until(Duration.from_millis(5)), Option.None)
    chan.send(10)
    chan.send(20)
    t.equal(chan.receive, 10)
    t.equal(chan.receive, 20)
  })

  t.test('Channel.clone', fn (t) {
    let chan1 = Channel.new
    let chan2 = chan1.clone
    let deadline = Duration.from_millis(5)

    chan1.send(10)

    t.equal(chan2.receive_until(deadline), Option.Some(10))
    t.equal(chan1.receive_until(deadline), Option.None)
  })

  t.test('AtomicInt.new', fn (t) {
    let val = AtomicInt.new(42)

    t.equal(val.value as Int, 42)
  })

  t.test('AtomicInt.compare_and_swap', fn (t) {
    let val = AtomicInt.new(10)

    t.true(val.compare_and_swap(10, 20))
    t.equal(val.value as Int, 20)

    t.false(val.compare_and_swap(10, 30))
    t.equal(val.value as Int, 20)
  })

  t.test('AtomicInt.store', fn (t) {
    let val = AtomicInt.new(0)

    val.store(10)
    t.equal(val.value as Int, 10)

    val.store(20)
    t.equal(val.value as Int, 20)
  })

  t.test('AtomicInt.load', fn (t) {
    let val = AtomicInt.new(0)

    val.store(10)
    t.equal(val.value as Int, 10)

    val.store(20)
    t.equal(val.value as Int, 20)
  })

  t.test('AtomicInt.add', fn (t) {
    let val = AtomicInt.new(0)

    t.equal(val.add(1), 0)
    t.equal(val.add(2), 1)
    t.equal(val.value as Int, 3)
  })

  t.test('AtomicInt.sub', fn (t) {
    let val = AtomicInt.new(2)

    t.equal(val.sub(1), 2)
    t.equal(val.sub(1), 1)
    t.equal(val.value as Int, 0)
  })

  t.test('AtomicInt.fmt', fn (t) {
    t.equal(fmt(AtomicInt.new(2)), 'AtomicInt(2)')
  })

  t.test('AtomicInt.clone', fn (t) {
    let a = AtomicInt.new(1)
    let b = a.clone

    a.store(2)

    t.equal(a.value as Int, 2)
    t.equal(b.value as Int, 2)
  })

  t.test('AtomicBool.new', fn (t) {
    let val = AtomicBool.new(true)

    t.equal(val.value as Bool, true)
  })

  t.test('AtomicBool.compare_and_swap', fn (t) {
    let val = AtomicBool.new(false)

    t.true(val.compare_and_swap(false, true))
    t.equal(val.value as Bool, true)

    t.false(val.compare_and_swap(false, false))
    t.equal(val.value as Bool, true)
  })

  t.test('AtomicBool.store', fn (t) {
    let val = AtomicBool.new(false)

    val.store(true)
    t.equal(val.value as Bool, true)

    val.store(false)
    t.equal(val.value as Bool, false)
  })

  t.test('AtomicBool.load', fn (t) {
    let val = AtomicBool.new(false)

    val.store(true)
    t.equal(val.value as Bool, true)

    val.store(false)
    t.equal(val.value as Bool, false)
  })

  t.test('AtomicBool.fmt', fn (t) {
    t.equal(fmt(AtomicBool.new(true)), 'AtomicBool(true)')
  })

  t.test('AtomicBool.clone', fn (t) {
    let a = AtomicBool.new(true)
    let b = a.clone

    a.store(false)

    t.equal(a.value as Bool, false)
    t.equal(b.value as Bool, false)
  })
}
