import std.fmt (fmt)
import std.fs (DirectoryEntry, FileType, Time)
import std.test (Tests)
import std.time

fn pub tests(t: mut Tests) {
  t.test('FileType.==', fn (t) {
    t.equal(FileType.File, FileType.File)
    t.equal(FileType.Directory, FileType.Directory)
    t.equal(FileType.SymbolicLink, FileType.SymbolicLink)
    t.equal(FileType.Other, FileType.Other)
    t.not_equal(FileType.File, FileType.Other)
  })

  t.test('FileType.fmt', fn (t) {
    t.equal(fmt(FileType.File), 'File')
    t.equal(fmt(FileType.Directory), 'Directory')
    t.equal(fmt(FileType.SymbolicLink), 'SymbolicLink')
    t.equal(fmt(FileType.Other), 'Other')
  })

  t.test('FileType.file?', fn (t) {
    t.true(FileType.File.file?)
    t.false(FileType.Directory.file?)
    t.false(FileType.SymbolicLink.file?)
    t.false(FileType.Other.file?)
  })

  t.test('FileType.directory?', fn (t) {
    t.false(FileType.File.directory?)
    t.true(FileType.Directory.directory?)
    t.false(FileType.SymbolicLink.directory?)
    t.false(FileType.Other.directory?)
  })

  t.test('FileType.symbolic_link?', fn (t) {
    t.false(FileType.File.symbolic_link?)
    t.false(FileType.Directory.symbolic_link?)
    t.true(FileType.SymbolicLink.symbolic_link?)
    t.false(FileType.Other.symbolic_link?)
  })

  t.test('DirectoryEntry.==', fn (t) {
    let entry1 = DirectoryEntry(path: 'foo'.to_path, type: FileType.File)
    let entry2 = DirectoryEntry(path: 'foo'.to_path, type: FileType.File)
    let entry3 = DirectoryEntry(path: 'bar'.to_path, type: FileType.File)
    let entry4 = DirectoryEntry(path: 'bar'.to_path, type: FileType.Directory)

    t.equal(entry1, entry2)
    t.not_equal(entry1, entry3)
    t.not_equal(entry3, entry4)
  })

  t.test('DirectoryEntry.fmt', fn (t) {
    let entry = DirectoryEntry(path: 'foo'.to_path, type: FileType.File)

    t.equal(fmt(entry), 'DirectoryEntry(path: "foo", type: File)')
  })

  t.test('Time.to_secs', fn (t) {
    t.equal(Time(secs: 2, nanos: 100).to_secs, 2.0000001)
  })

  t.test('Time.to_nanos', fn (t) {
    t.equal(Time(secs: 2, nanos: 100).to_nanos, 2_000_000_100)
  })

  t.test('Time.to_date_time', fn (t) {
    let inp = time.DateTime.new(
      time: time.Time.new(12, 15, 30, 100_000_000).get,
      date: time.Date.new(2025, 9, 19).get,
      utc_offset: 0,
    )
    let time = Time(secs: inp.to_int, nanos: inp.nanosecond)
    let out = time.to_date_time

    t.equal(out.date, inp.date)
    t.equal(out.time.hour, inp.time.hour)
    t.equal(out.time.minute, inp.time.minute)
    t.equal(out.time.second, inp.time.second)
  })
}
