import helpers (VALID_CERT, VALID_KEY)
import std.crypto.pem (PemFile)
import std.crypto.x509 (Certificate, PrivateKey)
import std.drop (drop)
import std.fmt (fmt)
import std.fs.file (ReadOnlyFile)
import std.io (Buffer, Error as IoError)
import std.net.ip (IpAddress)
import std.net.socket (Socket, TcpClient, TcpServer)
import std.net.tls (
  Client, ClientConfig, ClientError, PendingServer, PendingServerError, Server,
  ServerConfig, ServerConfigError, ServerError,
)
import std.sync (Promise)
import std.sys.net (NO_DEADLINE)
import std.test (Tests)
import std.time (Duration, Instant)

# A private key of which the content is invalid.
let INVALID_KEY = '
-----BEGIN PRIVATE KEY-----
MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCyU87LWHj+r1Dj
dZQtA0EWy5TmBjf8Rr5tv4eiSolFYAD1kfyelutxj6mMzgk1cvePpC8npPzZRhwO
/8vGZshRw2D0Vdgq8XN8B6G35S4PhhdgHsvGMSX6s5EBk4Xj730YKR9NaSpyHSIa
LEYcmM3Ryv+iKEwnEPw+/oFHeW56J197dWiLIHEDM8oC82lX5MT/cYm2QG4CsC/7
TCDDT1sEVhkdPB60Scks/Ln5ACsWYInH67AvXWDOaBSebBRR+wFGckgu2kldahIc
e0ejawKa5xgvOX00JmQyigDwqm3NMxjdGOg7y27aNWw8Vbo/oRDif775DvtNIn9C
1nJB8wNjAgMBAAECggEAFuAJo2u7yE6HQvOmvdLF4IgzQgHjNaEs4AQqgHGCRAbJ
fgwrinu+mQh+OI8yKYvlYM+FXaxcOPzgMDZflpmXBxICgmVD/6zjDQfSQWDh3zZA
EmGbmdayfK3YeIogKeSN40cHJRV2pJZtyktf9Ql5ls4CVnPyjNewxoiRidsfBlvc
IoCRjiTD6+MHOQjp4AzwVvbXH1Sr7OsngA4glQJjFlXllyVYQNXBr1sWTVl3TS2L
OQfqYzHWlRtty88z7ExK3D03Jz0PD7qWtTwgJkq1ON+PjgCf7rMvZbVmCoUgX759
LLxY1NE6ogdoRlPyZG3fvSfmxo2PWOqawboZMvirAQKBgQDVwkYwlbY00XuHA4UF
bGwTyk5Yp0/DVSR4jZyAJN6J5xln0JUWYKeps8kxLfDlPgmn6qIaine9Ewf1D9qt
DGr19mzEHzP07OBRo0l34XE5WUMvV4ter3swwmI5w/ysgds7Mz7xA9a69ukF/7SW
C+2RiVW7hJs1pydQw7+NY9YIYwKBgQDVkRv4tvmITtfPpVjAkw0gPIQ2WLw4uIvk
PIX/A58dg952ga+C4MZ7OFtcKI7CF7anr0gCNdGQS6I3SA18YS49U/zycuzPh9v7
lcIMV+R0Wvo2B6QIGJpt7FzfZBXGdv/ft5l+MII3jpoGqGu1K3Ifj/zUrDlUJDQq
ivrkH+CJAQKBgQDFcbCRugfWW9TlDhw1uUNPOGQLwWeMvr10WSHAv82KxZsS6Hh9
dgQIXZeuRIgpx5b1smXPbC1TyRtlgiJ0C29VCCzJLyU3zAEbh18aS3PhDBFhzlRe
vmpkzHgccWqYEU5mLVyrFOeoRN9S+jFdE2F6N8en8MHI2kAXeugZeqk9jwKBgCmV
pMWsEzCIcZs8DekJeR/SyMewRY4h2RNq+YhrUxszJykaHWu1itBJa/io6QtABM/n
4HSVuCWJpJ9xBzc10QQeC33GBPhv8tStF2jB4HkLkfbdTAJLkB5hTMAuw9KuLyqH
-----END PRIVATE KEY-----
'

# A certificate of which the content is invalid.
let INVALID_CERT = '
-----BEGIN CERTIFICATE-----
MIIDvDCCAqSgAwIBAgIUBwbzzsn/P9HmSv1o2tAoIH6ZYE0wDQYJKoZIhvcNAQEL
BQAwaTELMAkGA1UEBhMCTkwxEDAOBgNVBAgMB0V4YW1wbGUxEDAOBgNVBAcMB0V4
YW1wbGUxEDAOBgNVBAoMB0V4YW1wbGUxEDAOBgNVBAsMB2V4YW1wbGUxEjAQBgNV
BAMMCWxvY2FsaG9zdDAeFw0yNDA3MTcxMzA3MDVaFw0yNTA3MTcxMzA3MDVaMGkx
CzAJBgNVBAYTAk5MMRAwDgYDVQQIDAdFeGFtcGxlMRAwDgYDVQQHDAdFeGFtcGxl
MRAwDgYDVQQKDAdFeGFtcGxlMRAwDgYDVQQLDAdleGFtcGxlMRIwEAYDVQQDDAls
b2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCyU87LWHj+
r1DjdZQtA0EWy5TmBjf8Rr5tv4eiSolFYAD1kfyelutxj6mMzgk1cvePpC8npPzZ
-----END CERTIFICATE-----
'

type async DummyServer {
  let @socket: TcpServer
  let @config: ServerConfig

  fn static new -> Result[(DummyServer, Int), String] {
    let conf = recover {
      let conf = try ServerConfig
        .new(certificate(VALID_CERT), private_key(VALID_KEY))
        .map_error(fn (e) { 'failed to create the server config: ${e}' })

      conf.alpn(['foo', 'bar'])
    }

    # We bind to port zero so we get a random port number, such that we don't
    # accidentally pick one that's already in use.
    let sock = recover {
      try TcpServer.new(ip: IpAddress.v4(0, 0, 0, 0), port: 0).map_error(
        fn (e) { 'failed to start the server: ${e}' },
      )
    }
    let addr = try sock.local_address.map_error(fn (e) {
      'failed to get the server address: ${e}'
    })

    Result.Ok((DummyServer(sock, conf), addr.port))
  }

  fn async hello {
    # We may encounter an error such as when the client closes the connection.
    # We want to ignore those so we don't terminate the test suite.
    let _ = @socket.accept.then(fn (sock) {
      Server.new(sock, @config).get.write('hello')
    })
  }

  fn async reply {
    # We may encounter an error such as when the client closes the connection.
    # We want to ignore those so we don't terminate the test suite.
    let _ = @socket.accept.then(fn (sock) {
      let con = Server.new(sock, @config).get
      let bytes = ByteArray.new

      try con.read(into: bytes, size: 32)
      con.write(bytes)
    })
  }
}

type async DummyClient {
  fn async connect(
    output: uni Promise[uni Result[Client[TcpClient], String]],
    port: Int,
  ) {
    output.set(recover client(port, alpn: []))
  }

  fn async write(
    output: uni Promise[uni Result[Client[TcpClient], String]],
    port: Int,
  ) {
    let res = recover {
      client(port, alpn: []).then(fn (s) {
        try s.write('hello').map_error(fn (e) { 'write failed: ${e}' })
        Result.Ok(s)
      })
    }

    output.set(res)
  }

  fn async reply(output: uni Promise[uni Result[String, String]], port: Int) {
    let res = recover {
      client(port, alpn: []).then(fn (s) {
        let buf = ByteArray.new

        try s.read(into: buf, size: 5).map_error(fn (e) { 'read failed: ${e}' })
        Result.Ok(buf.into_string)
      })
    }

    output.set(res)
  }

  fn async alpn(port: Int) {
    client(port, ['foo'])
  }

  fn async invalid_hello(port: Int) {
    let Ok(sock) = TcpClient.new([IpAddress.v4(127, 0, 0, 1)], port) else return
    let _ = sock.write('oops')
  }

  fn client(
    port: Int,
    alpn: ref Array[String],
  ) -> Result[Client[TcpClient], String] {
    let conf = (try client_config).alpn(alpn)
    let sock = try TcpClient.new([IpAddress.v4(127, 0, 0, 1)], port).map_error(
      fn (e) { 'failed to connect: ${e}' },
    )

    Client.new(sock, conf, server: 'localhost').map_error(fn (e) { e.to_string })
  }
}

fn connect(port: Int) -> Result[TcpClient, String] {
  TcpClient.new([IpAddress.v4(127, 0, 0, 1)], port).map_error(fn (e) {
    'failed to connect to the server: ${e}'
  })
}

fn certificate(data: String) -> Certificate {
  let reader = PemFile.new(Buffer.new(data))

  match reader.next {
    case Some(Ok(Certificate(cert))) -> cert
    case _ -> panic('the certificate data is invalid')
  }
}

fn private_key(data: String) -> PrivateKey {
  let reader = PemFile.new(Buffer.new(data))

  match reader.next {
    case Some(Ok(PrivateKey(cert))) -> cert
    case _ -> panic('the private key data is invalid')
  }
}

fn client_config -> Result[ClientConfig, String] {
  ClientConfig.with_certificate(certificate(VALID_CERT)).ok_or(
    'failed to create the client configuration',
  )
}

fn server_config -> Result[ServerConfig, String] {
  ServerConfig.new(certificate(VALID_CERT), private_key(VALID_KEY)).map_error(
    fn (e) { e.to_string },
  )
}

fn dummy_socket -> Result[Socket, String] {
  Socket.stream(ipv6: false).map_error(fn (e) { e.to_string })
}

fn accept(socket: mut TcpServer) -> Result[Server[TcpClient], String] {
  let conf = (try server_config).alpn(['foo', 'bar'])
  let sock = try socket.accept.map_error(fn (e) { 'accept failed: ${e}' })

  Server.new(sock, conf).map_error(fn (e) { e.to_string })
}

fn listener -> Result[(TcpServer, Int), String] {
  let sock = try TcpServer.new(ip: IpAddress.v4(0, 0, 0, 0), port: 0).map_error(
    fn (e) { 'failed to start the server: ${e}' },
  )
  let addr = try sock.local_address.map_error(fn (e) {
    'failed to get the server address: ${e}'
  })

  Result.Ok((sock, addr.port))
}

fn pub tests(t: mut Tests) {
  t.test('ServerConfigError.to_string', fn (t) {
    t.false(ServerConfigError.InvalidCertificate.to_string.empty?)
    t.false(ServerConfigError.InvalidPrivateKey.to_string.empty?)
  })

  t.test('ServerConfigError.fmt', fn (t) {
    t.equal(fmt(ServerConfigError.InvalidCertificate), 'InvalidCertificate')
    t.equal(fmt(ServerConfigError.InvalidPrivateKey), 'InvalidPrivateKey')
  })

  t.test('ServerConfigError.==', fn (t) {
    t.equal(
      ServerConfigError.InvalidCertificate,
      ServerConfigError.InvalidCertificate,
    )
    t.equal(
      ServerConfigError.InvalidPrivateKey,
      ServerConfigError.InvalidPrivateKey,
    )
  })

  t.test('ClientConfig.new', fn (t) { t.true(ClientConfig.new.some?) })

  t.test('ClientConfig.with_certificate with a valid certificate', fn (t) {
    t.true(ClientConfig.with_certificate(certificate(VALID_CERT)).some?)
  })

  t.test('ClientConfig.with_certificate with an invalid certificate', fn (t) {
    t.true(ClientConfig.with_certificate(certificate(INVALID_CERT)).none?)
  })

  t.panic('ClientConfig.alpn when the ClientConfig has multiple owners', fn {
    let conf1 = ClientConfig.new.get

    conf1.clone.alpn(['foo'])
  })

  t.ok('ClientConfig.clone', fn (t) {
    let a = try client_config
    let b = a.clone

    t.equal(a.raw as Int, b.raw as Int)
    Result.Ok(nil)
  })

  t.test('ServerConfig.new with a valid certificate and private key', fn (t) {
    let cert = certificate(VALID_CERT)
    let key = private_key(VALID_KEY)

    t.true(ServerConfig.new(cert, key).ok?)
  })

  t.test('ServerConfig with an invalid certificate', fn (t) {
    let key = private_key(VALID_KEY)

    t.equal(
      ServerConfig.new(certificate(INVALID_CERT), key).error,
      Option.Some(ServerConfigError.InvalidCertificate),
    )
  })

  t.test('ServerConfig with an invalid private key', fn (t) {
    let cert = certificate(VALID_CERT)

    t.equal(
      ServerConfig.new(cert, private_key(INVALID_KEY)).error,
      Option.Some(ServerConfigError.InvalidPrivateKey),
    )
  })

  t.panic('ServerConfig.alpn when the ServerConfig has multiple owners', fn {
    let cert = certificate(VALID_CERT)
    let key = private_key(VALID_KEY)
    let conf1 = ServerConfig.new(cert, key).or_panic

    conf1.clone.alpn(['foo'])
  })

  t.ok('ServerConfig.clone', fn (t) {
    let a = try server_config
    let b = a.clone

    t.equal(b.raw as Int, a.raw as Int)
    Result.Ok(nil)
  })

  t.test('ClientError.to_string', fn (t) {
    t.false(ClientError.InvalidServer.to_string.empty?)
    t.false(ClientError.InvalidHandshake.to_string.empty?)
    t.false(ClientError.TimedOut.to_string.empty?)
  })

  t.test('ClientError.fmt', fn (t) {
    t.equal(fmt(ClientError.InvalidServer), 'InvalidServer')
    t.equal(fmt(ClientError.InvalidHandshake), 'InvalidHandshake')
    t.equal(fmt(ClientError.TimedOut), 'TimedOut')
  })

  t.test('ClientError.==', fn (t) {
    t.equal(ClientError.InvalidServer, ClientError.InvalidServer)
    t.equal(ClientError.InvalidHandshake, ClientError.InvalidHandshake)
    t.equal(ClientError.TimedOut, ClientError.TimedOut)
    t.not_equal(ClientError.InvalidServer, ClientError.InvalidHandshake)
    t.not_equal(ClientError.InvalidHandshake, ClientError.InvalidServer)
    t.not_equal(ClientError.TimedOut, ClientError.InvalidHandshake)
  })

  t.ok('Client.new with a valid DNS name as the server name', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)

    t.equal(Client.new(sock, conf, server: 'localhost').error, Option.None)
    Result.Ok(nil)
  })

  t.ok('Client.new with a valid IP address as the server name', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)

    t.equal(Client.new(sock, conf, server: '127.0.0.1').error, Option.None)
    Result.Ok(nil)
  })

  t.ok('Client.new with an invalid DNS name as the server name', fn (t) {
    let conf = try client_config
    let sock = try dummy_socket

    t.equal(
      Client.new(sock, conf, server: 'what?!').error,
      Option.Some(ClientError.InvalidServer),
    )
    Result.Ok(nil)
  })

  t.ok('Client.new with an invalid IP address as the server name', fn (t) {
    let conf = try client_config
    let sock = try dummy_socket

    t.equal(
      Client.new(sock, conf, server: '1.2.3.4.5').error,
      Option.Some(ClientError.InvalidServer),
    )
    Result.Ok(nil)
  })

  t.ok('Client.with_alpn', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)
    let client = try Client
      .with_alpn(sock, conf, server: 'localhost', alpn: ['bar'])
      .map_error(fn (e) { e.to_string })

    t.equal(client.alpn, Option.Some('bar'))
    Result.Ok(nil)
  })

  t.ok('Client.read', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.hello
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)
    let client = Client.new(sock, conf, server: 'localhost').get
    let bytes = ByteArray.new

    t.equal(client.read(into: bytes, size: 5), Result.Ok(5))
    t.equal(bytes.into_string, 'hello')
    Result.Ok(nil)
  })

  t.ok('Client.write', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)
    let client = Client.new(sock, conf, server: 'localhost').get
    let bytes = ByteArray.new

    t.equal(client.write('ping'), Result.Ok(nil))
    t.equal(client.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.ok('Client.send_file', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)
    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path).map_error(
      fn (e) { e.to_string },
    )
    let client = Client.new(sock, conf, server: 'localhost').get
    let bytes = ByteArray.new

    t.equal(
      try client.send_file(bytes, file).map_error(fn (e) { e.to_string }),
      6,
    )
    t.equal(client.read(into: bytes, size: 6), Result.Ok(6))
    t.equal(bytes.into_string, 'hello\n')
    Result.Ok(nil)
  })

  t.ok('Client.close', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)
    let client = Client.new(sock, conf, server: 'localhost').get

    t.equal(client.close, Result.Ok(nil))
    Result.Ok(nil)
  })

  t.ok('Client.timeout_after=', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)
    let client = Client.new(sock, conf, server: 'localhost').get
    let deadline = Instant.new + Duration.from_secs(1)

    client.timeout_after = deadline
    t.equal(client.socket.socket.deadline, deadline.to_int)

    client.reset_deadline
    t.equal(client.socket.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.ok('Client.alpn without a negotiated ALPN name', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let sock = try connect(port)
    let client = try Client.new(sock, conf, server: 'localhost').map_error(
      fn (e) { e.to_string },
    )

    t.equal(client.alpn, Option.None)
    Result.Ok(nil)
  })

  t.ok('Client.alpn with a negotiated ALPN name', fn (t) {
    let port = match DummyServer.new {
      case Ok((server, port)) -> {
        server.reply
        port
      }
      case Error(e) -> throw e
    }

    let conf = try client_config
    let conf = conf.alpn(['foo'])
    let sock = try connect(port)
    let client = try Client.new(sock, conf, server: 'localhost').map_error(
      fn (e) { e.to_string },
    )

    t.equal(client.alpn, Option.Some('foo'))
    Result.Ok(nil)
  })

  t.test('ServerError.to_string', fn (t) {
    t.false(ServerError.InvalidHandshake.to_string.empty?)
    t.false(ServerError.TimedOut.to_string.empty?)
  })

  t.test('ServerError.fmt', fn (t) {
    t.equal(fmt(ServerError.InvalidHandshake), 'InvalidHandshake')
    t.equal(fmt(ServerError.TimedOut), 'TimedOut')
  })

  t.test('ServerError.==', fn (t) {
    t.equal(ServerError.InvalidHandshake, ServerError.InvalidHandshake)
    t.equal(ServerError.TimedOut, ServerError.TimedOut)
    t.not_equal(ServerError.InvalidHandshake, ServerError.TimedOut)
    t.not_equal(ServerError.TimedOut, ServerError.InvalidHandshake)
  })

  t.ok('Server.new', fn (t) {
    let (sock, port) = try listener
    let _ = async DummyClient().write(port)

    t.equal(accept(sock).error, Option.None)
    Result.Ok(nil)
  })

  t.ok('Server.close', fn (t) {
    let (sock, port) = try listener
    let out = async DummyClient().connect(port)
    let server = try accept(sock)

    # There's not really a sensible way we can test close_notify handling as
    # it's timing/ordering sensitive, so we just test that the initial call
    # doesn't fail outright.
    t.equal(server.close, Result.Ok(nil))
    t.true(out.get.ok?)

    Result.Ok(nil)
  })

  t.ok('Server.read', fn (t) {
    let (sock, port) = try listener
    let out = async DummyClient().write(port)
    let server = try accept(sock)
    let bytes = ByteArray.new

    t.equal(server.read(into: bytes, size: 5), Result.Ok(5))
    t.equal(bytes.into_string, 'hello')
    t.true(out.get.ok?)

    Result.Ok(nil)
  })

  t.ok('Server.write', fn (t) {
    let (sock, port) = try listener
    let out = async DummyClient().reply(port)
    let server = try accept(sock)

    t.equal(server.write('hello'), Result.Ok(nil))
    t.equal(recover out.get, Result.Ok('hello'))

    Result.Ok(nil)
  })

  t.ok('Server.send_file', fn (t) {
    let (sock, port) = try listener
    let out = async DummyClient().reply(port)
    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path).map_error(
      fn (e) { e.to_string },
    )
    let server = try accept(sock)
    let buf = ByteArray.new

    t.equal(
      try server.send_file(buf, file).map_error(fn (e) { e.to_string }),
      6,
    )
    t.equal(recover out.get, Result.Ok('hello'))

    Result.Ok(nil)
  })

  t.ok('Server.timeout_after=', fn (t) {
    let (sock, port) = try listener
    let _ = async DummyClient().reply(port)
    let server = try accept(sock)
    let deadline = Instant.new + Duration.from_secs(1)

    server.timeout_after = deadline
    t.equal(server.socket.socket.deadline, deadline.to_int)

    server.reset_deadline
    t.equal(server.socket.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.ok('Server.alpn without a negotiated ALPN name', fn (t) {
    let (sock, port) = try listener
    let _ = async DummyClient().reply(port)
    let server = try accept(sock)

    t.equal(server.alpn, Option.None)
    Result.Ok(nil)
  })

  t.ok('Server.alpn with a negotiated ALPN name', fn (t) {
    let (sock, port) = try listener

    DummyClient().alpn(port)

    let server = try accept(sock)

    t.equal(server.alpn, Option.Some('foo'))
    Result.Ok(nil)
  })

  t.test('PendingServerError.to_string', fn (t) {
    t.false(PendingServerError.InvalidHandshake.to_string.empty?)
    t.false(PendingServerError.InvalidClientHello.to_string.empty?)
    t.false(PendingServerError.TimedOut.to_string.empty?)
    t.false(PendingServerError.InvalidHandshake.to_string.empty?)
    t.false(PendingServerError.Read(IoError.BrokenPipe).to_string.empty?)
  })

  t.test('PendingServerError.fmt', fn (t) {
    t.equal(fmt(PendingServerError.InvalidClientHello), 'InvalidClientHello')
    t.equal(fmt(PendingServerError.TimedOut), 'TimedOut')
    t.equal(fmt(PendingServerError.InvalidHandshake), 'InvalidHandshake')
    t.equal(
      fmt(PendingServerError.Read(IoError.BrokenPipe)),
      'Read(BrokenPipe)',
    )
  })

  t.test('PendingServerError.==', fn (t) {
    t.equal(
      PendingServerError.InvalidClientHello,
      PendingServerError.InvalidClientHello,
    )
    t.equal(PendingServerError.TimedOut, PendingServerError.TimedOut)
    t.equal(
      PendingServerError.InvalidHandshake,
      PendingServerError.InvalidHandshake,
    )
    t.equal(
      PendingServerError.Read(IoError.BrokenPipe),
      PendingServerError.Read(IoError.BrokenPipe),
    )

    t.not_equal(
      PendingServerError.InvalidClientHello,
      PendingServerError.TimedOut,
    )
    t.not_equal(
      PendingServerError.TimedOut,
      PendingServerError.InvalidHandshake,
    )
    t.not_equal(
      PendingServerError.InvalidHandshake,
      PendingServerError.TimedOut,
    )
    t.not_equal(
      PendingServerError.Read(IoError.BrokenPipe),
      PendingServerError.Read(IoError.NotFound),
    )
  })

  t.ok('PendingServer.new', fn (t) {
    let (sock, port) = try listener
    let _ = async DummyClient().reply(port)
    let peer = try sock.accept.map_error(fn (e) { e.to_string })

    t.equal(PendingServer.new(peer).error, Option.None)
    Result.Ok(nil)
  })

  t.ok('PendingServer.new with an invalid client hello message', fn (t) {
    let (sock, port) = try listener

    DummyClient().invalid_hello(port)

    let peer = try sock.accept.map_error(fn (e) { e.to_string })

    t.equal(
      PendingServer.new(peer).error,
      Option.Some(PendingServerError.InvalidClientHello),
    )
    Result.Ok(nil)
  })

  t.ok('PendingServer.server_name', fn (t) {
    let (sock, port) = try listener
    let _ = async DummyClient().reply(port)
    let peer = try sock.accept.map_error(fn (e) { e.to_string })
    let serv = try PendingServer.new(peer).map_error(fn (e) { e.to_string })

    t.equal(serv.server_name, Option.Some('localhost'))
    Result.Ok(nil)
  })

  t.ok('PendingServer.into_server', fn (t) {
    let (sock, port) = try listener
    let _ = async DummyClient().reply(port)
    let peer = try sock.accept.map_error(fn (e) { e.to_string })
    let pending = try PendingServer.new(peer).map_error(fn (e) { e.to_string })
    let conf = try server_config

    t.equal(pending.into_server(conf).error, Option.None)
    Result.Ok(nil)
  })

  # This is just a smoke test to ensure the internal state is dropped
  # correctly when `into_server` isn't called.
  t.ok('PendingServer.drop', fn (t) {
    let (sock, port) = try listener
    let _ = async DummyClient().reply(port)
    let peer = try sock.accept.map_error(fn (e) { e.to_string })
    let pending = try PendingServer.new(peer).map_error(fn (e) { e.to_string })

    drop(pending)
    Result.Ok(nil)
  })
}
