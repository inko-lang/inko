import std.drop (Drop, drop)
import std.env
import std.fmt (fmt)
import std.fs.file (ReadOnlyFile)
import std.fs.path (Path)
import std.io (Error)
import std.net.ip (IpAddress, Ipv4Address, Ipv6Address)
import std.net.socket (
  Notifier, Socket, SocketAddress, TcpClient, TcpServer, UdpSocket, UnixAddress,
  UnixClient, UnixDatagram, UnixServer, UnixSocket,
)
import std.string (ToString)
import std.sys.poll (NO_DEADLINE)
import std.test (Tests)
import std.time (Duration, Instant)

type SocketPath {
  let @path: Path

  fn static pair(id: Int) -> (SocketPath, SocketPath) {
    let p1 = env.temporary_directory.join('inko-test-${id}-1.sock')
    let p2 = env.temporary_directory.join('inko-test-${id}-2.sock')
    let _ = p1.remove_file
    let _ = p2.remove_file

    (SocketPath(p1), SocketPath(p2))
  }

  fn static new(id: Int) -> SocketPath {
    let path = env.temporary_directory.join('inko-test-${id}.sock')
    let _ = path.remove_file

    SocketPath(path)
  }
}

impl ToString for SocketPath {
  fn pub to_string -> String {
    @path.to_string
  }
}

impl Drop for SocketPath {
  fn mut drop {
    let _ = @path.remove_file
  }
}

fn pub tests(t: mut Tests) {
  t.test('SocketAddress.new', fn (t) {
    let addr = SocketAddress(ip: IpAddress.v4(127, 0, 0, 1), port: 1234)

    t.equal(addr.ip, IpAddress.V4(Ipv4Address.new(127, 0, 0, 1)))
    t.equal(addr.port, 1234)
  })

  t.test('SocketAddress.==', fn (t) {
    let addr1 = SocketAddress(ip: IpAddress.v4(127, 0, 0, 1), port: 1234)
    let addr2 = SocketAddress(ip: IpAddress.v4(127, 0, 0, 1), port: 4567)

    t.equal(addr1, addr1)
    t.not_equal(addr1, addr2)
  })

  t.test('SocketAddress.to_string', fn (t) {
    t.equal(
      SocketAddress(ip: IpAddress.v4(127, 0, 0, 1), port: 1234).to_string,
      '127.0.0.1:1234',
    )
  })

  t.test('SocketAddress.fmt', fn (t) {
    t.equal(
      fmt(SocketAddress(ip: IpAddress.v4(127, 0, 0, 1), port: 1234)),
      'SocketAddress(ip: 127.0.0.1, port: 1234)',
    )
  })

  t.test('SocketAddress.clone', fn (t) {
    t.equal(
      SocketAddress(ip: IpAddress.v4(127, 0, 0, 1), port: 1234).clone,
      SocketAddress(ip: IpAddress.v4(127, 0, 0, 1), port: 1234),
    )
  })

  t.test('Socket.stream', fn (t) {
    t.true(Socket.stream(ipv6: false).ok?)
    t.true(Socket.stream(ipv6: true).ok?)
  })

  t.test('Socket.datagram', fn (t) {
    t.true(Socket.datagram(ipv6: false).ok?)
    t.true(Socket.datagram(ipv6: true).ok?)
  })

  t.test('Socket.bind', fn (t) {
    let sock = Socket.stream(ipv6: false).get

    t.true(sock.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 0).ok?)
  })

  t.test('Socket.connect', fn (t) {
    let listener = Socket.stream(ipv6: false).get
    let stream1 = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    t.true(stream1.connect(addr.ip, addr.port).ok?)

    let stream2 = Socket.stream(ipv6: false).get

    # connect() may not immediately raise a "connection refused" error, due to
    # connect() being non-blocking. In this case the "connection refused" error
    # is raised on the next operation.
    #
    # Since a connect() _might_ still raise the error right away, we have to
    # both connect and try to use the socket in some way.
    t.true(
      stream2.connect(ip: IpAddress.v4(0, 0, 0, 0), port: 40_000).error?
        or stream2.write('ping').error?,
    )
  })

  t.test('Socket.listen', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    socket.bind(ip: IpAddress.v4(0, 0, 0, 0), port: 0).get
    t.true(socket.listen.ok?)
  })

  t.test('Socket.accept', fn (t) {
    let server = Socket.stream(ipv6: false).get
    let client = Socket.stream(ipv6: false).get

    server.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    server.listen.get

    let addr = server.local_address.get

    t.equal(client.connect(addr.ip, addr.port), Result.Ok(nil))

    let connection = server.accept.get

    t.equal(connection.local_address, Result.Ok(server.local_address.get))
  })

  t.test('Socket.send_to', fn (t) {
    let socket = Socket.datagram(ipv6: false).get

    socket.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get

    let send_to = socket.local_address.get
    let buffer = ByteArray.new

    t.equal(
      socket.send_to('ping', send_to.ip, send_to.port.clone),
      Result.Ok(4),
    )
    t.equal(socket.read(into: buffer, size: 4), Result.Ok(4))
    t.equal(buffer.into_string, 'ping')
  })

  t.ok('Socket.receive_from', fn (t) {
    let listener = try Socket.datagram(ipv6: false)
    let client = try Socket.datagram(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try client.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)

    let send_to = try listener.local_address

    t.equal(
      client.send_to('ping', send_to.ip, send_to.port.clone),
      Result.Ok(4),
    )

    let bytes = ByteArray.new
    let addr = try client.local_address

    t.equal(listener.receive_from(bytes: bytes, size: 4), Result.Ok((4, addr)))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.test('Socket.local_address with an unbound socket', fn (t) {
    let socket = Socket.datagram(ipv6: false).get
    let address = socket.local_address.get

    t.equal(address.ip, IpAddress.v4(0, 0, 0, 0))
    t.equal(address.port, 0)
  })

  t.test('Socket.local_address with a bound socket', fn (t) {
    let socket = Socket.datagram(ipv6: false).get

    socket.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get

    let local_address = socket.local_address.get

    t.equal(local_address.ip, IpAddress.v4(127, 0, 0, 1))
    t.true(local_address.port > 0)
  })

  t.test('Socket.peer_address with a disconnected socket', fn (t) {
    let socket = Socket.datagram(ipv6: false).get

    t.true(socket.peer_address.error?)
  })

  t.test('Socket.peer_address with a connected socket', fn (t) {
    let listener = Socket.stream(ipv6: false).get
    let client = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    t.equal(client.connect(addr.ip, addr.port), Result.Ok(nil))
    t.equal(client.peer_address, Result.Ok(addr))
  })

  t.test('Socket.ttl=', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true((socket.ttl = 10).ok?)
  })

  t.test('Socket.only_ipv6=', fn (t) {
    let socket = Socket.stream(ipv6: true).get

    t.true((socket.only_ipv6 = true).ok?)
  })

  t.test('Socket.no_delay=', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true((socket.no_delay = true).ok?)
    t.true(socket.no_delay?)
  })

  t.test('Socket.broadcast=', fn (t) {
    let socket = Socket.datagram(ipv6: false).get

    t.true((socket.broadcast = true).ok?)
  })

  t.test('Socket.linger=', fn (t) {
    let socket = Socket.stream(ipv6: false).get
    let duration = Duration.from_secs(5)

    t.true((socket.linger = Option.Some(duration)).ok?)
    t.equal(socket.linger, Option.Some(Duration.from_secs(5)))

    t.true((socket.linger = Option.None).ok?)
    t.equal(socket.linger, Option.None)
  })

  t.test('Socket.receive_buffer_size=', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true((socket.receive_buffer_size = 256).ok?)
  })

  t.test('Socket.send_buffer_size=', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true((socket.send_buffer_size = 256).ok?)
  })

  t.test('Socket.keepalive=', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true((socket.keepalive = true).ok?)
  })

  t.test('Socket.keepalive_time=', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true((socket.keepalive_time = Duration.from_secs(30)).ok?)
  })

  t.test('Socket.keepalive_interval=', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true((socket.keepalive_interval = Duration.from_secs(30)).ok?)
  })

  t.test('Socket.reuse_adress=', fn (t) {
    let socket = Socket.datagram(ipv6: true).get

    t.true((socket.reuse_address = true).ok?)
  })

  t.test('Socket.reuse_port=', fn (t) {
    let socket = Socket.datagram(ipv6: true).get

    t.true((socket.reuse_port = true).ok?)
  })

  t.test('Socket.shutdown_read', fn (t) {
    let listener = Socket.stream(ipv6: false).get
    let stream = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    t.equal(stream.connect(addr.ip, addr.port), Result.Ok(nil))
    stream.shutdown_read.get

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes.size, 0)
  })

  t.test('Socket.shutdown_write', fn (t) {
    let listener = Socket.stream(ipv6: false).get
    let stream = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    t.equal(stream.connect(addr.ip, addr.port), Result.Ok(nil))
    stream.shutdown_write.get

    t.true(stream.write('ping').error?)
  })

  t.test('Socket.shutdown shuts down the writing half', fn (t) {
    let listener = Socket.stream(ipv6: false).get
    let stream = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    t.equal(stream.connect(addr.ip, addr.port), Result.Ok(nil))
    stream.shutdown.get

    t.true(stream.write('ping').error?)
  })

  t.test('Socket.shutdown shuts down the reading half', fn (t) {
    let listener = Socket.stream(ipv6: false).get
    let stream = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    t.equal(stream.connect(addr.ip, addr.port), Result.Ok(nil))
    stream.shutdown.get

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes.size, 0)
  })

  t.test('Socket.try_clone', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.true(socket.try_clone.ok?)
  })

  t.test('Socket.read', fn (t) {
    let socket = Socket.datagram(ipv6: false).get

    socket.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get

    let addr = socket.local_address.get
    let bytes = ByteArray.new

    t.equal(socket.send_to('ping', addr.ip, addr.port), Result.Ok(4))
    t.equal(socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.test('Socket.write', fn (t) {
    let listener = Socket.stream(ipv6: false).get
    let stream = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    t.equal(stream.connect(addr.ip, addr.port), Result.Ok(nil))
    stream.write('ping').get

    let connection = listener.accept.get
    let bytes = ByteArray.new

    t.equal(connection.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.test('Socket.flush', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    t.equal(socket.flush, Result.Ok(nil))
  })

  t.test('Socket.timeout_after=', fn (t) {
    let server = Socket.stream(ipv6: false).get

    server.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    server.listen.get
    server.timeout_after = Duration.from_secs(0)

    t.true(server.accept.error?)
  })

  t.test('Socket.timeout_after= with a read after a timeout', fn (t) {
    let server = Socket.stream(ipv6: false).get
    let bytes = ByteArray.new

    server.timeout_after = Duration.from_secs(0)

    t.true(server.connect(ip: IpAddress.v4(192, 0, 2, 0), port: 80).error?)
    t.true(server.read(bytes, size: 32).error?)
  })

  t.test('Socket.reset_deadline', fn (t) {
    let socket = Socket.stream(ipv6: false).get

    socket.timeout_after = Duration.from_secs(10)
    t.true(socket.deadline > 0)

    socket.reset_deadline
    t.equal(socket.deadline, NO_DEADLINE)
  })

  t.test('UdpSocket.new', fn (t) {
    t.true(
      UdpSocket.new(ip: IpAddress.V4(Ipv4Address.new(0, 0, 0, 0)), port: 0).ok?,
    )

    t.true(
      UdpSocket
        .new(ip: IpAddress.V6(Ipv6Address.new(0, 0, 0, 0, 0, 0, 0, 0)), port: 0)
        .ok?,
    )
  })

  t.test('UdpSocket.connect', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let socket1 = UdpSocket.new(ip: ip.clone, port: 0).get
    let socket2 = UdpSocket.new(ip: ip, port: 0).get
    let addr = socket2.local_address.get

    t.true(socket1.connect(addr.ip, addr.port).ok?)
  })

  t.test('UdpSocket.send_to', fn (t) {
    let socket = UdpSocket
      .new(ip: IpAddress.V4(Ipv4Address.new(127, 0, 0, 1)), port: 0)
      .get

    let addr = socket.local_address.get

    t.equal(socket.send_to('ping', addr.ip, addr.port), Result.Ok(4))

    let bytes = ByteArray.new

    t.equal(socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.ok('UdpSocket.receive_from', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let listener = try UdpSocket.new(ip: ip.clone, port: 0)
    let client = try UdpSocket.new(ip: ip, port: 0)
    let addr = try listener.local_address

    try client.send_to('ping', addr.ip, addr.port)

    let bytes = ByteArray.new
    let addr = try client.local_address

    t.equal(listener.receive_from(bytes: bytes, size: 4), Result.Ok((4, addr)))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.test('UdpSocket.local_address', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let socket = UdpSocket.new(ip: ip, port: 0).get
    let local_address = socket.local_address.get

    t.equal(local_address.ip, IpAddress.v4(127, 0, 0, 1))
    t.true(local_address.port > 0)
  })

  t.test('UdpSocket.try_clone', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let socket = UdpSocket.new(ip: ip, port: 0).get

    t.true(socket.try_clone.ok?)
  })

  t.test('UdpSocket.read', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let socket = UdpSocket.new(ip: ip, port: 0).get
    let addr = socket.local_address.get

    t.equal(socket.send_to('ping', addr.ip, addr.port), Result.Ok(4))

    let bytes = ByteArray.new

    t.equal(socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.to_string, 'ping')
  })

  t.test('UdpSocket.write', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let server_socket = UdpSocket.new(ip: ip.clone, port: 0).get
    let client_socket = UdpSocket.new(ip: ip, port: 0).get
    let addr = server_socket.local_address.get

    t.equal(client_socket.connect(addr.ip, addr.port), Result.Ok(nil))
    client_socket.write('ping').get

    let bytes = ByteArray.new

    t.equal(server_socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.test('UdpSocket.flush', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let socket = UdpSocket.new(ip: ip, port: 0).get

    t.equal(socket.flush, Result.Ok(nil))
  })

  t.ok('TcpClient.new', fn (t) {
    let listener = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get
    let client = try TcpClient.new([addr.ip], addr.port)

    t.true(client.socket.no_delay?)
    Result.Ok(nil)
  })

  t.test('TcpClient.new with multiple IP addresses', fn (t) {
    let listener = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get
    let client = TcpClient.new([IpAddress.v4(192, 0, 2, 0), addr.ip], addr.port)

    t.true(client.ok?)
  })

  t.ok('TcpClient.with_timeout', fn (t) {
    let listener = Socket.stream(ipv6: false).get

    listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0).get
    listener.listen.get

    let addr = listener.local_address.get

    {
      let client = try TcpClient.with_timeout(
        [addr.ip],
        addr.port,
        timeout_after: Duration.from_secs(2),
      )

      t.equal(client.socket.deadline, NO_DEADLINE)
    }

    # This address is unroutable and so the connect times out.
    let timed_out = TcpClient.with_timeout(
      [IpAddress.v4(192, 168, 0, 0)],
      addr.port,
      timeout_after: Duration.from_micros(500),
    )

    # If no internet connection is available the error is NetworkDown
    # instead, so we have to account for that.
    t.true(
      match timed_out {
        case Error(TimedOut or NetworkDown) -> true
        case _ -> false
      },
    )

    Result.Ok(nil)
  })

  t.ok('TcpClient.local_address', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)
    let local_addr = try stream.local_address

    t.equal(local_addr.ip, IpAddress.v4(127, 0, 0, 1))
    t.true(local_addr.port > 0)
    Result.Ok(nil)
  })

  t.ok('TcpClient.peer_address', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)
    let peer_addr = try stream.peer_address

    t.equal(peer_addr.ip, addr.ip)
    t.equal(peer_addr.port, addr.port)
    Result.Ok(nil)
  })

  t.ok('TcpClient.read', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)
    let bytes = ByteArray.new
    let client = try listener.accept

    try client.write('ping')
    try stream.read(into: bytes, size: 4)

    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.ok('TcpClient.write', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)
    let connection = try listener.accept
    let bytes = ByteArray.new

    t.equal(stream.write('ping'), Result.Ok(nil))
    t.equal(connection.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.ok('TcpClient.flush', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)

    stream.flush
  })

  t.ok('TcpClient.shutdown_read', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)

    t.equal(stream.shutdown_read, Result.Ok(nil))

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes, ByteArray.new)
    Result.Ok(nil)
  })

  t.ok('TcpClient.shutdown_write', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)

    t.equal(stream.shutdown_write, Result.Ok(nil))
    t.true(stream.write('ping').error?)
    Result.Ok(nil)
  })

  t.ok('TcpClient.shutdown shuts down the writing half', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)

    t.equal(stream.shutdown, Result.Ok(nil))
    t.true(stream.write('ping').error?)
    Result.Ok(nil)
  })

  t.ok('TcpClient.shutdown shuts down the reading half', fn (t) {
    let listener = try Socket.stream(ipv6: false)

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)

    t.equal(stream.shutdown, Result.Ok(nil))

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes, ByteArray.new)
    Result.Ok(nil)
  })

  t.ok('TcpClient.try_clone', fn (t) {
    let listener = Socket.stream(ipv6: false).get

    try listener.bind(ip: IpAddress.v4(127, 0, 0, 1), port: 0)
    try listener.listen

    let addr = try listener.local_address
    let client = try TcpClient.new([addr.ip], addr.port)
    let clone = try client.try_clone

    t.true(clone.socket.no_delay?)
    Result.Ok(nil)
  })

  t.test('TcpServer.new', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(0, 0, 0, 0))

    t.true(TcpServer.new(ip: ip.clone, port: 0).ok?)

    let listener = TcpServer.new(ip: ip, port: 0).get
    let addr = listener.local_address.get

    t.true(TcpServer.new(addr.ip, addr.port).ok?)
  })

  t.ok('TcpServer.accept', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let listener = try TcpServer.new(ip: ip, port: 0)
    let addr = try listener.local_address
    let stream = try TcpClient.new([addr.ip], addr.port)
    let connection = try listener.accept

    t.equal(connection.local_address, stream.peer_address)
    t.true(connection.socket.no_delay?)
    Result.Ok(nil)
  })

  t.ok('TcpServer.accept with an interrupt', fn (t) {
    let srv = try TcpServer.new(IpAddress.v4(127, 0, 0, 1), port: 0)
    let not = srv.notifier.get

    t.true(not.notify)
    t.equal(srv.accept.error, Option.Some(Error.Interrupted))

    Result.Ok(nil)
  })

  t.ok('TcpServer.accept with an interrupt and pending connection', fn (t) {
    let srv = try TcpServer.new(IpAddress.v4(127, 0, 0, 1), port: 0)
    let not = srv.notifier.get
    let addr = try srv.local_address
    let _client = try TcpClient.new([addr.ip], addr.port)

    t.true(not.notify)

    # Depending on the order and timing of events we may observe either of the
    # sources being available or both. So instead of asserting an exact order,
    # we just assert that both expectations are true.
    let res = [srv.accept.error, srv.accept.error]

    t.true(res.contains?(Option.Some(Error.Interrupted)))
    t.true(res.contains?(Option.None))

    Result.Ok(nil)
  })

  t.test('TcpServer.local_address', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let listener = TcpServer.new(ip: ip, port: 0).get
    let addr = listener.local_address.get

    t.equal(addr.ip, IpAddress.v4(127, 0, 0, 1))
    t.true(addr.port > 0)
  })

  t.test('TcpServer.try_clone', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let server = match TcpServer.new(ip: ip, port: 0) {
      case Ok(v) -> v
      case Error(e) -> panic(e.to_string)
    }

    t.true(server.try_clone.ok?)
  })

  t.ok('TcpServer.timeout_after=', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let server = try TcpServer.new(ip: ip, port: 0)
    let deadline = Instant.new + Duration.from_secs(1)

    server.timeout_after = deadline
    t.equal(server.socket.deadline, deadline.to_int)

    server.reset_deadline
    t.equal(server.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.test('UnixAddress.to_path', fn (t) {
    t.equal(UnixAddress('foo.sock').to_path, Option.Some('foo.sock'.to_path))
    t.true(UnixAddress('\0foo').to_path.none?)
    t.true(UnixAddress('').to_path.none?)
  })

  t.test('UnixAddress.to_readable_string', fn (t) {
    t.equal(UnixAddress('foo.sock').to_readable_string, 'foo.sock')
    t.equal(UnixAddress('\0foo').to_readable_string, '@foo')
    t.equal(UnixAddress('').to_readable_string, 'unnamed')
  })

  t.test('UnixAddress.to_string', fn (t) {
    t.equal(UnixAddress('foo.sock').to_string, 'foo.sock')
    t.equal(UnixAddress('\0foo').to_string, '\0foo')
    t.equal(UnixAddress('').to_string, '')
  })

  t.test('UnixAddress.abstract?', fn (t) {
    t.false(UnixAddress('').abstract?)
    t.false(UnixAddress('foo.sock').abstract?)
    t.true(UnixAddress('\0foo').abstract?)
  })

  t.test('UnixAddress.unnamed?', fn (t) {
    t.false(UnixAddress('foo.sock').unnamed?)
    t.false(UnixAddress('\0foo').unnamed?)
    t.true(UnixAddress('').unnamed?)
  })

  t.test('UnixAddress.fmt', fn (t) {
    t.equal(fmt(UnixAddress('foo.sock')), 'foo.sock')
    t.equal(fmt(UnixAddress('\0foo')), '@foo')
    t.equal(fmt(UnixAddress('')), 'unnamed')
  })

  t.test('UnixAddress.clone', fn (t) {
    t.equal(UnixAddress('foo.sock').clone, UnixAddress('foo.sock'))
  })

  t.test('UnixAddress.==', fn (t) {
    t.equal(UnixAddress('a.sock'), UnixAddress('a.sock'))
    t.not_equal(UnixAddress('a.sock'), UnixAddress('b.sock'))
  })

  t.test('UnixSocket.new', fn (t) {
    t.true(UnixSocket.datagram.ok?)
    t.true(UnixSocket.stream.ok?)
  })

  t.test('UnixSocket.bind', fn (t) {
    let socket1 = UnixSocket.stream.get
    let socket2 = UnixSocket.stream.get
    let path = SocketPath.new(t.id)

    t.true(socket1.bind(path.path).ok?)
    t.true(socket2.bind(path.path).error?)

    if env.OS == 'linux' {
      let socket = UnixSocket.stream.get

      t.true(socket.bind('\0inko-test-${t.id}'.to_path).ok?)
    }
  })

  t.ok("UnixSocket.bind with a path that's too long", fn (t) {
    let socket = try UnixSocket.stream
    let path = 'x'.repeat(200) + '.sock'

    t.equal(socket.bind(path.to_path), Result.Error(Error.InvalidArgument))
    Result.Ok(nil)
  })

  t.ok('UnixSocket.bind with an empty path', fn (t) {
    let socket = try UnixSocket.stream
    let expected = if env.OS == 'linux' {
      Result.Ok(nil)
    } else {
      Result.Error(Error.InvalidArgument)
    }

    t.equal(socket.bind(''.to_path), expected)
    Result.Ok(nil)
  })

  t.test('UnixSocket.connect', fn (t) {
    let listener = UnixSocket.stream.get
    let stream = UnixSocket.stream.get
    let path = SocketPath.new(t.id)

    t.true(stream.connect(path.path).error?)

    listener.bind(path.path).get
    listener.listen.get

    t.true(stream.connect(path.path).ok?)

    if env.OS == 'linux' {
      let listener = UnixSocket.stream.get
      let stream = UnixSocket.stream.get
      let addr = '\0inko-test-${t.id}'.to_path

      listener.bind(addr).get
      listener.listen.get
      t.equal(stream.connect(addr), Result.Ok(nil))
    }
  })

  t.test('UnixSocket.listen', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixSocket.stream.get

    socket.bind(path.path).get

    t.true(socket.listen.ok?)
  })

  t.test('UnixSocket.accept', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get
    let stream = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get
    t.equal(stream.connect(path.path), Result.Ok(nil))

    let client = listener.accept.get

    t.equal(client.peer_address, stream.local_address)
  })

  t.test('UnixSocket.send_to', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixSocket.datagram.get

    t.equal(socket.bind(path.path), Result.Ok(nil))
    t.equal(socket.send_to('ping', path.path), Result.Ok(4))

    let bytes = ByteArray.new

    t.equal(socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.ok('UnixSocket.receive_from', fn (t) {
    let pair = SocketPath.pair(t.id)
    let listener = try UnixSocket.datagram
    let client = try UnixSocket.datagram

    t.equal(listener.bind(pair.0.path), Result.Ok(nil))
    t.equal(client.bind(pair.1.path), Result.Ok(nil))
    t.equal(client.send_to('ping', pair.0.path), Result.Ok(4))

    let bytes = ByteArray.new
    let addr = try client.local_address

    t.equal(listener.receive_from(bytes: bytes, size: 4), Result.Ok((4, addr)))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.test('UnixSocket.local_address with an unbound socket', fn (t) {
    let socket = UnixSocket.datagram.get
    let address = socket.local_address.get

    t.equal(address, UnixAddress(''))
  })

  t.test('UnixSocket.local_address with a bound socket', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixSocket.datagram.get

    socket.bind(path.path).get

    t.equal(socket.local_address, Result.Ok(UnixAddress(path.to_string)))
  })

  t.test('UnixSocket.peer_address with a disconnected socket', fn (t) {
    let socket = UnixSocket.datagram.get

    t.true(socket.peer_address.error?)
  })

  t.test('UnixSocket.peer_address with a connected socket', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get
    let client = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get
    t.equal(client.connect(path.path), Result.Ok(nil))

    t.equal(client.peer_address, listener.local_address)
  })

  t.test('UnixSocket.read', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixSocket.datagram.get

    t.equal(socket.bind(path.path), Result.Ok(nil))
    t.equal(socket.send_to('ping', path.path), Result.Ok(4))

    let bytes = ByteArray.new

    t.equal(socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.test('UnixSocket.write', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get
    let stream = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get
    t.equal(stream.connect(path.path), Result.Ok(nil))
    stream.write('ping').get

    let connection = listener.accept.get
    let bytes = ByteArray.new

    t.equal(connection.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.test('UnixSocket.flush', fn (t) {
    let socket = UnixSocket.stream.get

    t.equal(socket.flush, Result.Ok(nil))
  })

  t.test('UnixSocket.receive_buffer_size', fn (t) {
    let socket = UnixSocket.stream.get

    t.true((socket.receive_buffer_size = 256).ok?)
  })

  t.test('UnixSocket.send_buffer_size', fn (t) {
    let socket = UnixSocket.stream.get

    t.true((socket.send_buffer_size = 256).ok?)
  })

  t.test('UnixSocket.shutdown_read', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get
    let stream = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get
    t.equal(stream.connect(path.path), Result.Ok(nil))
    stream.shutdown_read.get

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes, ByteArray.new)
  })

  t.test('UnixSocket.shutdown_write', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get
    let stream = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get
    t.equal(stream.connect(path.path), Result.Ok(nil))
    stream.shutdown_write.get

    t.true(stream.write('ping').error?)
  })

  t.test('UnixSocket.shutdown shuts down the writing half', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get
    let stream = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get
    t.equal(stream.connect(path.path), Result.Ok(nil))
    stream.shutdown.get

    t.true(stream.write('ping').error?)
  })

  t.test('UnixSocket.shutdown shuts down the reading half', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get
    let stream = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get
    t.equal(stream.connect(path.path), Result.Ok(nil))
    stream.shutdown.get

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes, ByteArray.new)
  })

  t.test('UnixSocket.try_clone', fn (t) {
    let socket = UnixSocket.stream.get

    t.true(socket.try_clone.ok?)
  })

  t.test('UnixSocket.timeout_after=', fn (t) {
    let path = SocketPath.new(t.id)
    let server = UnixSocket.stream.get

    server.bind(path.path).get
    server.listen.get
    server.timeout_after = Duration.from_secs(0)

    t.true(server.accept.error?)
  })

  t.test('UnixSocket.reset_deadline', fn (t) {
    let socket = UnixSocket.stream.get

    socket.timeout_after = Duration.from_secs(10)
    t.true(socket.deadline > 0)

    socket.reset_deadline
    t.equal(socket.deadline, NO_DEADLINE)
  })

  t.test('UnixDatagram.new', fn (t) {
    let path = SocketPath.new(t.id)

    t.true(UnixDatagram.new(path.path).ok?)
    t.true(UnixDatagram.new(path.path).error?)
  })

  t.test('UnixDatagram.connect', fn (t) {
    let pair = SocketPath.pair(t.id)
    let _socket1 = UnixDatagram.new(pair.0.path).get
    let socket2 = UnixDatagram.new(pair.1.path).get

    t.true(socket2.connect(pair.0.path).ok?)
  })

  t.test('UnixDatagram.send_to', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixDatagram.new(path.path).get

    t.equal(socket.send_to('ping', path.path), Result.Ok(4))

    let bytes = ByteArray.new

    t.equal(socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.ok('UnixDatagram.receive_from', fn (t) {
    let pair = SocketPath.pair(t.id)
    let listener = try UnixDatagram.new(pair.0.path)
    let client = try UnixDatagram.new(pair.1.path)

    t.equal(client.send_to('ping', pair.0.path), Result.Ok(4))

    let bytes = ByteArray.new
    let addr = try client.local_address

    t.equal(listener.receive_from(bytes: bytes, size: 4), Result.Ok((4, addr)))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.test('UnixDatagram.local_address', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixDatagram.new(path.path).get

    t.equal(socket.local_address, Result.Ok(UnixAddress(path.to_string)))
  })

  t.test('UnixDatagram.try_clone', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixDatagram.new(path.path).get

    t.true(socket.try_clone.ok?)
  })

  t.test('UnixDatagram.read', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixDatagram.new(path.path).get

    t.equal(socket.send_to('ping', address: path.path), Result.Ok(4))

    let bytes = ByteArray.new

    t.equal(socket.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.test('UnixDatagram.write', fn (t) {
    let pair = SocketPath.pair(t.id)
    let server = UnixDatagram.new(pair.0.path).get
    let client = UnixDatagram.new(pair.1.path).get

    t.equal(client.connect(pair.0.path), Result.Ok(nil))

    let bytes = ByteArray.new

    t.equal(client.write('ping'.to_byte_array), Result.Ok(nil))
    t.equal(server.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
  })

  t.test('UnixDatagram.flush', fn (t) {
    let path = SocketPath.new(t.id)
    let socket = UnixDatagram.new(path.path).get

    t.equal(socket.flush, Result.Ok(nil))
  })

  t.test('UnixClient.new', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get

    t.true(UnixClient.new(path.path).ok?)
  })

  t.ok('UnixClient.with_timeout', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    listener.bind(path.path).get
    listener.listen.get

    # Unlike IP sockets there's no unroutable address we can use, so at best we
    # can assert the following doesn't time out. This means this test is mostly
    # a smoke test, unlikely to actually fail unless our runtime is bugged.
    let client = try UnixClient.with_timeout(path.path, Duration.from_secs(5))

    t.equal(client.socket.deadline, NO_DEADLINE)
    Result.Ok(nil)
  })

  t.ok('UnixClient.local_address', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)

    t.equal(stream.local_address, Result.Ok(UnixAddress('')))
    Result.Ok(nil)
  })

  t.ok('UnixClient.peer_address', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)

    t.equal(stream.peer_address, Result.Ok(UnixAddress(path.to_string)))
    Result.Ok(nil)
  })

  t.ok('UnixClient.read', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)
    let connection = try listener.accept

    t.equal(connection.write('ping'), Result.Ok(nil))

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.ok('UnixClient.write', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)
    let connection = try listener.accept
    let bytes = ByteArray.new

    t.equal(stream.write('ping'), Result.Ok(nil))
    t.equal(connection.read(into: bytes, size: 4), Result.Ok(4))
    t.equal(bytes.into_string, 'ping')
    Result.Ok(nil)
  })

  t.ok('UnixClient.flush', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    UnixClient.new(path.path).then(fn (s) { s.flush })
  })

  t.ok('UnixClient.shutdown_read', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)

    t.equal(stream.shutdown_read, Result.Ok(nil))

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes, ByteArray.new)
    Result.Ok(nil)
  })

  t.ok('UnixClient.shutdown_write', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)

    t.equal(stream.shutdown_write, Result.Ok(nil))
    t.true(stream.write('ping').error?)
    Result.Ok(nil)
  })

  t.ok('UnixClient.shutdown shuts down the writing half', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)

    t.equal(stream.shutdown, Result.Ok(nil))
    t.true(stream.write('ping').error?)
    Result.Ok(nil)
  })

  t.ok('UnixClient.shutdown shuts down the reading half', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    let stream = try UnixClient.new(path.path)

    t.equal(stream.shutdown, Result.Ok(nil))

    let bytes = ByteArray.new

    t.equal(stream.read(into: bytes, size: 4), Result.Ok(0))
    t.equal(bytes, ByteArray.new)
    Result.Ok(nil)
  })

  t.ok('UnixClient.try_clone', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixSocket.stream.get

    try listener.bind(path.path)
    try listener.listen

    UnixClient.new(path.path).then(fn (s) { s.try_clone })
  })

  t.test('UnixServer.new', fn (t) {
    let path = SocketPath.new(t.id)

    t.true(UnixServer.new(path.path).ok?)
  })

  t.ok('UnixServer.accept', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = try UnixServer.new(path.path)
    let stream = try UnixClient.new(path.path)
    let connection = try listener.accept

    t.equal(connection.local_address, stream.peer_address)
    Result.Ok(nil)
  })

  t.ok('UnixServer.accept with an interrupt', fn (t) {
    let path = SocketPath.new(t.id)
    let srv = try UnixServer.new(path.path)
    let not = srv.notifier.get

    t.true(not.notify)
    t.equal(srv.accept.error, Option.Some(Error.Interrupted))

    Result.Ok(nil)
  })

  t.ok('UnixServer.accept with an interrupt and pending connection', fn (t) {
    let path = SocketPath.new(t.id)
    let srv = try UnixServer.new(path.path)
    let not = srv.notifier.get
    let _client = try UnixClient.new(path.path)

    t.true(not.notify)

    # Depending on the order and timing of events we may observe either of the
    # sources being available or both. So instead of asserting an exact order,
    # we just assert that both expectations are true.
    let res = [srv.accept.error, srv.accept.error]

    t.true(res.contains?(Option.Some(Error.Interrupted)))
    t.true(res.contains?(Option.None))

    Result.Ok(nil)
  })

  t.test('UnixServer.local_address', fn (t) {
    let path = SocketPath.new(t.id)
    let listener = UnixServer.new(path.path).get
    let addr = listener.local_address.get

    t.equal(addr, UnixAddress(path.to_string))
  })

  t.test('UnixServer.try_clone', fn (t) {
    let path = SocketPath.new(t.id)
    let server = UnixServer.new(path.path).get

    t.true(server.try_clone.ok?)
  })

  t.ok('UnixClient.timeout_after=', fn (t) {
    let path = SocketPath.new(t.id)
    let sock = try UnixServer.new(path.path)
    let deadline = Instant.new + Duration.from_secs(1)

    sock.timeout_after = deadline
    t.equal(sock.socket.deadline, deadline.to_int)

    sock.reset_deadline
    t.equal(sock.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.ok('Socket.send_file', fn (t) {
    let server = try Socket.stream(ipv6: false)
    let client = try Socket.stream(ipv6: false)

    try server.bind(IpAddress.v4(0, 0, 0, 0), port: 0)
    try server.listen

    let addr = try server.local_address
    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path)

    try client.connect(addr.ip, addr.port)

    let con = try server.accept
    let buf = ByteArray.new

    t.equal(try client.send_file(buf, file), 6)
    t.equal(con.read(buf, size: 1024), Result.Ok(6))
    t.equal(buf.to_string, 'hello\n')
    t.equal(file.read_all(buf), Result.Ok(6))
    t.equal(buf.to_string, 'hello\nhello\n')
    Result.Ok(nil)
  })

  t.ok('UdpSocket.send_file', fn (t) {
    let server = try UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 0)
    let client = try UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 0)
    let addr = try server.local_address
    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path)
    let buf = ByteArray.new

    try client.connect(addr.ip, addr.port)

    t.equal(try client.send_file(buf, file), 6)
    t.equal(server.read(buf, size: 1024), Result.Ok(6))
    t.equal(buf.to_string, 'hello\n')
    t.equal(file.read_all(buf), Result.Ok(6))
    t.equal(buf.to_string, 'hello\nhello\n')
    Result.Ok(nil)
  })

  t.ok('UdpSocket.timeout_after=', fn (t) {
    let sock = try UdpSocket.new(IpAddress.v4(0, 0, 0, 0), port: 0)
    let deadline = Instant.new + Duration.from_secs(1)

    sock.timeout_after = deadline
    t.equal(sock.socket.deadline, deadline.to_int)

    sock.reset_deadline
    t.equal(sock.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.ok('TcpClient.send_file', fn (t) {
    let server = try Socket.stream(ipv6: false)

    try server.bind(IpAddress.v4(0, 0, 0, 0), port: 0)
    try server.listen

    let addr = try server.local_address
    let client = try TcpClient.new([addr.ip], addr.port)
    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path)
    let con = try server.accept
    let buf = ByteArray.new

    t.equal(try client.send_file(buf, file), 6)
    t.equal(con.read(buf, size: 1024), Result.Ok(6))
    t.equal(buf.to_string, 'hello\n')
    t.equal(file.read_all(buf), Result.Ok(6))
    t.equal(buf.to_string, 'hello\nhello\n')
    Result.Ok(nil)
  })

  t.ok('TcpClient.timeout_after=', fn (t) {
    let ip = IpAddress.V4(Ipv4Address.new(127, 0, 0, 1))
    let server = try TcpServer.new(ip: ip, port: 0)
    let addr = try server.local_address
    let client = try TcpClient.new([addr.ip], addr.port)
    let deadline = Instant.new + Duration.from_secs(1)

    client.timeout_after = deadline
    t.equal(client.socket.deadline, deadline.to_int)

    client.reset_deadline
    t.equal(client.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.ok('UnixSocket.send_file', fn (t) {
    let path = SocketPath.new(t.id)
    let server = try UnixSocket.stream
    let client = try UnixSocket.stream

    try server.bind(path.path)
    try server.listen

    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path)

    try client.connect(path.path)

    let con = try server.accept
    let buf = ByteArray.new

    t.equal(try client.send_file(buf, file), 6)
    t.equal(con.read(buf, size: 1024), Result.Ok(6))
    t.equal(buf.to_string, 'hello\n')
    t.equal(file.read_all(buf), Result.Ok(6))
    t.equal(buf.to_string, 'hello\nhello\n')
    Result.Ok(nil)
  })

  t.ok('UnixDatagram.send_file', fn (t) {
    let pair = SocketPath.pair(t.id)
    let server = try UnixDatagram.new(pair.0.path)
    let client = try UnixDatagram.new(pair.1.path)
    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path)

    try client.connect(pair.0.path)

    let buf = ByteArray.new

    t.equal(try client.send_file(buf, file), 6)
    t.equal(server.read(buf, size: 1024), Result.Ok(6))
    t.equal(buf.to_string, 'hello\n')
    t.equal(file.read_all(buf), Result.Ok(6))
    t.equal(buf.to_string, 'hello\nhello\n')
    Result.Ok(nil)
  })

  t.ok('UnixDatagram.timeout_after=', fn (t) {
    let path = SocketPath.new(t.id)
    let sock = try UnixDatagram.new(path.path)
    let deadline = Instant.new + Duration.from_secs(1)

    sock.timeout_after = deadline
    t.equal(sock.socket.deadline, deadline.to_int)

    sock.reset_deadline
    t.equal(sock.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.ok('UnixClient.send_file', fn (t) {
    let path = SocketPath.new(t.id)
    let server = try UnixSocket.stream

    try server.bind(path.path)
    try server.listen

    let client = try UnixClient.new(path.path)
    let file = try ReadOnlyFile.new('fixtures/hello.txt'.to_path)
    let con = try server.accept
    let buf = ByteArray.new

    t.equal(try client.send_file(buf, file), 6)
    t.equal(con.read(buf, size: 1024), Result.Ok(6))
    t.equal(buf.to_string, 'hello\n')
    t.equal(file.read_all(buf), Result.Ok(6))
    t.equal(buf.to_string, 'hello\nhello\n')
    Result.Ok(nil)
  })

  t.ok('UnixClient.timeout_after=', fn (t) {
    let path = SocketPath.new(t.id)
    let _server = try UnixServer.new(path.path)
    let client = try UnixClient.new(path.path)
    let deadline = Instant.new + Duration.from_secs(1)

    client.timeout_after = deadline
    t.equal(client.socket.deadline, deadline.to_int)

    client.reset_deadline
    t.equal(client.socket.deadline, NO_DEADLINE)

    Result.Ok(nil)
  })

  t.ok('Notifier.notify', fn (t) {
    let (not, wait) = try Notifier.new
    let buf = ByteArray.new

    t.true(not.notify)
    wait.reader.timeout_after = Duration.from_secs(5)
    t.equal(wait.reader.read(buf, size: 1), Result.Ok(1))

    t.true(not.notify)
    t.true(not.notify)
    wait.reader.timeout_after = Duration.from_secs(5)
    t.equal(wait.reader.read(buf, size: 1), Result.Ok(1))
    t.equal(wait.reader.read(buf, size: 1), Result.Ok(1))

    drop(wait)
    t.false(not.notify)

    Result.Ok(nil)
  })

  t.ok('Waiter.clear', fn (t) {
    let (not, wait) = try Notifier.new
    let buf = ByteArray.new

    not.notify
    wait.clear

    wait.reader.timeout_after = Duration.from_millis(10)
    t.equal(wait.reader.read(buf, size: 1), Result.Error(Error.TimedOut))

    Result.Ok(nil)
  })
}
