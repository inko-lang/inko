import std.fmt (fmt)
import std.int
import std.io (Buffer, Error as IoError)
import std.json (Error, ErrorKind, Json, Number, Parser, PullParser, Type)
import std.test (Tests)

fn parse(input: String) -> Result[Json, Error[IoError]] {
  Json.parse(Buffer.new(input))
}

fn pub tests(t: mut Tests) {
  t.test('ErrorKind.==', fn (t) {
    t.equal(
      ErrorKind.RecursionLimitExceeded(1) as ErrorKind[IoError],
      ErrorKind.RecursionLimitExceeded(1),
    )
    t.equal(
      ErrorKind.InvalidSurrogate as ErrorKind[IoError],
      ErrorKind.InvalidSurrogate,
    )
    t.equal(ErrorKind.Read(IoError.Other(1)), ErrorKind.Read(IoError.Other(1)))

    t.not_equal(
      ErrorKind.RecursionLimitExceeded(1) as ErrorKind[IoError],
      ErrorKind.InvalidControl,
    )
  })

  t.test('ErrorKind.fmt', fn (t) {
    t.equal(
      fmt(ErrorKind.RecursionLimitExceeded(1) as ErrorKind[IoError]),
      'RecursionLimitExceeded(1)',
    )
    t.equal(
      fmt(ErrorKind.InvalidSurrogate as ErrorKind[IoError]),
      'InvalidSurrogate',
    )
    t.equal(fmt(ErrorKind.Read(IoError.Other(1))), 'Read(Other(1))')
  })

  t.test('ErrorKind.to_string', fn (t) {
    t.equal(
      (ErrorKind.RecursionLimitExceeded(1) as ErrorKind[IoError]).to_string,
      'the maximum recursion depth of 1 is exceeded',
    )
    t.equal(
      (ErrorKind.Unexpected('f') as ErrorKind[IoError]).to_string,
      "the character 'f' is unexpected",
    )
  })

  t.test('Error.fmt', fn (t) {
    let err = Error(ErrorKind.Unexpected('f'), offset: 5) as Error[IoError]

    t.equal(fmt(err), 'Error(kind: Unexpected("f"), offset: 5)')
  })

  t.test('Error.==', fn (t) {
    let err1 = Error(ErrorKind.Unexpected('a'), offset: 5) as Error[IoError]
    let err2 = Error(ErrorKind.Unexpected('a'), offset: 5)
    let err3 = Error(ErrorKind.RecursionLimitExceeded(1), offset: 6)

    t.equal(err1, err2)
    t.not_equal(err1, err3)
  })

  t.test('Error.to_string', fn (t) {
    let err = Error(ErrorKind.Unexpected('t'), offset: 5) as Error[IoError]

    t.equal(err.to_string, "the character 't' is unexpected, at byte offset 5")
  })

  t.test('PullParser.object', fn (t) {
    let tests = [
      # Valid input
      ('{}', Result.Ok(nil)),
      (' {}', Result.Ok(nil)),
      ('{ }', Result.Ok(nil)),
      ('{       }', Result.Ok(nil)),
      ('{"k": "v"}', Result.Ok(nil)),
      ('{ "k": "v" }', Result.Ok(nil)),
      ('{   "k": "v" }', Result.Ok(nil)),

      # Invalid input
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
      ('"k": "v"', Result.Error(Error(ErrorKind.Unexpected('"'), offset: 0))),
      ('{,}', Result.Error(Error(ErrorKind.Unexpected(','), offset: 1))),
      ('{', Result.Error(Error(ErrorKind.EndOfInput, offset: 1))),
    ]

    for (inp, res) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).object, res)
    }
  })

  t.test('PullParser.key?', fn (t) {
    let tests = [
      # Valid input
      ('"k":', Result.Ok(true)),
      ('  "k":', Result.Ok(true)),
      (' } ', Result.Ok(false)),

      # Invalid input
      (' , "key": ', Result.Error(Error(ErrorKind.Unexpected(','), offset: 1))),
      (',,', Result.Error(Error(ErrorKind.Unexpected(','), offset: 0))),
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
      (',1', Result.Error(Error(ErrorKind.Unexpected(','), offset: 0))),
      ('1', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
      (']', Result.Error(Error(ErrorKind.Unexpected(']'), offset: 0))),
    ]

    for (inp, res) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).key?, res)
    }
  })

  t.test('PullParser.next_key', fn (t) {
    let tests = [
      # Valid input
      (',10', Result.Ok(nil)),
      ('}', Result.Ok(nil)),

      # Invalid input
      (',', Result.Error(Error(ErrorKind.EndOfInput, offset: 1))),
      (',,', Result.Error(Error(ErrorKind.Unexpected(','), offset: 1))),
      (',}', Result.Error(Error(ErrorKind.Unexpected('}'), offset: 1))),
      ('1', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
    ]

    for (inp, exp) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).next_key, exp)
    }
  })

  t.test('PullParser.key', fn (t) {
    let tests = [
      # Valid input
      ('"a": "b"', Result.Ok('a')),
      (' "a": "b"', Result.Ok('a')),
      ('"a" : "b"', Result.Ok('a')),

      # Invalid input
      ('10: 20', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
      ('}', Result.Error(Error(ErrorKind.Unexpected('}'), offset: 0))),
      (']', Result.Error(Error(ErrorKind.Unexpected(']'), offset: 0))),
    ]

    for (inp, res) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).key, res)
    }
  })
  t.test('PullParser.array', fn (t) {
    let tests = [
      # Valid input
      ('[]', Result.Ok(nil)),
      (' []', Result.Ok(nil)),
      ('[ ]', Result.Ok(nil)),
      ('[       ]', Result.Ok(nil)),
      ('[10]', Result.Ok(nil)),
      ('[ 10 ]', Result.Ok(nil)),
      ('[   10 ]', Result.Ok(nil)),

      # Invalid input
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
      ('10', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
      ('[,]', Result.Error(Error(ErrorKind.Unexpected(','), offset: 1))),
      ('[', Result.Error(Error(ErrorKind.EndOfInput, offset: 1))),
    ]

    for (inp, res) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).array, res)
    }
  })

  t.test('PullParser.array_value?', fn (t) {
    let tests = [
      # Valid input
      ('10', Result.Ok(true)),
      ('  10', Result.Ok(true)),
      (' ] ', Result.Ok(false)),

      # Invalid input
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
    ]

    for (inp, res) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).array_value?, res)
    }
  })

  t.test('PullParser.next_value', fn (t) {
    let tests = [
      # Valid input
      (',10', Result.Ok(nil)),
      (']', Result.Ok(nil)),

      # Invalid input
      (',', Result.Error(Error(ErrorKind.EndOfInput, offset: 1))),
      (',,', Result.Error(Error(ErrorKind.Unexpected(','), offset: 1))),
      (',]', Result.Error(Error(ErrorKind.Unexpected(']'), offset: 1))),
      ('1', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
    ]

    for (inp, exp) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).next_value, exp)
    }
  })

  t.test('PullParser.string', fn (t) {
    let tests = [
      # Valid input
      ('"foo"', Result.Ok('foo')),
      ('"foo bar"', Result.Ok('foo bar')),
      ('"foo\\nbar"', Result.Ok('foo\nbar')),
      ('"foo\\tbar"', Result.Ok('foo\tbar')),
      ('"foo\\rbar"', Result.Ok('foo\rbar')),
      ('"foo\\bbar"', Result.Ok('foo\u{8}bar')),
      ('"foo\\fbar"', Result.Ok('foo\u{C}bar')),
      ('"foo\\"bar"', Result.Ok('foo"bar')),
      ('"foo\\/bar"', Result.Ok('foo/bar')),
      ('"foo\\\\bar"', Result.Ok('foo\\bar')),
      ('"foo\\u005Cbar"', Result.Ok('foo\\bar')),
      ('"foo\\u001Fbar"', Result.Ok('foo\u{1F}bar')),
      ('"\\uD834\\uDD1E"', Result.Ok('\u{1D11E}')),
      ('"\\uE000\\uE000"', Result.Ok('\u{E000}\u{E000}')),
      ('"üê±"', Result.Ok('üê±')),

      # Invalid input
      ('"\0"', Result.Error(Error(ErrorKind.InvalidControl, offset: 1))),
      ('"\n"', Result.Error(Error(ErrorKind.InvalidControl, offset: 1))),
      ('"\t"', Result.Error(Error(ErrorKind.InvalidControl, offset: 1))),
      ('"\r"', Result.Error(Error(ErrorKind.InvalidControl, offset: 1))),
      ('"\u{8}"', Result.Error(Error(ErrorKind.InvalidControl, offset: 1))),
      ('"\u{C}"', Result.Error(Error(ErrorKind.InvalidControl, offset: 1))),
      ('"\\x42"', Result.Error(Error(ErrorKind.Unexpected('x'), offset: 2))),
      ('"\\u1"', Result.Error(Error(ErrorKind.Unexpected('"'), offset: 4))),
      ('"\\u12"', Result.Error(Error(ErrorKind.Unexpected('"'), offset: 5))),
      ('"\\u123"', Result.Error(Error(ErrorKind.Unexpected('"'), offset: 6))),
      (
        '"\\u{XXXX}"',
        Result.Error(Error(ErrorKind.Unexpected('{'), offset: 3)),
      ),
      (
        '"\\uD834\\uE000"',
        Result.Error(Error(ErrorKind.InvalidSurrogate, offset: 1)),
      ),
      (
        '"\\uD834\\uZZZZ"',
        Result.Error(Error(ErrorKind.InvalidSurrogate, offset: 1)),
      ),
      (
        '"\\uDFFF\\uDFFF"',
        Result.Error(Error(ErrorKind.InvalidSurrogate, offset: 1)),
      ),
      ('"eof', Result.Error(Error(ErrorKind.EndOfInput, offset: 4))),
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
      ('1', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
    ]

    for (inp, res) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).string, res)
    }
  })

  t.test('PullParser.int', fn (t) {
    let tests = [
      # Valid input
      ('10', Result.Ok(10)),
      ('  10', Result.Ok(10)),
      ('10.2', Result.Ok(10)),
      ('-10', Result.Ok(-10)),
      ('-10.2', Result.Ok(-10)),
      ('99999999999999999999999999999999999999999999999', Result.Ok(int.MAX)),
      ('-99999999999999999999999999999999999999999999999', Result.Ok(int.MIN)),

      # Invalid input
      ('00', Result.Error(Error(ErrorKind.Unexpected('0'), offset: 1))),
      ('01', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 1))),
      ('a', Result.Error(Error(ErrorKind.Unexpected('a'), offset: 0))),
      ('  a', Result.Error(Error(ErrorKind.Unexpected('a'), offset: 2))),
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
    ]

    for (inp, exp) in tests {
      let parser = PullParser.new(Buffer.new(inp))
      let got = parser.int

      t.equal(got, exp)

      if got.ok? { t.true(parser.buffer.empty?) }
    }
  })

  t.test('PullParser.float', fn (t) {
    let tests = [
      # Valid input
      ('10', Result.Ok(10.0)),
      ('  10', Result.Ok(10.0)),
      ('10.2', Result.Ok(10.2)),
      ('-10', Result.Ok(-10.0)),
      ('-10.2', Result.Ok(-10.2)),
      (
        '99999999999999999999999999999999999999999999999',
        Result.Ok(99999999999999999999999999999999999999999999999.0),
      ),
      (
        '-99999999999999999999999999999999999999999999999',
        Result.Ok(-99999999999999999999999999999999999999999999999.0),
      ),
      ('1.2e1', Result.Ok(1.2e1)),
      ('1.2e+1', Result.Ok(1.2e+1)),
      ('1.2e-1', Result.Ok(1.2e-1)),
      ('1.2E1', Result.Ok(1.2e1)),
      ('1.2E+1', Result.Ok(1.2e+1)),
      ('1.2E-1', Result.Ok(1.2e-1)),
      ('1e4', Result.Ok(1e4)),
      ('1E4', Result.Ok(1e4)),

      # Invalid input
      ('00', Result.Error(Error(ErrorKind.Unexpected('0'), offset: 1))),
      ('01', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 1))),
      ('01.0', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 1))),
      ('a', Result.Error(Error(ErrorKind.Unexpected('a'), offset: 0))),
      ('  a', Result.Error(Error(ErrorKind.Unexpected('a'), offset: 2))),
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
      ('1.', Result.Error(Error(ErrorKind.EndOfInput, offset: 2))),
      ('1.2e', Result.Error(Error(ErrorKind.EndOfInput, offset: 4))),
      ('1.2e+', Result.Error(Error(ErrorKind.EndOfInput, offset: 5))),
      ('1.2e-', Result.Error(Error(ErrorKind.EndOfInput, offset: 5))),
      ('1e', Result.Error(Error(ErrorKind.EndOfInput, offset: 2))),
      ('1E', Result.Error(Error(ErrorKind.EndOfInput, offset: 2))),
    ]

    for (inp, exp) in tests {
      let parser = PullParser.new(Buffer.new(inp))
      let got = parser.float

      t.equal(got, exp)

      if got.ok? { t.true(parser.buffer.empty?) }
    }
  })

  t.test('PullParser.number', fn (t) {
    let tests = [
      ('10', Result.Ok(Number.Int(10))),
      ('10.2', Result.Ok(Number.Float(10.2))),
    ]

    for (inp, exp) in tests {
      let parser = PullParser.new(Buffer.new(inp))
      let got = parser.number

      t.equal(got, exp)

      if got.ok? { t.true(parser.buffer.empty?) }
    }
  })

  t.test('PullParser.null', fn (t) {
    let tests = [
      # Valid input
      ('null', Result.Ok(nil)),

      # Invalid input
      ('10', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
      ('nu', Result.Error(Error(ErrorKind.EndOfInput, offset: 2))),
      ('nuf', Result.Error(Error(ErrorKind.Unexpected('f'), offset: 2))),
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
    ]

    for (inp, exp) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).null, exp)
    }
  })

  t.test('PullParser.bool', fn (t) {
    let tests = [
      # Valid input
      ('true', Result.Ok(true)),
      ('false', Result.Ok(false)),

      # Invalid input
      ('10', Result.Error(Error(ErrorKind.Unexpected('1'), offset: 0))),
      ('tr', Result.Error(Error(ErrorKind.EndOfInput, offset: 2))),
      ('tra', Result.Error(Error(ErrorKind.Unexpected('a'), offset: 2))),
      ('fa', Result.Error(Error(ErrorKind.EndOfInput, offset: 2))),
      ('fax', Result.Error(Error(ErrorKind.Unexpected('x'), offset: 2))),
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
    ]

    for (inp, exp) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).bool, exp)
    }
  })

  t.test('PullParser.value_type', fn (t) {
    let tests = [
      # Valid input
      ('10', Result.Ok(Type.Number)),
      ('-1', Result.Ok(Type.Number)),
      ('[', Result.Ok(Type.Array)),
      ('t', Result.Ok(Type.Bool)),
      ('f', Result.Ok(Type.Bool)),
      ('n', Result.Ok(Type.Null)),
      ('"a"', Result.Ok(Type.String)),

      # Invalid input
      ('x', Result.Error(Error(ErrorKind.Unexpected('x'), offset: 0))),
      ('', Result.Error(Error(ErrorKind.EndOfInput, offset: 0))),
    ]

    for (inp, exp) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).value_type, exp)
    }
  })

  t.test('PullParser.start_of_next_value', fn (t) {
    let tests = [
      ('10', Result.Ok(0)),
      ('  10', Result.Ok(2)),
      ('  ,', Result.Ok(2)),
    ]

    for (inp, exp) in tests {
      t.equal(PullParser.new(Buffer.new(inp)).start_of_next_value, exp)
    }
  })

  t.test('Json.fmt', fn (t) {
    let map = Map.new

    map.set('a', Json.Int(10))

    t.equal(fmt(Json.Int(42)), 'Int(42)')
    t.equal(fmt(Json.Float(42.0)), 'Float(42.0)')
    t.equal(fmt(Json.String('test')), 'String("test")')
    t.equal(fmt(Json.Array([Json.Int(10)])), 'Array([Int(10)])')
    t.equal(fmt(Json.Object(map)), 'Object({"a": Int(10)})')
    t.equal(fmt(Json.Bool(true)), 'Bool(true)')
    t.equal(fmt(Json.Bool(false)), 'Bool(false)')
    t.equal(fmt(Json.Null), 'Null')
  })

  t.test('Json.==', fn (t) {
    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new

    map1.set('a', Json.Int(10))
    map2.set('a', Json.Int(10))
    map3.set('a', Json.Int(10))

    t.equal(Json.Int(10), Json.Int(10))
    t.not_equal(Json.Int(10), Json.Int(20))
    t.not_equal(Json.Int(10), Json.Float(20.0))

    t.equal(Json.Float(10.0), Json.Float(10.0))
    t.not_equal(Json.Float(10.0), Json.Float(20.0))
    t.not_equal(Json.Float(10.0), Json.Int(10))

    t.equal(Json.String('foo'), Json.String('foo'))
    t.not_equal(Json.String('foo'), Json.String('bar'))
    t.not_equal(Json.String('foo'), Json.Int(10))

    t.equal(Json.Array([Json.Int(10)]), Json.Array([Json.Int(10)]))
    t.not_equal(Json.Array([Json.Int(10)]), Json.Array([Json.Int(20)]))
    t.not_equal(Json.Array([Json.Int(10)]), Json.Int(10))

    t.equal(Json.Object(map1), Json.Object(map2))
    t.not_equal(Json.Object(map3), Json.Object(Map.new))
    t.not_equal(Json.Object(Map.new), Json.Int(10))

    t.equal(Json.Bool(true), Json.Bool(true))
    t.not_equal(Json.Bool(true), Json.Bool(false))
    t.not_equal(Json.Bool(true), Json.Int(10))

    t.equal(Json.Null, Json.Null)
    t.not_equal(Json.Null, Json.Int(10))
  })

  t.test('Json.to_string', fn (t) {
    let map = Map.new

    map.set('a', Json.Int(1))
    map.set('b', Json.Int(2))

    t.equal(Json.Int(42).to_string, '42')
    t.equal(Json.Float(1.2).to_string, '1.2')
    t.equal(Json.String('foo').to_string, '"foo"')
    t.equal(Json.String('a\nb').to_string, '"a\\nb"')
    t.equal(Json.String('a\rb').to_string, '"a\\rb"')
    t.equal(Json.String('a\tb').to_string, '"a\\tb"')
    t.equal(Json.String('a\u{C}b').to_string, '"a\\fb"')
    t.equal(Json.String('a\u{8}b').to_string, '"a\\bb"')
    t.equal(Json.String('a\\b').to_string, '"a\\\\b"')
    t.equal(Json.Array([]).to_string, '[]')
    t.equal(Json.Array([Json.Int(1), Json.Int(2)]).to_string, '[1, 2]')
    t.equal(Json.Object(map).to_string, '{"a": 1, "b": 2}')
    t.equal(Json.Object(Map.new).to_string, '{}')
    t.equal(Json.Bool(true).to_string, 'true')
    t.equal(Json.Bool(false).to_string, 'false')
    t.equal(Json.Null.to_string, 'null')
  })

  t.test('Json.to_pretty_string', fn (t) {
    t.equal(Json.Int(42).to_pretty_string, '42')
    t.equal(Json.Float(1.2).to_pretty_string, '1.2')
    t.equal(Json.String('foo').to_pretty_string, '"foo"')
    t.equal(Json.String('a\nb').to_pretty_string, '"a\\nb"')
    t.equal(Json.String('a\rb').to_pretty_string, '"a\\rb"')
    t.equal(Json.String('a\tb').to_pretty_string, '"a\\tb"')
    t.equal(Json.String('a\u{C}b').to_pretty_string, '"a\\fb"')
    t.equal(Json.String('a\u{8}b').to_pretty_string, '"a\\bb"')
    t.equal(Json.String('a\\b').to_pretty_string, '"a\\\\b"')
    t.equal(Json.Bool(true).to_pretty_string, 'true')
    t.equal(Json.Bool(false).to_pretty_string, 'false')
    t.equal(Json.Null.to_pretty_string, 'null')

    t.equal(Json.Array([]).to_pretty_string, '[]')
    t.equal(
      Json.Array([Json.Int(1), Json.Int(2)]).to_pretty_string,
      '[
  1,
  2
]',
    )

    t.equal(
      Json.Array([Json.Array([Json.Int(1), Json.Int(2)])]).to_pretty_string,
      '[
  [
    1,
    2
  ]
]',
    )

    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new
    let map4 = Map.new

    map1.set('a', Json.Int(1))
    map1.set('b', Json.Int(2))
    map2.set('a', Json.Array([Json.Int(1), Json.Int(2)]))
    map3.set('a', Json.Int(1))
    map3.set('b', Json.Object(map2))
    map4.set('a', Json.Array([]))
    map4.set('b', Json.Object(Map.new))

    t.equal(Json.Object(Map.new).to_pretty_string, '{}')
    t.equal(
      Json.Object(map1).to_pretty_string,
      '{
  "a": 1,
  "b": 2
}',
    )

    t.equal(
      Json.Object(map3).to_pretty_string,
      '{
  "a": 1,
  "b": {
    "a": [
      1,
      2
    ]
  }
}',
    )

    t.equal(
      Json.Object(map4).to_pretty_string,
      '{
  "a": [],
  "b": {}
}',
    )
  })

  t.test('Json.parse with integers', fn (t) {
    t.equal(parse('0'), Result.Ok(Json.Int(0)))
    t.equal(parse('42'), Result.Ok(Json.Int(42)))
    t.equal(parse('  42'), Result.Ok(Json.Int(42)))
    t.equal(parse('42   '), Result.Ok(Json.Int(42)))
    t.equal(parse('\t42'), Result.Ok(Json.Int(42)))
    t.equal(parse('\r42'), Result.Ok(Json.Int(42)))
    t.equal(parse('-42'), Result.Ok(Json.Int(-42)))

    t.true(parse('00').error?)
    t.true(parse('10,').error?)
    t.true(parse('-').error?)
    t.true(parse('-01').error?)
    t.true(parse('01').error?)
    t.true(parse('1a').error?)
    t.true(parse('-a').error?)
    t.true(parse('- ').error?)
  })

  t.test('Json.parse with floats', fn (t) {
    t.equal(parse('  1.2'), Result.Ok(Json.Float(1.2)))
    t.equal(parse('1.2   '), Result.Ok(Json.Float(1.2)))
    t.equal(parse('1.2'), Result.Ok(Json.Float(1.2)))
    t.equal(parse('-1.2'), Result.Ok(Json.Float(-1.2)))
    t.equal(parse('1.2e+123'), Result.Ok(Json.Float(1.2e+123)))
    t.equal(parse('1.2e-123'), Result.Ok(Json.Float(1.2e-123)))
    t.equal(parse('1.2E+123'), Result.Ok(Json.Float(1.2e+123)))
    t.equal(parse('1.2E-123'), Result.Ok(Json.Float(1.2e-123)))
    t.equal(parse('-1.2E-123'), Result.Ok(Json.Float(-1.2e-123)))
    t.equal(parse('0.0'), Result.Ok(Json.Float(0.0)))
    t.equal(parse('0E0'), Result.Ok(Json.Float(0.0)))
    t.equal(parse('0e+1'), Result.Ok(Json.Float(0.0)))
    t.equal(parse('1.2E1'), Result.Ok(Json.Float(1.2e1)))
    t.equal(parse('1.2e1'), Result.Ok(Json.Float(1.2e1)))
    t.equal(
      parse('1.7976931348623157e+310'),
      Result.Ok(Json.Float(Float.infinity)),
    )
    t.equal(
      parse('4.940656458412465441765687928682213723651e-330'),
      Result.Ok(Json.Float(0.0)),
    )
    t.equal(
      parse(
        '-0.000000000000000000000000000000000000000000000000000000000000000000000000000001',
      ),
      Result.Ok(Json.Float(-1.0E-78)),
    )

    # These numbers are too big for regular integers, so we promote them to
    # floats.
    t.equal(
      parse('11111111111111111111111111111111111111111'),
      Result.Ok(Json.Float(11111111111111111111111111111111111111111.0)),
    )
    t.equal(
      parse('10000000000000000999'),
      Result.Ok(Json.Float(10000000000000000999.0)),
    )

    t.true(parse('00.0').error?)
    t.true(parse('1.2e').error?)
    t.true(parse('1.2e+').error?)
    t.true(parse('1.2e-').error?)
    t.true(parse('1.2E').error?)
    t.true(parse('1.2E+').error?)
    t.true(parse('1.2E-').error?)
    t.true(parse('1.2E+a').error?)
    t.true(parse('1.2E-a').error?)
    t.true(parse('0E').error?)
    t.true(parse('10.2,').error?)

    t.equal(
      parse('\n1.2e'),
      Result.Error(Error(ErrorKind.EndOfInput, offset: 5)),
    )
  })

  t.test('Json.parse with arrays', fn (t) {
    t.equal(parse('[]'), Result.Ok(Json.Array([])))
    t.equal(parse('[10]'), Result.Ok(Json.Array([Json.Int(10)])))
    t.equal(
      parse('[10, 20]'),
      Result.Ok(Json.Array([Json.Int(10), Json.Int(20)])),
    )

    t.true(parse('[').error?)
    t.true(parse(']').error?)
    t.true(parse('[,10]').error?)
    t.true(parse('[10,]').error?)
    t.true(parse('[10').error?)
    t.true(parse('[10,').error?)
    t.true(parse('[10true]').error?)
    t.true(parse('[],').error?)

    {
      let parser = Parser.new(Buffer.new('[[[[10]]]]'.to_byte_array))

      parser.max_depth = 2
      t.true(parser.parse.error?)
    }
  })

  t.test('Json.parse with booleans', fn (t) {
    t.equal(parse('true'), Result.Ok(Json.Bool(true)))
    t.equal(parse('false'), Result.Ok(Json.Bool(false)))

    t.true(parse('t').error?)
    t.true(parse('tr').error?)
    t.true(parse('tru').error?)
    t.true(parse('f').error?)
    t.true(parse('fa').error?)
    t.true(parse('fal').error?)
    t.true(parse('fals').error?)
  })

  t.test('Json.parse with NULL', fn (t) {
    t.equal(parse('null'), Result.Ok(Json.Null))

    t.true(parse('n').error?)
    t.true(parse('nu').error?)
    t.true(parse('nul').error?)
  })

  t.test('Json.parse with strings', fn (t) {
    t.equal(parse('"foo"'), Result.Ok(Json.String('foo')))
    t.equal(parse('"foo bar"'), Result.Ok(Json.String('foo bar')))
    t.equal(parse('"foo\\nbar"'), Result.Ok(Json.String('foo\nbar')))
    t.equal(parse('"foo\\tbar"'), Result.Ok(Json.String('foo\tbar')))
    t.equal(parse('"foo\\rbar"'), Result.Ok(Json.String('foo\rbar')))
    t.equal(parse('"foo\\bbar"'), Result.Ok(Json.String('foo\u{8}bar')))
    t.equal(parse('"foo\\fbar"'), Result.Ok(Json.String('foo\u{C}bar')))
    t.equal(parse('"foo\\"bar"'), Result.Ok(Json.String('foo"bar')))
    t.equal(parse('"foo\\/bar"'), Result.Ok(Json.String('foo/bar')))
    t.equal(parse('"foo\\\\bar"'), Result.Ok(Json.String('foo\\bar')))
    t.equal(parse('"foo\\u005Cbar"'), Result.Ok(Json.String('foo\\bar')))
    t.equal(parse('"foo\\u001Fbar"'), Result.Ok(Json.String('foo\u{1F}bar')))
    t.equal(parse('"\\uD834\\uDD1E"'), Result.Ok(Json.String('\u{1D11E}')))
    t.equal(
      parse('"\\uE000\\uE000"'),
      Result.Ok(Json.String('\u{E000}\u{E000}')),
    )

    t.true(parse('"\0"').error?)
    t.true(parse('"\n"').error?)
    t.true(parse('"\t"').error?)
    t.true(parse('"\r"').error?)
    t.true(parse('"\u{8}"').error?) # \b
    t.true(parse('"\u{C}"').error?) # \f

    t.true(parse('"\\x42"').error?)
    t.true(parse('"\\u1"').error?)
    t.true(parse('"\\u12"').error?)
    t.true(parse('"\\u123"').error?)
    t.true(parse('"\\u{XXXX}"').error?)
    t.true(parse('"\\uD834\\uE000"').error?)
    t.true(parse('"\\uD834\\uZZZZ"').error?)
    t.true(parse('"\\uDFFF\\uDFFF"').error?)

    t.equal(parse('"a'), Result.Error(Error(ErrorKind.EndOfInput, offset: 2)))
  })

  t.test('Json.parse with objects', fn (t) {
    let map1 = Map.new
    let map2 = Map.new
    let map3 = Map.new
    let map4 = Map.new
    let map5 = Map.new

    map2.set('a', Json.Int(10))
    map3.set('a', Json.Int(20))
    map4.set('a', Json.Int(10))
    map4.set('b', Json.Int(20))
    map5.set('a', Json.Int(10))
    map5.set('b', Json.Int(20))

    t.equal(parse('{}'), Result.Ok(Json.Object(map1)))
    t.equal(parse('{ "a" : 10 }'), Result.Ok(Json.Object(map2)))
    t.equal(parse('{"a": 10, "a": 20}'), Result.Ok(Json.Object(map3)))
    t.equal(parse('{"a": 10, "b": 20}'), Result.Ok(Json.Object(map4)))
    t.equal(
      parse(
        '{
          "a": 10,
          "b": 20
        }',
      ),
      Result.Ok(Json.Object(map5)),
    )

    t.true(parse('{').error?)
    t.true(parse('}').error?)
    t.true(parse('{{}}').error?)
    t.true(parse('{"a"}').error?)
    t.true(parse('{"a":}').error?)
    t.true(parse('{"a":10,}').error?)
    t.true(parse('{"a":10 "b": 20}').error?)
    t.true(parse('{a":10,}').error?)
    t.true(parse('{},').error?)
    t.true(parse('{"a": true} "x"').error?)

    {
      let bytes = Buffer.new('{"a": {"b": {"c": 10}}}'.to_byte_array)
      let parser = Parser.new(bytes)

      parser.max_depth = 2
      t.true(parser.parse.error?)
    }

    t.equal(
      parse('{"a"}'),
      Result.Error(Error(ErrorKind.Unexpected('}'), offset: 4)),
    )
  })

  t.test('Json.parse with Unicode BOMs', fn (t) {
    t.true(parse('\u{FEFF}10').error?)
    t.true(parse('\u{FFFE}10').error?)
    t.true(parse('\u{EF}\u{BB}\u{BF}10').error?)
  })

  t.test('Json.query', fn (t) {
    t.equal(Json.Int(42).query.as_int, Option.Some(42))
    t.equal(Json.String('test').query.as_int, Option.None)
  })

  t.test('Query.key', fn (t) {
    let map = Map.new

    map.set('name', Json.String('Alice'))

    let obj = Json.Object(map)

    t.equal(obj.query.key('name').as_string, Option.Some('Alice'))
    t.equal(obj.query.key('city').as_string, Option.None)
    t.equal(Json.Int(42).query.key('name').as_string, Option.None)
  })

  t.test('Query.index', fn (t) {
    t.equal(Json.Array([Json.Int(42)]).query.index(0).as_int, Option.Some(42))
    t.equal(Json.Array([Json.Int(42)]).query.index(1).as_int, Option.None)
    t.equal(Json.Int(42).query.index(0).as_int, Option.None)
  })

  t.test('Query.as_int', fn (t) {
    t.equal(Json.String('test').query.as_int, Option.None)
    t.equal(Json.Float(1.2).query.as_int, Option.None)
    t.equal(Json.Null.query.as_int, Option.None)
    t.equal(Json.Array([]).query.as_int, Option.None)
    t.equal(Json.Object(Map.new).query.as_int, Option.None)
    t.equal(Json.Int(42).query.as_int, Option.Some(42))
  })

  t.test('Query.as_float', fn (t) {
    t.equal(Json.String('test').query.as_float, Option.None)
    t.equal(Json.Null.query.as_float, Option.None)
    t.equal(Json.Int(42).query.as_float, Option.None)
    t.equal(Json.Array([]).query.as_float, Option.None)
    t.equal(Json.Object(Map.new).query.as_float, Option.None)
    t.equal(Json.Float(1.2).query.as_float, Option.Some(1.2))
  })

  t.test('Query.as_string', fn (t) {
    t.equal(Json.Null.query.as_string, Option.None)
    t.equal(Json.Int(42).query.as_string, Option.None)
    t.equal(Json.Float(1.2).query.as_string, Option.None)
    t.equal(Json.Array([]).query.as_string, Option.None)
    t.equal(Json.Object(Map.new).query.as_string, Option.None)
    t.equal(Json.String('test').query.as_string, Option.Some('test'))
  })

  t.test('Query.as_array', fn (t) {
    t.equal(Json.Null.query.as_array, Option.None)
    t.equal(Json.Int(42).query.as_array, Option.None)
    t.equal(Json.Float(1.2).query.as_array, Option.None)
    t.equal(Json.Object(Map.new).query.as_array, Option.None)
    t.equal(Json.String('test').query.as_array, Option.None)
    t.equal(
      Json.Array([Json.Int(42)]).query.as_array,
      Option.Some(ref [Json.Int(42)]),
    )
  })

  t.test('Query.as_object', fn (t) {
    t.equal(Json.Null.query.as_object, Option.None)
    t.equal(Json.Int(42).query.as_object, Option.None)
    t.equal(Json.Float(1.2).query.as_object, Option.None)
    t.equal(Json.String('test').query.as_object, Option.None)
    t.equal(Json.Array([Json.Int(42)]).query.as_object, Option.None)
    t.equal(Json.Object(Map.new).query.as_object, Option.Some(ref Map.new))
  })

  t.test('Query.as_bool', fn (t) {
    t.equal(Json.Bool(true).query.as_bool, Option.Some(true))
    t.equal(Json.Bool(false).query.as_bool, Option.Some(false))
    t.equal(Json.Int(42).query.as_bool, Option.None)
  })

  t.test('ObjectBuilder.string', fn (t) {
    let obj = Json.object.string('key', 'value')

    t.equal(obj.map.get('key'), Result.Ok(ref Json.String('value')))
  })

  t.test('ObjectBuilder.int', fn (t) {
    let obj = Json.object.int('key', 42)

    t.equal(obj.map.get('key'), Result.Ok(ref Json.Int(42)))
  })

  t.test('ObjectBuilder.float', fn (t) {
    let obj = Json.object.float('key', 42.0)

    t.equal(obj.map.get('key'), Result.Ok(ref Json.Float(42.0)))
  })

  t.test('ObjectBuilder.bool', fn (t) {
    let obj = Json.object.bool('key', true)

    t.equal(obj.map.get('key'), Result.Ok(ref Json.Bool(true)))
  })

  t.test('ObjectBuilder.null', fn (t) {
    let obj = Json.object.null('key')

    t.equal(obj.map.get('key'), Result.Ok(ref Json.Null))
  })

  t.test('ObjectBuilder.object', fn (t) {
    let obj = Json.object.object('key', Json.object.string('sub', 'value'))

    t.equal(
      obj.map.get('key'),
      Result.Ok(
        ref Json.Object(
          {
            let map = Map.new

            map.set('sub', Json.String('value'))
            map
          },
        ),
      ),
    )
  })

  t.test('ObjectBuilder.array', fn (t) {
    let obj = Json.object.array('key', Json.array.int(10).int(20))

    t.equal(
      obj.map.get('key'),
      Result.Ok(ref Json.Array([Json.Int(10), Json.Int(20)])),
    )
  })

  t.test('ObjectBuilder.into_pretty_string', fn (t) {
    let val = Json.object.string('key', 'value').into_pretty_string

    t.equal(val, '{\n  "key": "value"\n}')
  })

  t.test('ObjectBuilder.into_string', fn (t) {
    let val = Json.object.string('key', 'value').into_string

    t.equal(val, '{"key": "value"}')
  })

  t.test('ArrayBuilder.string', fn (t) {
    let ary = Json.array.string('value')

    t.equal(ary.values, ref [Json.String('value')])
  })

  t.test('ArrayBuilder.int', fn (t) {
    let ary = Json.array.int(10)

    t.equal(ary.values, ref [Json.Int(10)])
  })

  t.test('ArrayBuilder.float', fn (t) {
    let ary = Json.array.float(10.0)

    t.equal(ary.values, ref [Json.Float(10.0)])
  })

  t.test('ArrayBuilder.bool', fn (t) {
    let ary = Json.array.bool(true)

    t.equal(ary.values, ref [Json.Bool(true)])
  })

  t.test('ArrayBuilder.null', fn (t) {
    let ary = Json.array.null

    t.equal(ary.values, ref [Json.Null])
  })

  t.test('ArrayBuilder.object', fn (t) {
    let ary = Json.array.object(Json.object.string('key', 'value'))

    t.equal(
      ary.values,
      ref [
        Json.Object(
          {
            let map = Map.new

            map.set('key', Json.String('value'))
            map
          },
        ),
      ],
    )
  })

  t.test('ArrayBuilder.array', fn (t) {
    let ary = Json.array.array(Json.array.int(10).int(20))

    t.equal(ary.values, ref [Json.Array([Json.Int(10), Json.Int(20)])])
  })

  t.test('ArrayBuilder.into_pretty_string', fn (t) {
    let val = Json.array.int(10).into_pretty_string

    t.equal(val, '[\n  10\n]')
  })

  t.test('ArrayBuilder.into_string', fn (t) {
    let val = Json.array.int(10).into_string

    t.equal(val, '[10]')
  })
}
