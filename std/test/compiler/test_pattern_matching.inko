import std.drop (Drop, drop)
import std.test (Tests)

type enum Letter {
  case A
  case B
  case C
}

type enum State {
  case Closed
  case Button(State)
}

type Dummy {}

type enum Transition {
  case Empty(Dummy)
  case Split(Transition)
}

type Person {
  let @name: String
}

type Value {
  let mut @dropped: Int

  fn static new -> Value {
    Value(0)
  }
}

type ValueRef {
  let @value: mut Value

  fn static new(value: mut Value) -> ValueRef {
    ValueRef(value)
  }
}

impl Drop for ValueRef {
  fn mut drop {
    @value.dropped += 1
  }
}

fn pub tests(t: mut Tests) {
  # https://github.com/inko-lang/inko/issues/363
  t.test('match with OR patterns and a guard', fn (t) {
    let number = 42
    let result = match Letter.A {
      case A or B if number == 42 -> true
      case _ -> false
    }

    t.true(result)
  })

  # https://github.com/inko-lang/inko/issues/519
  #
  # This bug would result in a reference counting underflow. If you then created
  # a new reference the count would be zero, instead of one, and that would
  # allow the drop(), which is invalid. With the fixes in place, the drop() will
  # correctly panic because references still exist.
  t.panic("match doesn't drop match registers prematurely", fn {
    let state = match State.Button(State.Closed) {
      case Closed -> State.Closed
      case state -> state
    }

    let _temp = ref state

    drop(state)
  })

  t.no_panic('match with a wildcard drops all components', fn {
    let a = Letter.A
    let b = Letter.B

    match (ref a, ref b) {
      case (A, A) -> true
      case _ -> false
    }
  })

  t.no_panic("match doesn't drop deeply nested bindings prematurely", fn {
    let trans = Transition.Split(Transition.Empty(Dummy()))

    match ref trans {
      case Split(Empty(_state1)) -> {}
      case _ -> {}
    }
  })

  # This test checks if the `mut a` reference is dropped at the end of the match
  # arm, because the first match case returns `Nil`.
  t.no_panic('match drops case return values when they are to be ignored', fn {
    let a = [10]

    match 10 {
      case 5 -> nil
      case _ -> mut a
    }
  })

  # This fails because `_b` still contains a ref to `a`, which would be invalid
  # after the match expression.
  t.panic('Destructuring an owned value with existing references', fn {
    let a = Person('Alice')
    let _b = ref a

    match a {
      case { @name = _ } -> nil
    }
  })

  t.no_panic('Dropping a value ignored by match cases', fn {
    let a = [10, 20]
    let b = [ref a]

    match Option.Some(b) {
      case None -> nil
      case Some(v) -> v
    }
  })

  t.test('Pattern matching against an Array', fn (t) {
    let res = match [10, 20] {
      case [10, 20] -> true
      case _ -> false
    }

    t.true(res)

    let val = Value.new
    let owned = [ValueRef.new(val)]

    match ref owned {
      case [_] -> {}
      case _ -> {}
    }

    match mut owned {
      case [_] -> {}
      case _ -> {}
    }

    match owned {
      case [_] -> {}
      case _ -> {}
    }

    t.equal(val.dropped, 1)
    val.dropped = 0

    match [ValueRef.new(val)] {
      case [_] if false -> {}
      case _ignore -> {}
    }

    t.equal(val.dropped, 1)
  })

  t.test('Pattern matching an Array against a binding', fn (t) {
    t.equal(
      match [10, 20] {
        case val -> val.size
      },
      2,
    )
    t.equal(
      match [10, 20] {
        case [10] -> -1
        case val -> val.size
      },
      2,
    )
    t.equal(
      match [10, 20] {
        case [10, 30] -> -1
        case val -> val.size
      },
      2,
    )
    t.equal(
      match [10, 20] {
        case [10, 20] if false -> -1
        case val -> val.size
      },
      2,
    )
  })

  t.test('Pattern matching against a ByteArray', fn (t) {
    t.true(
      match ByteArray.from_array([10, 20]) {
        case [10, 20] -> true
        case _ -> false
      },
    )

    t.true(
      match ref ByteArray.from_array([10, 20]) {
        case [10, 20] -> true
        case _ -> false
      },
    )

    t.true(
      match mut ByteArray.from_array([10, 20]) {
        case [10, 20] -> true
        case _ -> false
      },
    )
  })

  t.test('Pattern matching a String against a Slice[String]', fn (t) {
    let val = 'abc'

    t.true(
      match val.slice(0, 3) {
        case 'abc' -> true
        case _ -> false
      },
    )
  })
}
