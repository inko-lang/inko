import builder.html (Document, Element)
import docs.menu (Menu)
import docs.url (link_from, relative?)
import markdown.html (Filter, TableOfContents)
import std.bytes (Bytes)
import std.string (StringBuffer)
import wobsite (Page)
import wobsite.url (relative_to_absolute)

fn starts_with_capital?[B: Bytes](value: ref B) -> Bool {
  let byte = value.get(0).or(-1)

  byte >= 65 and byte <= 90
}

# A filter that automatically inserts a table of contents.
type AutoTableOfContents {
  fn static new -> AutoTableOfContents {
    AutoTableOfContents()
  }

  fn add_marker(document: mut Document) {
    document.div.attr('class', 'toc')
  }
}

impl Filter for AutoTableOfContents {
  fn pub mut run(document: mut Document) {
    add_marker(document)
    TableOfContents.new.run(document)
  }
}

type AddCopyButton {
  fn static new -> AddCopyButton {
    AddCopyButton()
  }
}

impl Filter for AddCopyButton {
  fn pub mut run(document: mut Document) {
    for n in document.nodes.iter_mut {
      let el = match n {
        case Element(e) if e.name == 'div' -> {
          match e.attributes.get('class') {
            case Ok('highlight') -> e
            case _ -> next
          }
        }
        case _ -> next
      }

      el.button.attr('class', 'copy').with(fn (btn) {
        btn.i.attr('class', 'icon-clipboard')
        btn.span.attr('class', 'copy-text').text(' Copy')
        btn.span.attr('class', 'copied-text').text(' Copied!')
      })
    }
  }
}

# A filter that turns relative document links (e.g. `[](ivm)`) into the correct
# URLs, optionally setting the link text if left out. This makes it easier to
# link to different documents.
type RelativeLinks {
  let @menu: ref Menu
  let @page: ref Page

  fn update(element: mut Element) {
    if element.name != 'a' { return }

    let href = match element.attributes.get('href') {
      case Ok(v) if relative?(v) -> v
      case _ -> return
    }

    let rel = link_from(@page, href)

    match title(rel) {
      case Some(v) if element.nodes.empty? -> element.text(v)
      case _ -> {}
    }

    element.attributes.set('href', rel)
  }

  fn title(relative: String) -> Option[String] {
    let mut abs = relative_to_absolute(@page.url, relative, as_file: false)

    if !abs.ends_with?('/') { abs = abs + '/' }

    @menu.titles.get(abs).ok
  }
}

impl Filter for RelativeLinks {
  fn pub mut run(document: mut Document) {
    let nodes = document.nodes.iter_mut.to_array

    loop {
      match nodes.pop {
        case Some(Element(el)) -> {
          update(el)
          nodes.append(el.nodes.iter_mut.to_array)
        }
        case Some(_) -> {}
        case _ -> break
      }
    }
  }
}

# A filter that generates links to the standard library.
type StandardLibraryLinks {
  let @base_url: String

  fn update(element: mut Element) {
    if element.name != 'a' { return }

    let text = match element.attributes.get('href') {
      case Ok(v) if v.size > 0 -> v
      case _ -> return
    }

    let uri_chunks = text.split('://')

    let frag_rest = match (uri_chunks.next, uri_chunks.next) {
      case (Some('method'), Some(v)) -> ('#method.', v)
      case (Some('field'), Some(v)) -> ('#field.', v)
      case (Some('constructor'), Some(v)) -> ('#constructor.', v)
      case _ if text.starts_with?('std.') -> ('', text.to_slice)
      case _ -> return
    }

    let frag = frag_rest.0
    let text = frag_rest.1
    let path = StringBuffer.new
    let steps = text.split('.').to_array
    let len = steps.size

    for (idx, val) in steps.iter.with_index {
      if frag.size > 0 and idx == (len - 1) {
        path.push(frag)
        path.push(val.to_string)
      } else {
        path.push(val.to_string)
        path.push('/')
      }
    }

    element.attr('href', '${@base_url}/module/${path.into_string}').attr(
      'title',
      text.to_string,
    )

    if element.nodes.empty? {
      let tail = steps.last.get
      let text = if frag.size > 0 {
        '${steps.get(steps.size - 2).get}.${tail}'
      } else if starts_with_capital?(tail) {
        tail.to_string
      } else {
        text.to_string
      }

      element.code.text(text)
    }
  }
}

impl Filter for StandardLibraryLinks {
  fn pub mut run(document: mut Document) {
    let nodes = document.nodes.iter_mut.to_array

    loop {
      match nodes.pop {
        case Some(Element(el)) -> {
          update(el)
          nodes.append(el.nodes.iter_mut.to_array)
        }
        case Some(_) -> {}
        case _ -> break
      }
    }
  }
}
